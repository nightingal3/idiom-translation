<HTML><HEAD><META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<script type="text/javascript">
<!--

IE = (navigator.appName == "Microsoft Internet Explorer")

function lookup(e) {
  if(IE){
    range = document.selection.createRange()
    str = range.text
  }else{
    str = document.getSelection()
  }
  code = str.charCodeAt(0)
  if(code >= 0 && code <= 127){
    str = str.replace(/^[^a-zA-Z0-9]+/,"")
    str = str.replace(/[^a-zA-Z0-9]+$/,"")
    if(str != ""){
      win = open("http://dictionary.goo.ne.jp/search.php?MT="+escape(str)+"&kind=&mode=0", "Goo", "width=600,height=400,scrollbars=yes")
      win.focus()
    }
  } 
}
function showLayer(id){ 
    if(document.getElementById){
        document.getElementById(id).style.visibility = 'visible'
    }else if(document.all){
        document.all(id).style.visibility = 'visible'
    }else if(document.layers){
        document.layers[id].visibility = 'show'
    }
}

reJ = new RegExp('J');
reE = new RegExp('E');
function hideLayer(id){
    if(id.match(reJ) && !document.F.CJ.checked) return
    if(id.match(reE) && !document.F.CE.checked) return
    if(document.getElementById){
        document.getElementById(id).style.visibility = 'hidden'
    }else if(document.all){
        document.all(id).style.visibility = 'hidden'
    }else if(document.layers){
        document.layers[id].visibility = 'hidden'
    }
}
function layerIsVisible(id){
    if(document.getElementById){
        return (document.getElementById(id).style.visibility == 'visible')
    }else if(document.all){
        return (document.all(id).style.visibility == 'visible')
    }else if(document.layers){
        return (document.layers[id].visibility == 'show')
    }
}
function toggleLayer(id){
    if(layerIsVisible(id)){
        hideLayer(id)
    }else{
        showLayer(id)
    }
}

function showOrHideE(eng, jp){
    if(document.F.CE.checked){
        hideLayer(eng)
    }else{
        showLayer(jp)
    }
}

function showOrHideJ(jp, eng){
    if(document.F.CJ.checked){
        hideLayer(jp)
    }else{
        showLayer(eng)
    }
}
				

function hasAttribute2(obj, attr){
    if(IE){
        return true
    }else if(document.getElementById){
        return obj.hasAttribute(attr)
    }else{
        return true
    }
}

reTAB = new RegExp("TAB")
function hideJE(str) {
    re = new RegExp(str);
    spans = document.getElementsByTagName("TD")
    for(i=0; i<spans.length; i++){
        if(hasAttribute2(spans[i], "id")){
            id = spans[i].getAttribute("id")
            if(id.match(re)){
	        hideLayer(id)
            }else if(id.match(reTAB) &&
            (document.F.CJ.checked || document.F.CE.checked)){
                spans[i].setAttribute('BGCOLOR', "#FFFFFF")
            }
	}
    }
}
function showJE(str) {
    re = new RegExp(str);
    spans = document.getElementsByTagName("TD")
    for(i=0; i<spans.length; i++){
        if(hasAttribute2(spans[i], "id")){
            id = spans[i].getAttribute("id")
            if(id.match(re)){
	        showLayer(id)
            }else if(id.match(reTAB) &&
            (!document.F.CJ.checked && !document.F.CE.checked)){
                spans[i].setAttribute('BGCOLOR', "#F0F0F0")
	    }
	}
    }
}
function addRules (){
    obj = document.getElementById('TRANSPAIR');
    obj.rules = 'ALL'
    obj.frame = 'BORDER'
}

function removeRules (){
    obj = document.getElementById('TRANSPAIR');
    obj.rules = 'NONE'
    obj.frame = 'VOID'
}

function onoffJ(){
    if (document.F.CJ.checked) {
        hideJE('J');
        addRules();
    }else{
        showJE('J');
        if(!document.F.CE.checked){
            removeRules();
        }
    }
}
function onoffE(){
    if (document.F.CE.checked) {
        hideJE('E');
        addRules();
    }else{
        showJE('E');
        if(!document.F.CJ.checked){
            removeRules();
        }
    }
}
				
// -->
</script>
</HEAD><BODY BGCOLOR=#FFFFFF><div align=right><a href="../data/titles-ja-pages.htm">タイトル順</a>/<a href="../data/authors-pages.htm">著者順</a>/<a href="../data/translators-pages.htm">訳者順</a>/<a href="../index.html">ホーム</a></div><h2>RMS lecture at KTH / Richard M. Stallman 著</h2><h2>RMS スウェーデン王立工科大学講演  / リチャード・M・ストールマン 著 / 山形浩生 訳</h2><p>Annotator: 高橋真弓</p><div align=right><form name="F"><input type="checkbox" name="CE" onclick="onoffE()">英語文を消す <input type="checkbox" name="CJ" onclick="onoffJ()">日本語文を消す <br>(反対側の文を押すと消えた文が出る)</form></div>オリジナル:<a href="../org/rmse.txt">英語文</a>&<a href="../org/rmsj.txt">日本語文</a> / <a href="../manual-alignment/rms.alm">対訳データ</a> / <a href="#preamble">このページにある対訳文について</a>
<TITLE>5 of RMS lecture at KTH</TITLE>
<hr>
<a href="rms-4.htm">prev</a>
<a href="rms-0.htm">0</a>
<a href="rms-1.htm">1</a>
<a href="rms-2.htm">2</a>
<a href="rms-3.htm">3</a>
<a href="rms-4.htm">4</a>
<5>
<a href="rms-6.htm">6</a>
<a href="rms-7.htm">7</a>
<a href="rms-8.htm">8</a>
<a href="rms-9.htm">9</a>
<a href="rms-6.htm">next</a>
<a name="tableBegin"></a><HR><span><TABLE BGCOLOR=#F0F0F0 ID=TRANSPAIR FRAME=VOID RULES=NONE BORDERCOLOR=#000000>
<!-- TRANS_PAIR BEGIN --><TR id="501"><a name="501"><TD id="E501" onclick="javascript:toggleLayer('J501')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> If you're trying to index by something, then most of the time that code will become invalid if the index quantity is in memory, 
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J501" onclick="javascript:toggleLayer('E501')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 何かをインデックスにしてアドレスを決めるとき、そのインデックス値がメモリに入ってたら、そのコードはほとんどの場合役にたたなくなる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="502"><a name="502"><TD id="E502" onclick="javascript:toggleLayer('J502')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> except in a few cases on some machines where you can it with indirect addressing.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J502" onclick="javascript:toggleLayer('E502')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ただし、間接アドレッシングでそれができるマシンは別だけど。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="503"><a name="503"><TD id="E503" onclick="javascript:toggleLayer('J503')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In the cases when you're doing auto-increment on an index register you may have to copy the value into a register, do the instruction, and then copy the incremented value back to the memory slot where it really lives.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J503" onclick="javascript:toggleLayer('E503')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> インデックスレジスタに自動インクリメントとかかけてるときには、その値をレジスタに入れて、命令をやって、インクリメントした値をほんとにあるべきメモリのスロットに戻してやらなきゃならないかもしれない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="504"><a name="504"><TD id="E504" onclick="javascript:toggleLayer('J504')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> There's got room for a lot of hair, and I've not finished implementing all the hair needed to make really fully efficient.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J504" onclick="javascript:toggleLayer('E504')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> まだまだいろいろ小細工の余地はあって、ぼくもまだ十分に効率よくなるほどの細工は実装しきってない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="505"><a name="505"><TD id="E505" onclick="javascript:toggleLayer('J505')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This compiler currently works by having a parser which turns C code into effectively a syntax tree annotated with C datatype information. 
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J505" onclick="javascript:toggleLayer('E505')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> このコンパイラは、C のコードをとって、それを実質的にはCデータ型の注釈がついた構文ツリーに変えるパーサーを持つことでいまは動いてる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="506"><a name="506"><TD id="E506" onclick="javascript:toggleLayer('J506')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Then another pass which looks at that tree and generates code like this [LISP like code].
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J506" onclick="javascript:toggleLayer('E506')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それから次のパスではそのツリーをながめて、こんな（ LISP 状の）コードを生成する。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="507"><a name="507"><TD id="E507" onclick="javascript:toggleLayer('J507')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Then several optimization passes.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J507" onclick="javascript:toggleLayer('E507')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それから最適化パスがいくつかある。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="508"><a name="508"><TD id="E508" onclick="javascript:toggleLayer('J508')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> One to handle things like jumps across jumps, jumps to jumps, jumps to .+1, all of which can be immediately simplified.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J508" onclick="javascript:toggleLayer('E508')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 一つには、ジャンプからジャンプ、ジャンプへのジャンプ、.+1 へのジャンプなんかを扱うもので、こんなのはみんなすぐに簡素化できる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="509"><a name="509"><TD id="E509" onclick="javascript:toggleLayer('J509')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Then a common subexpression recognizer, then finding basic blocks, and performing dataflow-analysis, so that it can tell for each instruction which values are used in that instruction and never used afterward.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J509" onclick="javascript:toggleLayer('E509')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それからよくある副次式の認識、さらに基本ブロック探し、それからデータフロー分析をして、どの命令にどの値が使われて、その後まったく使われないのはどれかがわかる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="510"><a name="510"><TD id="E510" onclick="javascript:toggleLayer('J510')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And also linking each instruction to the places where the values it uses were generated, so if I have one instruction which generates pseudo register R[28], and then another instruction later which uses R[28] and it's the first place to use R[28], I make the second one point back to the first one, and this pointer is used to control the attempts to combine the instructions.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J510" onclick="javascript:toggleLayer('E510')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そしてそれぞれの命令を、それが使う値の生成場所とリンクさせて、だから疑似レジスタ R[28] を生成するある命令があって、別の命令があとでR[28] を使って、それが R[28] を使う最初の場所だったら、二番目のやつが最初のやつを戻って指すようにして、このポインタが、命令を組み合わせようとするときの制御に使われる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="511"><a name="511"><TD id="E511" onclick="javascript:toggleLayer('J511')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You don't combine adjacent instructions, you combine an instruction that uses a value with the instruction that produced that value.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J511" onclick="javascript:toggleLayer('E511')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 隣り合った命令を組み合わせるんじゃなくて、ある値を使う命令と、それを生成する命令とを組み合わせるの。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="512"><a name="512"><TD id="E512" onclick="javascript:toggleLayer('J512')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Even if there are other instructions in between, they don't matter for this, you just have to check them to make sure they don't do anything to interfere.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J512" onclick="javascript:toggleLayer('E512')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 間にほかの命令がはさまっていても、ここでは関係なくて、単に介入してきたりしないかどうかチェックしなきゃならないだけ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="513"><a name="513"><TD id="E513" onclick="javascript:toggleLayer('J513')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Then after the combiner comes the dynamic register allocator, and finally something to convert it into assembly code.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J513" onclick="javascript:toggleLayer('E513')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それで組み合わせ機能が動的レジスタ割り当てをやって、そして最後に、アセンブリコードにする部分がくる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="514"><a name="514"><TD id="E514" onclick="javascript:toggleLayer('J514')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In the Arizona compiler the instruction recognizer was generated with LEX.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J514" onclick="javascript:toggleLayer('E514')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> アリゾナコンパイラでは、命令認識部分は LEX で生成されてた。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="515"><a name="515"><TD id="E515" onclick="javascript:toggleLayer('J515')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Your machine description was simply a LEX program that LEX would turn into a C function to recognize valid instructions as strings.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J515" onclick="javascript:toggleLayer('E515')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> マシン記述はただの LEX プログラムで、LEX はそれを C 関数にして、有効な命令を文字列として認識する。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="516"><a name="516"><TD id="E516" onclick="javascript:toggleLayer('J516')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> What I have is instead a special purpose decision tree that's generated from a machine description written in this syntax as if it were LISP.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J516" onclick="javascript:toggleLayer('E516')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ぼくがかわりにつけたのは、特別な専用デシジョン・ツリーで、まるでLISP みたいなこの構文で書かれたマシン記述から生成される。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="517"><a name="517"><TD id="E517" onclick="javascript:toggleLayer('J517')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And this recognizer is used as a subroutine for many different parts of the compiler.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J517" onclick="javascript:toggleLayer('E517')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そしてこの認識部分は、コンパイラ内のいろんな部分のためのサブルーチンとして使われてる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="518"><a name="518"><TD id="E518" onclick="javascript:toggleLayer('J518')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Currently this compiler runs about as fast as PCC.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J518" onclick="javascript:toggleLayer('E518')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> いまんとこ、このコンパイラは PCC くらいの速度で走る。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="519"><a name="519"><TD id="E519" onclick="javascript:toggleLayer('J519')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> It runs noticeably faster if you tell it not to do the hairy register allocation, in which case it allocates registers the same way as PCC does.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J519" onclick="javascript:toggleLayer('E519')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> レジスタ割り当ての小細工をするなといえば、目に見えて速くはなって、それだと PCC とレジスタの割り当ては同じ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="520"><a name="520"><TD id="E520" onclick="javascript:toggleLayer('J520')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In its super hairy mode it does a much better job of allocating registers than PCC, and I observe that for the VAX it generates the best code I've seen from any C compiler on the VAX.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J520" onclick="javascript:toggleLayer('E520')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 超小細工モードだと、PCC よりずっと上手にレジスタ割り当てをやって、ぼくの見立てでは VAX だと VAX 用のどの C コンパイラよりもいいコードを生成してくれるね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="521"><a name="521"><TD id="E521" onclick="javascript:toggleLayer('J521')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> For the 68000 the code is still not ideal.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J521" onclick="javascript:toggleLayer('E521')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 68000 だとコードはまだ理想的とはいえない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="522"><a name="522"><TD id="E522" onclick="javascript:toggleLayer('J522')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> I can see places where early stages do things that are not the best, because it can't fully look ahead.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J522" onclick="javascript:toggleLayer('E522')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 前段で、十分に先を見通してないから、最高とはいえないようなことをしてる部分が見える。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="523"><a name="523"><TD id="E523" onclick="javascript:toggleLayer('J523')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> It has a choice in an early stage, and it does the thing that it thinks is going to be best, but really if it did the other one, a later stage is actually smart enough to do something even better.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J523" onclick="javascript:toggleLayer('E523')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 前段では選択の余地があって、だからそいつが一番いいと思うことをやるんだけれど、でも別のやりかたをしてくれたら後段のほうが頭がいいから、もっといい処理をしてくれたはず。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="524"><a name="524"><TD id="E524" onclick="javascript:toggleLayer('J524')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But the early stage doesn't know what the later stage is going to do, so I have more work to do on some of these things.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J524" onclick="javascript:toggleLayer('E524')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だけど前段は、後段がそんなことしてくれるとは知らないので、だからそういうのでもっと手を入れないと。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="525"><a name="525"><TD id="E525" onclick="javascript:toggleLayer('J525')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Sometimes this causes it to free up registers unnecessarily.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J525" onclick="javascript:toggleLayer('E525')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ときどきこのせいで、レジスタが無用に解放されちゃう。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="526"><a name="526"><TD id="E526" onclick="javascript:toggleLayer('J526')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Because when things wind up in memory and it needs to copy them into registers, it needs to get registers to copy them into.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J526" onclick="javascript:toggleLayer('E526')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だって、何かがメモリのほうにおさまって、それをレジスタにコピーしなきゃならなかったら、まずはそれをコピーするためのレジスタが必要になる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="527"><a name="527"><TD id="E527" onclick="javascript:toggleLayer('J527')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This means taking registers that it has already allocated to, and kicking those temporary quantities out to stack slots.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J527" onclick="javascript:toggleLayer('E527')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これはつまり、すでに割り当てたレジスタを持ってきて、一時的な値をスタックのスロットに蹴り出すってことだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="528"><a name="528"><TD id="E528" onclick="javascript:toggleLayer('J528')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Of course this may invalidate more instructions now that those things are in memory, not registers, so it has to check again and again.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J528" onclick="javascript:toggleLayer('E528')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> もちろんそういうのがレジスタからメモリにいっちゃうと、さらにほかの命令が無効になるかもしれなくて、だから何度も何度もチェックが必要になる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="529"><a name="529"><TD id="E529" onclick="javascript:toggleLayer('J529')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Sometimes it thinks it has to copy things to registers and really it isn't going to have to, so it may free up too many things and thus not use all the registers that it could.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J529" onclick="javascript:toggleLayer('E529')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ときどきこいつは、何かをレジスタにコピーしなきゃと思うんだけど、でもそんな必要がなかったりして、すると必要以上のレジスタを解放しちゃって、使えるレジスタを使い切らなかったりするんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="530"><a name="530"><TD id="E530" onclick="javascript:toggleLayer('J530')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> (Question: Do you have a code generator for 32000?)
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J530" onclick="javascript:toggleLayer('E530')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> （質問: 32000 用のコードジェネレータはありますか？）
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="531"><a name="531"><TD id="E531" onclick="javascript:toggleLayer('J531')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Not yet, but again, it's not a code generator it's just a machine description that you need.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J531" onclick="javascript:toggleLayer('E531')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> まだだけど、でも言っとくと、要るのはコードジェネレータじゃなくて、ただのマシンの記述だけね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="532"><a name="532"><TD id="E532" onclick="javascript:toggleLayer('J532')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> A list of all the machine instructions described in this [LISP like] form.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J532" onclick="javascript:toggleLayer('E532')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そのマシンの命令が全部こんなふうに（LISP っぽい形式で）リストしてあればいい。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="533"><a name="533"><TD id="E533" onclick="javascript:toggleLayer('J533')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So in fact aside from the work of implementing the idea of constraints on which arguments can be in registers and which kind of registers, which is something which was needed for the 68000 and was not needed for the VAX, the work of porting this compiler from the VAX to the 68000 just took a few days.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J533" onclick="javascript:toggleLayer('E533')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから実際問題として、どの引数がレジスタに入れてとかどのレジスタにとかいう制約条件の考え方を実装するところは別にして、これは 68000 には必要だけど VAXでは不要だった話なんだけど、でもそれを別にすれば、このコンパイラを VAX から68000 に移植するのはほんの数日しかかからなかった。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="534"><a name="534"><TD id="E534" onclick="javascript:toggleLayer('J534')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So it's very easy to port.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J534" onclick="javascript:toggleLayer('E534')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから、すごく簡単に移植できるんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="535"><a name="535"><TD id="E535" onclick="javascript:toggleLayer('J535')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> The compiler currently generates assembler code and it can generate debugging information either in the format that DBX wants, or in the special internal format of GDB.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J535" onclick="javascript:toggleLayer('E535')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> コンパイラはいまはアセンブラ・コードを生成して、デバッグ情報を DBX の求める形式でも出せるし、GDB の特別な内部形式でも出せる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="536"><a name="536"><TD id="E536" onclick="javascript:toggleLayer('J536')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> I'd say the only work needed on this compiler is in three areas.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J536" onclick="javascript:toggleLayer('E536')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ぼくに言わせれば、このコンパイラで手をいれなきゃいけないのは、あとたった 3 分野だけ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="537"><a name="537"><TD id="E537" onclick="javascript:toggleLayer('J537')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> One: I have to add a ``profiling'' feature,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J537" onclick="javascript:toggleLayer('E537')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible">  * 「プロファイリング」機能をつけなきゃならない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="538"><a name="538"><TD id="E538" onclick="javascript:toggleLayer('J538')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> like the one that the UNIX compilers have.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J538" onclick="javascript:toggleLayer('E538')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> UNIX のコンパイラにあるやつ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="539"><a name="539"><TD id="E539" onclick="javascript:toggleLayer('J539')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Two: I have to make these register allocation things smarter,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J539" onclick="javascript:toggleLayer('E539')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible">  * レジスタ割り当てをもう少し賢くしないとダメ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="540"><a name="540"><TD id="E540" onclick="javascript:toggleLayer('J540')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> so that I can stop seeing stupid things appearing in the output.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J540" onclick="javascript:toggleLayer('E540')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 出力にバカな代物が出てこないようにする。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="541"><a name="541"><TD id="E541" onclick="javascript:toggleLayer('J541')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And three: There are various bugs, things that doesn't handle correctly yet,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J541" onclick="javascript:toggleLayer('E541')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible">  * 最後に、いろんなバグがあるし、ちゃんと扱えてないものがある。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="542"><a name="542"><TD id="E542" onclick="javascript:toggleLayer('J542')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> although it has compiled itself correctly.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J542" onclick="javascript:toggleLayer('E542')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 自分自身はコンパイルはできてるんだけどね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="543"><a name="543"><TD id="E543" onclick="javascript:toggleLayer('J543')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> I expect this will just take a few months, and then I will release the compiler.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J543" onclick="javascript:toggleLayer('E543')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これだけやるのに、まあ数ヶ月もあればってとこで、そしたらコンパイラをリリースする。
 </TD></a></TR><!-- TRANS_PAIR END -->
<TR id="544"><a name="544"><TD ID="TAB544" onclick="javascript:toggleLayer('J544')" BGCOLOR=#F0F0F0 style="visibility : visible"> <BR> </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD ID="TAB544" onclick="javascript:toggleLayer('E544')" BGCOLOR=#F0F0F0 style="visibility : visible"> <BR> </TD></a></TR>
<!-- TRANS_PAIR BEGIN --><TR id="545"><a name="545"><TD ID="TAB545" onclick="javascript:toggleLayer('J545')" BGCOLOR=#F0F0F0 style="visibility : visible">  </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J545" onclick="javascript:toggleLayer('E545')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 3.5 TRIX カーネル
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="546"><a name="546"><TD id="E546" onclick="javascript:toggleLayer('J546')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> The other sizable part of the system that exist, is the kernel. 
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J546" onclick="javascript:toggleLayer('E546')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> システムの中ですでに存在する大きな部分がカーネル。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="547"><a name="547"><TD id="E547" onclick="javascript:toggleLayer('J547')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> (Question: A pause?)
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J547" onclick="javascript:toggleLayer('E547')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> (質問：休みは？) 
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="548"><a name="548"><TD id="E548" onclick="javascript:toggleLayer('J548')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Ah, yeah I guess we've forgotten about breaks.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J548" onclick="javascript:toggleLayer('E548')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ああ、うん、そういや休憩を忘れてたね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="549"><a name="549"><TD id="E549" onclick="javascript:toggleLayer('J549')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Why don't I finish talking about the kernel,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J549" onclick="javascript:toggleLayer('E549')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> とりあえずカーネルの話だけ終わらせてよ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="550"><a name="550"><TD id="E550" onclick="javascript:toggleLayer('J550')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> which should only take about five minutes,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J550" onclick="javascript:toggleLayer('E550')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 5分ほどですむから。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="551"><a name="551"><TD id="E551" onclick="javascript:toggleLayer('J551')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> and then we can take a break.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J551" onclick="javascript:toggleLayer('E551')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そしたら休憩にしよう。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="552"><a name="552"><TD id="E552" onclick="javascript:toggleLayer('J552')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Now, for the kernel I am planning to use a system called TRIX (it doesn't stand for anything that I know of)
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J552" onclick="javascript:toggleLayer('E552')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> で、カーネルには TRIX （ぼくの知る限りでは、何の略でもないみたい）っていうシステムを使う予定（訳注：不詳。きいたことない。でも、すでにマルチサーバ式の OS らしきものは構想されているのがわかる。なおここでは、この 1986 年の時点でカーネルがまもなくできそうな雰囲気だが、実際に GNU のカーネルであるHURD がまがりなりにもリリースされたのは、1997 年になってからのことだった。）。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="553"><a name="553"><TD id="E553" onclick="javascript:toggleLayer('J553')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> which was developed as a research project at MIT.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J553" onclick="javascript:toggleLayer('E553')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これは MIT の研究プロジェクトで開発されたもので、
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="554"><a name="554"><TD id="E554" onclick="javascript:toggleLayer('J554')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This system is based on Remote Procedure Call.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J554" onclick="javascript:toggleLayer('E554')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> リモート・プロシージャ・コールに基づいてる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="555"><a name="555"><TD id="E555" onclick="javascript:toggleLayer('J555')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Thus programs are called domains.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J555" onclick="javascript:toggleLayer('E555')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だからプログラムはドメインと呼ばれてる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="556"><a name="556"><TD id="E556" onclick="javascript:toggleLayer('J556')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Each domain is a address space and various capabilities, and a capability is none other than the ability to call a domain.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J556" onclick="javascript:toggleLayer('E556')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 各ドメインはアドレス空間といろんな機能（capability）で、機能（capability）ってのはまさに、ドメインを呼び出す能力なんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="557"><a name="557"><TD id="E557" onclick="javascript:toggleLayer('J557')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Any domain can create ``capability ports'' to call it, and then it can pass these ports to other domains, and there is no difference between calling the system and calling another user domain.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J557" onclick="javascript:toggleLayer('E557')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> どのドメインもそれを呼び出す「capability ports」（機能ポート）がつくれて、そしてシステムコールとほかのユーザドメインをコールするのとがまったく同じ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="558"><a name="558"><TD id="E558" onclick="javascript:toggleLayer('J558')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In fact you can't tell which you have.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J558" onclick="javascript:toggleLayer('E558')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> どっちをしてるのかすら区別できない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="559"><a name="559"><TD id="E559" onclick="javascript:toggleLayer('J559')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Thus it is very easy to have devices implemented by other user programs.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J559" onclick="javascript:toggleLayer('E559')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だからほかのユーザプログラムでデバイスを簡単に実装できる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="560"><a name="560"><TD id="E560" onclick="javascript:toggleLayer('J560')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> A file system could be implemented by a user program, transparently.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J560" onclick="javascript:toggleLayer('E560')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ファイルシステムも、透過的にユーザプログラムで実装できる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="561"><a name="561"><TD id="E561" onclick="javascript:toggleLayer('J561')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> It's also transparent to communicate across networks.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J561" onclick="javascript:toggleLayer('E561')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> さらにネットワークごしに通信するのも透過的。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="562"><a name="562"><TD id="E562" onclick="javascript:toggleLayer('J562')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You think that you're directly calling another domain, but really you're calling the network server domain.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J562" onclick="javascript:toggleLayer('E562')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ほかのドメインを直接呼んでるつもりでも、実はネットワークサーバのドメインを呼んでるかもしれない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="563"><a name="563"><TD id="E563" onclick="javascript:toggleLayer('J563')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> It takes the information that you gave in the call, and passes this over the network to another server program which then calls the domain that you're trying to talk to.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J563" onclick="javascript:toggleLayer('E563')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> コールで与えた情報をとって、それをネットワーク越しに別のサーバプログラムに渡して、それがこんどはあなたの話そうとしてるドメインを呼び出す。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="564"><a name="564"><TD id="E564" onclick="javascript:toggleLayer('J564')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But you and that other domain see this as happening invisibly.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J564" onclick="javascript:toggleLayer('E564')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でも、あなたとその相手のドメインには、そういう動きはまったく見えずに起こる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="565"><a name="565"><TD id="E565" onclick="javascript:toggleLayer('J565')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> The TRIX kernel runs, and it has a certain limited amount of UNIX compatibility, but it needs a lot more.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J565" onclick="javascript:toggleLayer('E565')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> TRIX カーネルは動くし、ごく限られたかたちで UNIX と互換性もあるんだけれど、でもまだまだだね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="566"><a name="566"><TD id="E566" onclick="javascript:toggleLayer('J566')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Currently it has a file system that uses the same structure on disk as the ancient UNIX file system does.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J566" onclick="javascript:toggleLayer('E566')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> いまのところ、ディスク上では古くさい UNIX ファイルシステムが使ってるのと同じ構造を使ったファイルシステムを持ってる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="567"><a name="567"><TD id="E567" onclick="javascript:toggleLayer('J567')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This made it easier to debug the thing,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J567" onclick="javascript:toggleLayer('E567')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> おかげでデバッグはやさしいよ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="568"><a name="568"><TD id="E568" onclick="javascript:toggleLayer('J568')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> because they could set up the files with UNIX, and then they could run TRIX,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J568" onclick="javascript:toggleLayer('E568')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ファイルを UNIX でセットして、それを TRIX で走らせたりできるから。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="569"><a name="569"><TD id="E569" onclick="javascript:toggleLayer('J569')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> but that file system doesn't have any of the features that I believe are necessary.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J569" onclick="javascript:toggleLayer('E569')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でもこのファイルシステムは、ぼくが必要だと思う機能をぜんぜん持ってない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="570"><a name="570"><TD id="E570" onclick="javascript:toggleLayer('J570')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Features that I believe must be added include: Version numbers, undeletion, information on when and how and where the file was backed up on tape, atomic superseding of files.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J570" onclick="javascript:toggleLayer('E570')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> どうしても追加するべきだと思う機能としては、バージョン番号、削除ファイルの復活、ファイルがいつどこでテープにバックアップされたかの情報、ファイルの詳細更新（atomic superseding of files）。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="571"><a name="571"><TD id="E571" onclick="javascript:toggleLayer('J571')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> I believe that it is good that in Unix when a file is being written, you can already look at what's going there,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J571" onclick="javascript:toggleLayer('E571')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> UNIX でいいと思うのは、ファイルが書き込まれているときには、いつでもどうなってるか見られるってことね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="572"><a name="572"><TD id="E572" onclick="javascript:toggleLayer('J572')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> so for example, you can use ``tail'' to see how far the thing got, that's very nice.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J572" onclick="javascript:toggleLayer('E572')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえば「tail」を使ってどこまで進んだか見るとか、あれっていいよね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="573"><a name="573"><TD id="E573" onclick="javascript:toggleLayer('J573')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And if the program dies, having partly written the file, you can see what it produced.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J573" onclick="javascript:toggleLayer('E573')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それでプログラムが、ファイル書きかけで死んだりしたら、どこまで行ったかも見られる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="574"><a name="574"><TD id="E574" onclick="javascript:toggleLayer('J574')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> These things are all good, but, that partly written output should not ever be taken for the complete output that you expected to have eventually.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J574" onclick="javascript:toggleLayer('E574')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> こういうのっていいんだけど、でもこの書きかけの出力が、いずれ期待してた完全な出力にまちがえられるようなことは、絶対にあってはならない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="575"><a name="575"><TD id="E575" onclick="javascript:toggleLayer('J575')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> The previous version of that should continue to be visible and used by everyone who tries to use it, until the new version is completely and correctly made.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J575" onclick="javascript:toggleLayer('E575')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> その前のバージョンもちゃんと見られて、新しいバージョンが完全に正しくできるまでは、それを使おうとする人みんなに使われるべきでしょ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="576"><a name="576"><TD id="E576" onclick="javascript:toggleLayer('J576')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This means that the new version should be visible in the file system but not under the name it is supposed to have.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J576" onclick="javascript:toggleLayer('E576')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ということはつまり、新しいバージョンはファイルシステムの中で見えなきゃダメだけれど、でも名前は予定されてた名前じゃいけないってことだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="577"><a name="577"><TD id="E577" onclick="javascript:toggleLayer('J577')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> It should get renamed when it's finished.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J577" onclick="javascript:toggleLayer('E577')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 作業が完了してはじめてリネームされるようにしないと。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="578"><a name="578"><TD id="E578" onclick="javascript:toggleLayer('J578')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Which is by the way what happens in ITS, although there each user program has to do this explicitly.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J578" onclick="javascript:toggleLayer('E578')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これはまさに ITS がそうで、だけどここでは、各ユーザプログラムがそれを明示的にやる必要があった。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="579"><a name="579"><TD id="E579" onclick="javascript:toggleLayer('J579')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> For UNIX compatibility with the user programs, it has to happen invisibly.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J579" onclick="javascript:toggleLayer('E579')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ユーザプログラムに UNIX と互換性を持たせるには、これを目に見えない形でやる必要がある。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="580"><a name="580"><TD id="E580" onclick="javascript:toggleLayer('J580')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> I have a weird hairy scheme to try to make version numbers fit with the existing UNIX user programs.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J580" onclick="javascript:toggleLayer('E580')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> バージョン番号を、いまの UNIX のユーザプログラムにフィットさせるための、すごい小細工っぽい方式を考えてある。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="581"><a name="581"><TD id="E581" onclick="javascript:toggleLayer('J581')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And this is the idea that you specify a file name leaving the version number implicit, if you just specify the name in the ordinary way.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J581" onclick="javascript:toggleLayer('E581')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それでこれって、ファイル名をそのまま指定してバージョン番号を略すと、ふつうの形で名前を指定するってこと。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="582"><a name="582"><TD id="E582" onclick="javascript:toggleLayer('J582')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But if you wish to specify a name exactly, either because you want to state explicitly what version to use, or because you don't want versions at all, you put a point at the end of it.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J582" onclick="javascript:toggleLayer('E582')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でもファイル名をはっきり指定したければ、たとえばはっきりどのバージョンを使いたいか指定するとか、あるいはぜんぜんバージョンを使いたくなければ、ファイル名の最後にピリオドをつける。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="583"><a name="583"><TD id="E583" onclick="javascript:toggleLayer('J583')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Thus if you give the filename ``FOO'' it means ``Search the versions that exists for FOO and take the latest one''.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J583" onclick="javascript:toggleLayer('E583')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だからもし「HOGE」っていうファイル名を与えたら、これはつまり「HOGE のバージョンを全部見て、最新のヤツをもっといで」という意味。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="584"><a name="584"><TD id="E584" onclick="javascript:toggleLayer('J584')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But if you say ``FOO.'' it means ``use exactly the name FOO and none other''.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J584" onclick="javascript:toggleLayer('E584')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でも「HOGE.」といえば、「純粋に HOGE という名前だけのファイルを持っといで、それ以外はいらないよ」ってこと。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="585"><a name="585"><TD id="E585" onclick="javascript:toggleLayer('J585')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> If you say ``FOO.3.'' it says ``use exactly the name FOO.3 '' which of course is version three of FOO and none other.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J585" onclick="javascript:toggleLayer('E585')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 「HOGE.3.」ってのは「ずばり HOGE.3 って名前のファイル」で、これはもちろん HOGE のバージョン3そのもの。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="586"><a name="586"><TD id="E586" onclick="javascript:toggleLayer('J586')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> On output, if you just say ``FOO'', it will eventually create a new version of ``FOO'', but if you say ``FOO.'' it will write a file named exactly ``FOO''.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J586" onclick="javascript:toggleLayer('E586')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 出力では、単に「HOGE」といったら、これはいずれ「HOGE」の新しいバージョンをつくるけれど、でも「HOGE.」と指定すれば、純粋に「HOGE」という名前のファイルに書き込む。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="587"><a name="587"><TD id="E587" onclick="javascript:toggleLayer('J587')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Now there's some challenges involved in working out all the details in this, and seeing whether there are any lingering problems, whether some UNIX software actually breaks despite feeding them names with points in them and so on, to try to make it get the same behavior.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J587" onclick="javascript:toggleLayer('E587')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> さて、細かいところを全部つめて、問題が残ってないかとか、UNIX がファイル名にピリオドをつけたらいかれるかかなんとか、同じ行動をさせるようにするには、いろいろまだハードルが残ってはいる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="588"><a name="588"><TD id="E588" onclick="javascript:toggleLayer('J588')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> I would expect that when you open a file for output whose name ends in a point, you should actually open that name right away,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J588" onclick="javascript:toggleLayer('E588')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 出力用に、名前がピリオドで終わるファイルを開いたら、その名前をすぐに開いて、だから同じ UNIX の振る舞いが得られるようにしたい。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="589"><a name="589"><TD id="E589" onclick="javascript:toggleLayer('J589')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> so you get the so you get the same UNIX behavior, the partially written output is immediately visible, whereas when you output a name that doesn't end in a point, the new version should appear when you close it, and only if you close it explicitly.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J589" onclick="javascript:toggleLayer('E589')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 書きかけの出力がそのまま見えるようになって、でもピリオドで終わらない名前に出力したら、閉じたときには新しいバージョンがあらわれて、しかもそれを明示的に閉じないと新しいバージョンにならない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="590"><a name="590"><TD id="E590" onclick="javascript:toggleLayer('J590')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> If it gets closed because the job dies, or because the system crashes or anything like that, it should be under a different name.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J590" onclick="javascript:toggleLayer('E590')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> システムがクラッシュしたとかなんとかで、ジョブが死んだためにファイルが閉じたら、それは名前が変わる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="591"><a name="591"><TD id="E591" onclick="javascript:toggleLayer('J591')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And this idea can be connected up to ``star matching'',
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J591" onclick="javascript:toggleLayer('E591')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そしてこのアイデアは、「スター・マッチング」に結びつけられる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="592"><a name="592"><TD id="E592" onclick="javascript:toggleLayer('J592')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> by saying that a name that doesn't end in a point is matched against all the names without their version numbers,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J592" onclick="javascript:toggleLayer('E592')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> つまり、ピリオドで終わらない名前はバージョン番号のついてない名前とマッチするようになるってわけ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="593"><a name="593"><TD id="E593" onclick="javascript:toggleLayer('J593')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> so if a certain directory has files like this:
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J593" onclick="javascript:toggleLayer('E593')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だからあるディレクトリにこんなファイルがあったとしよう：
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="594"><a name="594"><TD id="E594" onclick="javascript:toggleLayer('J594')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> foo.1 foo.2 bar.8
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J594" onclick="javascript:toggleLayer('E594')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ho.1  ho.2  ge.8
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="595"><a name="595"><TD id="E595" onclick="javascript:toggleLayer('J595')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> If I say ``*'', that's equivalent to foo bar
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J595" onclick="javascript:toggleLayer('E595')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ここで「*」と言ったら、それは：ho　　ge に相当する。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="596"><a name="596"><TD id="E596" onclick="javascript:toggleLayer('J596')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> because it takes all the names and gets rid of their versions, and takes all the distinct ones.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J596" onclick="javascript:toggleLayer('E596')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 名前をとって、バージョン番号をそこから除いて、それで区別がつくものを選ぶから。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="597"><a name="597"><TD id="E597" onclick="javascript:toggleLayer('J597')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But if I say ``*.'' then it takes all the exact names, puts a point after each one, and matches against them.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J597" onclick="javascript:toggleLayer('E597')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でも「*.」といえば、絶対名を全部とってきて、それにピリオドをつけて、それに対してマッチしたのをさがす。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="598"><a name="598"><TD id="E598" onclick="javascript:toggleLayer('J598')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So this gives me all the names for all the individual versions that exist.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J598" onclick="javascript:toggleLayer('E598')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから存在する個別バージョンがすべてあてはまる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="599"><a name="599"><TD id="E599" onclick="javascript:toggleLayer('J599')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And similar, you can see the difference between ``*.c'' and ``*.c.''
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J599" onclick="javascript:toggleLayer('E599')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 同じようにして「*.c」と「*.c.」のちがいもわかるよね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="600"><a name="600"><TD id="E600" onclick="javascript:toggleLayer('J600')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> this [the first] would give you essentially versionless references to all the ``.c'' files, whereas this [the second] will give you all the versions ..... well this actually wouldn't, you'd have to say ``*.c.*.''.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J600" onclick="javascript:toggleLayer('E600')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> こいつ（最初の）は基本的にバージョンなしの「.c」ファイルすべてをさすんだけど、こいつ（二番目）は全バージョンをさす……わけじゃないな、それだと「*.c.*.」とやんなきゃいけないのか。
 </TD></a></TR><!-- TRANS_PAIR END -->
</TABLE></span><HR>
<a href="rms-4.htm">prev</a>
<a href="rms-0.htm">0</a>
<a href="rms-1.htm">1</a>
<a href="rms-2.htm">2</a>
<a href="rms-3.htm">3</a>
<a href="rms-4.htm">4</a>
<5>
<a href="rms-6.htm">6</a>
<a href="rms-7.htm">7</a>
<a href="rms-8.htm">8</a>
<a href="rms-9.htm">9</a>
<a href="rms-6.htm">next</a>
<hr>

<h2><a name="preamble">このページにある対訳文について</a></h2>このページの対訳文は，再配布可能な作品（<a href="http://www.gutenberg.org/">Project Gutenberg</a> や<a href="http://www.aozora.gr.jp/">青空文庫</a>や<a href="http://www.genpaku.org/">プロジェクト杉田玄白</a>などの作品）について，日本語文と英語文とを対応付けたものの一つです．その他の対訳作品やダウンロードや著作権などについては，<a href="../index.html">日英対訳文対応付けデータのホームページ</a>を見て下さい．また，オリジナルの日英作品の著作権についてはオリジナルの日本語文および英語文の著作権を見て下さい．なお，著作権上の問題がある作品については，情報通信研究機構自然言語グループ内山将夫（ｍｕｔｉｙａｍａ あっとまーく ｎｉｃｔ どっと ｇｏ どっと ｊｐ）まで連絡していただければ，それらについては削除します．<h3>関連ページ</h3><ul><li>オリジナルの英語文: <a href="../org/rmse.txt">local copy</a><li>オリジナルの日本語文: <a href="../org/rmsj.txt">local copy</a><li><a href="../manual-alignment/rms.alm">対訳データ</a></ul><p>
<script type="text/javascript">
<!--
document.F.CE.checked = false
document.F.CJ.checked = false
// -->
</script>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</BODY></HTML>

