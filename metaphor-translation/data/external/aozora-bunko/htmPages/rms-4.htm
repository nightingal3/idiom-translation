<HTML><HEAD><META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<script type="text/javascript">
<!--

IE = (navigator.appName == "Microsoft Internet Explorer")

function lookup(e) {
  if(IE){
    range = document.selection.createRange()
    str = range.text
  }else{
    str = document.getSelection()
  }
  code = str.charCodeAt(0)
  if(code >= 0 && code <= 127){
    str = str.replace(/^[^a-zA-Z0-9]+/,"")
    str = str.replace(/[^a-zA-Z0-9]+$/,"")
    if(str != ""){
      win = open("http://dictionary.goo.ne.jp/search.php?MT="+escape(str)+"&kind=&mode=0", "Goo", "width=600,height=400,scrollbars=yes")
      win.focus()
    }
  } 
}
function showLayer(id){ 
    if(document.getElementById){
        document.getElementById(id).style.visibility = 'visible'
    }else if(document.all){
        document.all(id).style.visibility = 'visible'
    }else if(document.layers){
        document.layers[id].visibility = 'show'
    }
}

reJ = new RegExp('J');
reE = new RegExp('E');
function hideLayer(id){
    if(id.match(reJ) && !document.F.CJ.checked) return
    if(id.match(reE) && !document.F.CE.checked) return
    if(document.getElementById){
        document.getElementById(id).style.visibility = 'hidden'
    }else if(document.all){
        document.all(id).style.visibility = 'hidden'
    }else if(document.layers){
        document.layers[id].visibility = 'hidden'
    }
}
function layerIsVisible(id){
    if(document.getElementById){
        return (document.getElementById(id).style.visibility == 'visible')
    }else if(document.all){
        return (document.all(id).style.visibility == 'visible')
    }else if(document.layers){
        return (document.layers[id].visibility == 'show')
    }
}
function toggleLayer(id){
    if(layerIsVisible(id)){
        hideLayer(id)
    }else{
        showLayer(id)
    }
}

function showOrHideE(eng, jp){
    if(document.F.CE.checked){
        hideLayer(eng)
    }else{
        showLayer(jp)
    }
}

function showOrHideJ(jp, eng){
    if(document.F.CJ.checked){
        hideLayer(jp)
    }else{
        showLayer(eng)
    }
}
				

function hasAttribute2(obj, attr){
    if(IE){
        return true
    }else if(document.getElementById){
        return obj.hasAttribute(attr)
    }else{
        return true
    }
}

reTAB = new RegExp("TAB")
function hideJE(str) {
    re = new RegExp(str);
    spans = document.getElementsByTagName("TD")
    for(i=0; i<spans.length; i++){
        if(hasAttribute2(spans[i], "id")){
            id = spans[i].getAttribute("id")
            if(id.match(re)){
	        hideLayer(id)
            }else if(id.match(reTAB) &&
            (document.F.CJ.checked || document.F.CE.checked)){
                spans[i].setAttribute('BGCOLOR', "#FFFFFF")
            }
	}
    }
}
function showJE(str) {
    re = new RegExp(str);
    spans = document.getElementsByTagName("TD")
    for(i=0; i<spans.length; i++){
        if(hasAttribute2(spans[i], "id")){
            id = spans[i].getAttribute("id")
            if(id.match(re)){
	        showLayer(id)
            }else if(id.match(reTAB) &&
            (!document.F.CJ.checked && !document.F.CE.checked)){
                spans[i].setAttribute('BGCOLOR', "#F0F0F0")
	    }
	}
    }
}
function addRules (){
    obj = document.getElementById('TRANSPAIR');
    obj.rules = 'ALL'
    obj.frame = 'BORDER'
}

function removeRules (){
    obj = document.getElementById('TRANSPAIR');
    obj.rules = 'NONE'
    obj.frame = 'VOID'
}

function onoffJ(){
    if (document.F.CJ.checked) {
        hideJE('J');
        addRules();
    }else{
        showJE('J');
        if(!document.F.CE.checked){
            removeRules();
        }
    }
}
function onoffE(){
    if (document.F.CE.checked) {
        hideJE('E');
        addRules();
    }else{
        showJE('E');
        if(!document.F.CJ.checked){
            removeRules();
        }
    }
}
				
// -->
</script>
</HEAD><BODY BGCOLOR=#FFFFFF><div align=right><a href="../data/titles-ja-pages.htm">タイトル順</a>/<a href="../data/authors-pages.htm">著者順</a>/<a href="../data/translators-pages.htm">訳者順</a>/<a href="../index.html">ホーム</a></div><h2>RMS lecture at KTH / Richard M. Stallman 著</h2><h2>RMS スウェーデン王立工科大学講演  / リチャード・M・ストールマン 著 / 山形浩生 訳</h2><p>Annotator: 高橋真弓</p><div align=right><form name="F"><input type="checkbox" name="CE" onclick="onoffE()">英語文を消す <input type="checkbox" name="CJ" onclick="onoffJ()">日本語文を消す <br>(反対側の文を押すと消えた文が出る)</form></div>オリジナル:<a href="../org/rmse.txt">英語文</a>&<a href="../org/rmsj.txt">日本語文</a> / <a href="../manual-alignment/rms.alm">対訳データ</a> / <a href="#preamble">このページにある対訳文について</a>
<TITLE>4 of RMS lecture at KTH</TITLE>
<hr>
<a href="rms-3.htm">prev</a>
<a href="rms-0.htm">0</a>
<a href="rms-1.htm">1</a>
<a href="rms-2.htm">2</a>
<a href="rms-3.htm">3</a>
<4>
<a href="rms-5.htm">5</a>
<a href="rms-6.htm">6</a>
<a href="rms-7.htm">7</a>
<a href="rms-8.htm">8</a>
<a href="rms-9.htm">9</a>
<a href="rms-5.htm">next</a>
<a name="tableBegin"></a><HR><span><TABLE BGCOLOR=#F0F0F0 ID=TRANSPAIR FRAME=VOID RULES=NONE BORDERCOLOR=#000000>
<!-- TRANS_PAIR BEGIN --><TR id="401"><a name="401"><TD id="E401" onclick="javascript:toggleLayer('J401')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> you say ``stop when you get to this point in the program, but only if a certain expression is true''.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J401" onclick="javascript:toggleLayer('E401')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 「プログラムのここまできたら止まれ、ただしこの条件式が真の場合だけね」と言うわけ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="402"><a name="402"><TD id="E402" onclick="javascript:toggleLayer('J402')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> The variables in the debugger allow you to compare a variable in the program with a previous value of that variable that you saved in a debugger variable.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J402" onclick="javascript:toggleLayer('E402')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> デバッガの変数は、プログラム内の変数と、デバッガ変数内に保存した変数値とをくらべさせてくれる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="403"><a name="403"><TD id="E403" onclick="javascript:toggleLayer('J403')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Another thing that they can be used for is for counting,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J403" onclick="javascript:toggleLayer('E403')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これはほかにも、数えるのに使える。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="404"><a name="404"><TD id="E404" onclick="javascript:toggleLayer('J404')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> because after all, assignments are expressions in C, therefore you can do ``$foo+=5'' to increment the value of ``$foo'' by five, or just ``$foo++'' you can do.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J404" onclick="javascript:toggleLayer('E404')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だって値の割付は要するにCの式でしょ、だから$hoge を 5 増やすには $hoge+=5 でもいいし、あるいは単に $hoge++ でやってもいい。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="405"><a name="405"><TD id="E405" onclick="javascript:toggleLayer('J405')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You can even do this in a conditional breakpoint, so that's a cheap way of having it break the tenth time the breakpoint is hit, you can do ``$foo--==0''.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J405" onclick="javascript:toggleLayer('E405')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これを条件付きブレークでもできるから、このブレークポイントに 10 回目にきたらブレークとかするのにはお手軽でしょ、 $hoge--==0 をするんだよね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="406"><a name="406"><TD id="E406" onclick="javascript:toggleLayer('J406')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Does everyone follow that?
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J406" onclick="javascript:toggleLayer('E406')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> みんな、ついてきてる？
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="407"><a name="407"><TD id="E407" onclick="javascript:toggleLayer('J407')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Decrement foo and if it's zero now, break.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J407" onclick="javascript:toggleLayer('E407')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> hoge を減らしてって、それがゼロになってたらブレークしろってこと。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="408"><a name="408"><TD id="E408" onclick="javascript:toggleLayer('J408')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And then you set $foo to the number of times you want it to skip, and you let it go.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J408" onclick="javascript:toggleLayer('E408')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そしてそれから $hoge を、スキップしたい回数にセットして、それで行ける。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="409"><a name="409"><TD id="E409" onclick="javascript:toggleLayer('J409')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You can also use that to examine elements of an array.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J409" onclick="javascript:toggleLayer('E409')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これを配列の中の要素を見るのにも使える。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="410"><a name="410"><TD id="E410" onclick="javascript:toggleLayer('J410')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Suppose you have an array of pointers, you can then do:
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J410" onclick="javascript:toggleLayer('E410')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえばポインタの配列があって、そしたらこんなことする：
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="411"><a name="411"><TD id="E411" onclick="javascript:toggleLayer('J411')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> PRINT X[$foo++]
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J411" onclick="javascript:toggleLayer('E411')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> PRINT X[$hoge++]
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="412"><a name="412"><TD id="E412" onclick="javascript:toggleLayer('J412')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But first you do
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J412" onclick="javascript:toggleLayer('E412')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でもその前にまずこれ：
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="413"><a name="413"><TD id="E413" onclick="javascript:toggleLayer('J413')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> SET $foo=0
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J413" onclick="javascript:toggleLayer('E413')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> SET $hoge=0
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="414"><a name="414"><TD id="E414" onclick="javascript:toggleLayer('J414')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Okay, when you do that [points at the ``Print'' expression], you get the zeroth element of X,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J414" onclick="javascript:toggleLayer('E414')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> オッケー、で、こうしたら（と「Print」式をさす）、X のゼロ番目の要素が出てくる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="415"><a name="415"><TD id="E415" onclick="javascript:toggleLayer('J415')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> and then you do it again and it gets the first element, and suppose these are pointers to structures, then you probably put an asterisk there [before the X in the PRINT expression] and each time it prints the next structure pointed to by the element of the array.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J415" onclick="javascript:toggleLayer('E415')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> で、もう一回やったらそれは一番目の要素で、それでこれがもし構造体へのポインタなら、たぶんここ（PRINT 式の X の前）にアステリスク（*）を入れて、そしたら毎回これはこの配列の要素がさしてる次の構造体をだしてくる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="416"><a name="416"><TD id="E416" onclick="javascript:toggleLayer('J416')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And of course you can repeat this command by typing carriage-return.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J416" onclick="javascript:toggleLayer('E416')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そしてもちろん、改行をおすだけでこれを繰り返せる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="417"><a name="417"><TD id="E417" onclick="javascript:toggleLayer('J417')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> If a single thing to repeat is not enough, you can create a user-defined-command.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J417" onclick="javascript:toggleLayer('E417')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これ一つだけ繰り返すんじゃ不十分なら、ユーザ定義コマンドをつくればいい。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="418"><a name="418"><TD id="E418" onclick="javascript:toggleLayer('J418')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You can say ``Define Mumble'', and then you give some lines of commands and then you say ``end''.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J418" onclick="javascript:toggleLayer('E418')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 「Define むにゃむにゃ」とやって、それからコマンドを何行か入れて、「end」とやる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="419"><a name="419"><TD id="E419" onclick="javascript:toggleLayer('J419')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And now there is defined a ``Mumble'' command which will execute those lines.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J419" onclick="javascript:toggleLayer('E419')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これでもう「むにゃむにゃ」コマンドが定義されて、それが入れた行を実行する。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="420"><a name="420"><TD id="E420" onclick="javascript:toggleLayer('J420')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And it's very useful to put these definitions in a command file.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J420" onclick="javascript:toggleLayer('E420')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> で、こういう定義をコマンドファイルに入れておくとすごく便利なの。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="421"><a name="421"><TD id="E421" onclick="javascript:toggleLayer('J421')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You can have a command file in each directory, that will be loaded automatically when you start the debugger with that as your working directory.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J421" onclick="javascript:toggleLayer('E421')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ディレクトリごとにコマンドファイルを持って、そこを作業ディレクトリにしてデバッガを起動すると、それが勝手にロードされるようにしておける。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="422"><a name="422"><TD id="E422" onclick="javascript:toggleLayer('J422')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So for each program you can define a set of user defined commands to access the data structures of that program in a useful way.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J422" onclick="javascript:toggleLayer('E422')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから各プログラムごとに、ユーザ定義コマンドをいろいろ定義しておいて、便利な形でそのプログラムのデータ構造にアクセスできるようにしとける。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="423"><a name="423"><TD id="E423" onclick="javascript:toggleLayer('J423')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You can even provide documentation for your user-defined commands,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J423" onclick="javascript:toggleLayer('E423')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そういうユーザ定義コマンド用にドキュメンテーションだってつくれるんだよ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="424"><a name="424"><TD id="E424" onclick="javascript:toggleLayer('J424')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> so that they get handled by the ``help'' features just like the built-in commands.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J424" onclick="javascript:toggleLayer('E424')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そうするともとからのコマンドとまったく同じように、「help」機能で処理されるんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="425"><a name="425"><TD id="E425" onclick="javascript:toggleLayer('J425')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> One other unusual thing in this debugger, is the ability to discard frames from the stack.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J425" onclick="javascript:toggleLayer('E425')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> このデバッガでもう一つ珍しいのが、スタックからフレームを捨てられるってこと。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="426"><a name="426"><TD id="E426" onclick="javascript:toggleLayer('J426')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Because I believe it's important not just to be able to examine what's happening in the program you're debugging, but also to change it in any way conceivable.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J426" onclick="javascript:toggleLayer('E426')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> デバッグしてるプログラムで何が起きてるか見られるだけじゃなくて、それを好き放題変えられるってのが大事だと思うんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="427"><a name="427"><TD id="E427" onclick="javascript:toggleLayer('J427')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So that after you've found one problem and you know what's wrong, you can fix things up as if that code were correct and find the next bug without having to recompile your program first.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J427" onclick="javascript:toggleLayer('E427')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから問題を一つ見つけて何がダメかわかったら、そのコードが正しかったかのようにあちこちなおしてから、コンパイルしなおさなくても次のバグを見つけにいけるわけだよ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="428"><a name="428"><TD id="E428" onclick="javascript:toggleLayer('J428')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This means not only being able to change the data areas in you program flexibly, but also being able to change the flow of control.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J428" onclick="javascript:toggleLayer('E428')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ということは、プログラムのデータ領域を思い通りに直せるだけじゃなくて、コントロールのフローを好きに変えられなきゃならない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="429"><a name="429"><TD id="E429" onclick="javascript:toggleLayer('J429')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In this debugger you can change the flow of control very directly by saying:
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J429" onclick="javascript:toggleLayer('E429')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> このデバッガでは、こんなふうにしてコントロールのフローをすごく直接的に変えられる：
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="430"><a name="430"><TD id="E430" onclick="javascript:toggleLayer('J430')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> SET $PC=&lt;some number&gt;
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J430" onclick="javascript:toggleLayer('E430')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> SET $PC=&lt;なんか数字&gt;
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="431"><a name="431"><TD id="E431" onclick="javascript:toggleLayer('J431')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So you can set the program counter.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J431" onclick="javascript:toggleLayer('E431')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> こうやってプログラムカウンタを変えるの。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="432"><a name="432"><TD id="E432" onclick="javascript:toggleLayer('J432')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You can also set the stack pointer, or you can say
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J432" onclick="javascript:toggleLayer('E432')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それとスタックポインタもセットできるし、あるいはこういうふうにでも：
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="433"><a name="433"><TD id="E433" onclick="javascript:toggleLayer('J433')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> SET $SP+=&lt;something&gt;
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J433" onclick="javascript:toggleLayer('E433')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> SET $SP+=&lt;なんとか&gt;
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="434"><a name="434"><TD id="E434" onclick="javascript:toggleLayer('J434')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> If you want to increment the stack pointer a certain amount.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J434" onclick="javascript:toggleLayer('E434')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> スタックポインタをちょっと増やしたいなと思うでしょ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="435"><a name="435"><TD id="E435" onclick="javascript:toggleLayer('J435')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But in addition you can also tell it to start at a particular line in the program, you can set the program counter to a particular source line.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J435" onclick="javascript:toggleLayer('E435')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でもついでに、プログラムのどこか途中からはじめたいとして、だからプログラムカウンタをそのソース行にあわせるよね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="436"><a name="436"><TD id="E436" onclick="javascript:toggleLayer('J436')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But what if you find that you called a function by mistake and you didn't really want to call that function at all?
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J436" onclick="javascript:toggleLayer('E436')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でもそれで、その関数を呼んだのがまちがいで、その関数呼びたくなかった！としたら？
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="437"><a name="437"><TD id="E437" onclick="javascript:toggleLayer('J437')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Say, that function is so screwed up that what you really want to do is get back out of it and do by hand what that function should have done.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J437" onclick="javascript:toggleLayer('E437')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえばその関数がどうしようもなくいかれてて、実はそこから戻ってきて、その関数のやるべきだったことを手でやりたいとしたら？
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="438"><a name="438"><TD id="E438" onclick="javascript:toggleLayer('J438')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> For that you can use the ``RETURN'' command.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J438" onclick="javascript:toggleLayer('E438')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それには 「RETURN」 命令を使う。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="439"><a name="439"><TD id="E439" onclick="javascript:toggleLayer('J439')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> You select a stack frame and you say ``RETURN'', and it causes that stack-frame, and all the ones within it, to be discarded as if that function were returning right now, and you can also specify the value it should return.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J439" onclick="javascript:toggleLayer('E439')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> スタックフレームを選んで 「RETURN」とやると、そのスタックフレームや、その中にあるやつ全部が捨てられて、その関数からすぐに戻ってきたような感じになって、しかもそこから返ってくるはずの値も指定できる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="440"><a name="440"><TD id="E440" onclick="javascript:toggleLayer('J440')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This does not continue execution;
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J440" onclick="javascript:toggleLayer('E440')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 実行は続かないよ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="441"><a name="441"><TD id="E441" onclick="javascript:toggleLayer('J441')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> it pretends that return happened and then stops the program again, so you can continue changing other things.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J441" onclick="javascript:toggleLayer('E441')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 返ってきたようなふりをして、そこでまたプログラムを止めるから、ほかのものもどんどん変えられる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="442"><a name="442"><TD id="E442" onclick="javascript:toggleLayer('J442')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And with all these things put together you thus have pretty good control over what's going on in a program.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J442" onclick="javascript:toggleLayer('E442')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> このくらいいろいろまとまってると、プログラムの中で何が起きてるか、かなり細かくコントロールがきくわけよ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="443"><a name="443"><TD id="E443" onclick="javascript:toggleLayer('J443')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In addition one slightly amusing thing:
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J443" onclick="javascript:toggleLayer('E443')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これに加えて、もう一つちょっとおもしろいこと。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="444"><a name="444"><TD id="E444" onclick="javascript:toggleLayer('J444')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> C has string constants, what happens if you use a string constant in an expression that you're computing in the debugger?
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J444" onclick="javascript:toggleLayer('E444')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> C にはストリング定数があって、デバッガ内で計算してる数式にストリング定数を使ったらどうなるか？
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="445"><a name="445"><TD id="E445" onclick="javascript:toggleLayer('J445')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> It has to create a string in the program you were debugging.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J445" onclick="javascript:toggleLayer('E445')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> デバッグしてるプログラム内にストリングをつくらなきゃなんない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="446"><a name="446"><TD id="E446" onclick="javascript:toggleLayer('J446')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Well it does.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J446" onclick="javascript:toggleLayer('E446')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だからつくってくれる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="447"><a name="447"><TD id="E447" onclick="javascript:toggleLayer('J447')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> It sets up a call to MALLOC in that debugged program, lets MALLOC run, and then gets control back.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J447" onclick="javascript:toggleLayer('E447')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> デバッグ中のプログラム内で MALLOC へのコールをやってくれて、MALLOC を走らせて、それからコントロールを取り戻す。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="448"><a name="448"><TD id="E448" onclick="javascript:toggleLayer('J448')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Thus it invisibly finds a place to put the string constant.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J448" onclick="javascript:toggleLayer('E448')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> こうやって、知らないうちにストリング定数を置く場所を見つけてくれるの。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="449"><a name="449"><TD id="E449" onclick="javascript:toggleLayer('J449')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Eventually when this debugger is running on the real GNU system, I intend to put in facilities in the debugger to examine all of the internal status of the process that is running underneath it.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J449" onclick="javascript:toggleLayer('E449')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> いずれこのデバッガが本物の GNU システム上で動くようになるときには、その下で動いてる全プロセスの内部状態を調べられるような機能をつけるつもり。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="450"><a name="450"><TD id="E450" onclick="javascript:toggleLayer('J450')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> For example to examine the status of the memory map, which pages exist, which are readable, which are writable, and to examine the inferior program's terminal status.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J450" onclick="javascript:toggleLayer('E450')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえばメモリマップの状態を見ようとかね、どのページが存在して、どれが読めて、どれが書き込めるか見て、あと下部プログラムの終了状態（terminal status）を見るとか。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="451"><a name="451"><TD id="E451" onclick="javascript:toggleLayer('J451')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> There already is a bit of a command;
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J451" onclick="javascript:toggleLayer('E451')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> もうかなりコマンドはあるんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="452"><a name="452"><TD id="E452" onclick="javascript:toggleLayer('J452')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> this debugger, unlike the debuggers on UNIX, keeps the terminal status completely separate for the debugger and the program you're debugging,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J452" onclick="javascript:toggleLayer('E452')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> このデバッガは、UNIX のデバッガとはちがって、終了状態をデバッガやデバッグ中のプログラムと完全に切り離してる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="453"><a name="453"><TD id="E453" onclick="javascript:toggleLayer('J453')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> so that it works with programs that run in raw mode, it works with programs that do interrupt driven input, and there's also a command that enables you to find out something about the terminal settings at the program you're debugging is actually using.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J453" onclick="javascript:toggleLayer('E453')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だからそのままのモード（raw mode）で動くプログラムも見られるし、割り込み駆動入力をするプログラムでも動くし、それにデバッグ中のプログラムが実際に使ってるものの終了状態についても調べてくれるコマンドがある。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="454"><a name="454"><TD id="E454" onclick="javascript:toggleLayer('J454')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> I believe that in general a debugger should allow you to find out everything that's going on in the inferior process.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J454" onclick="javascript:toggleLayer('E454')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 一般にデバッガというのは、下部プロセスで起こってることはすべてわかるようにすべきだと思うな。
 </TD></a></TR><!-- TRANS_PAIR END -->
<TR id="455"><a name="455"><TD ID="TAB455" onclick="javascript:toggleLayer('J455')" BGCOLOR=#F0F0F0 style="visibility : visible"> <BR> </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD ID="TAB455" onclick="javascript:toggleLayer('E455')" BGCOLOR=#F0F0F0 style="visibility : visible"> <BR> </TD></a></TR>
<!-- TRANS_PAIR BEGIN --><TR id="456"><a name="456"><TD ID="TAB456" onclick="javascript:toggleLayer('J456')" BGCOLOR=#F0F0F0 style="visibility : visible">  </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J456" onclick="javascript:toggleLayer('E456')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 3.4 gcc コンパイラ
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="457"><a name="457"><TD id="E457" onclick="javascript:toggleLayer('J457')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> There are two other main parts of the GNU system that already exist.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J457" onclick="javascript:toggleLayer('E457')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> GNU システムのうちすでに存在する主要部分は二つある。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="458"><a name="458"><TD id="E458" onclick="javascript:toggleLayer('J458')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> One is the new C compiler, and one is the TRIX kernel.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J458" onclick="javascript:toggleLayer('E458')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 一つは新しい C コンパイラ（訳注：もちろんこの時点ではまだ gcc という名前はなかった。）で、もう一つは TRIX カーネルだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="459"><a name="459"><TD id="E459" onclick="javascript:toggleLayer('J459')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> The new C compiler is something that I've written this year since last spring.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J459" onclick="javascript:toggleLayer('E459')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 新しい C コンパイラは、この春から今年いっぱい書いてたもの。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="460"><a name="460"><TD id="E460" onclick="javascript:toggleLayer('J460')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> I finally decided that I'd have to throw out PASTEL.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J460" onclick="javascript:toggleLayer('E460')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ついに PASTELは捨てようと決めたんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="461"><a name="461"><TD id="E461" onclick="javascript:toggleLayer('J461')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This C compiler uses some ideas taken from PASTEL, and some ideas taken from the University of Arizona Portable Optimizer.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J461" onclick="javascript:toggleLayer('E461')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> この C コンパイラは PASTEL からのアイデアをもらってて、アリゾナ大学ポータブル・オプチマイザからのアイデアももらってる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="462"><a name="462"><TD id="E462" onclick="javascript:toggleLayer('J462')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Their interesting idea was to handle many different kinds of machines by generating simple instructions, and then combining several simple instructions into a complicated instruction when the target machine permits it.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J462" onclick="javascript:toggleLayer('E462')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 連中のおもしろいアイデアは、いろんな種類のマシンを単純な命令の生成で扱うことで、ターゲットのマシンが許せばそれをいくつか組み合わせて複雑な命令にするんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="463"><a name="463"><TD id="E463" onclick="javascript:toggleLayer('J463')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In order to do this uniformly, they represent they represent the instructions in algebraic notation.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J463" onclick="javascript:toggleLayer('E463')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これを総合的にやるために、命令が数学式の記法で書かれてる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="464"><a name="464"><TD id="E464" onclick="javascript:toggleLayer('J464')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> For example, an ADD instruction might be represented like this:
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J464" onclick="javascript:toggleLayer('E464')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえば ADD 命令はこんな感じで書かれる：
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="465"><a name="465"><TD id="E465" onclick="javascript:toggleLayer('J465')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> r[3]=r[2]+4
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J465" onclick="javascript:toggleLayer('E465')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> r[3]=r[2]+4
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="466"><a name="466"><TD id="E466" onclick="javascript:toggleLayer('J466')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This would be a representation inside their compiler
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J466" onclick="javascript:toggleLayer('E466')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> これはコンパイラ内部での命令の表現形。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="467"><a name="467"><TD id="E467" onclick="javascript:toggleLayer('J467')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> for instruction to take the contents of register two, add four and store it in register three.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J467" onclick="javascript:toggleLayer('E467')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 2 番レジスタの中身をとって、それに 4を足して 3 番レジスタに入れろという命令。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="468"><a name="468"><TD id="E468" onclick="javascript:toggleLayer('J468')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In this fashion you can represent any possible instruction for any machine.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J468" onclick="javascript:toggleLayer('E468')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> こういうふうにすれば、あらゆるマシン用にあらゆる命令を表現できる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="469"><a name="469"><TD id="E469" onclick="javascript:toggleLayer('J469')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So they actually did represent all the instructions this way and then when it came time to try to combine them, they would do this by substituting one expression into another, making a more complicated algebraic expression for the combined instruction.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J469" onclick="javascript:toggleLayer('E469')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それでかれらは実際に、すべての命令をこの形式で表現して、それを組み合わせる段階になったら、ある表現式をべつので置き換えて、もっと複雑な式をつくって組み合わせて命令にするわけ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="470"><a name="470"><TD id="E470" onclick="javascript:toggleLayer('J470')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Sometimes depending on whether the result of the first instruction had any further use, it might be necessary to make a combined instruction with two assignment operators.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J470" onclick="javascript:toggleLayer('E470')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ときどき、最初の命令の結果がそれ以上使われるかどうかに応じて、割りつけ演算子を 2 つ持つような組み合わせ命令をつくんなきゃならない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="471"><a name="471"><TD id="E471" onclick="javascript:toggleLayer('J471')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> One for this value [pointing at ???]and another one with this value [pointing at ???] substituted in it with what came from the second instruction.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J471" onclick="javascript:toggleLayer('E471')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> この値（と何かを指さす）用に 1 つと、こっちの値（と何かを指さす）用に 1 つ、こっちは 2 番目の命令からきた値と差し替えるのね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="472"><a name="472"><TD id="E472" onclick="javascript:toggleLayer('J472')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But if this value was only used that once, you could eliminate it after substituting for it;
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J472" onclick="javascript:toggleLayer('E472')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でもこの値を 1 回しか使わないなら、差し替えたあとは捨てちゃえる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="473"><a name="473"><TD id="E473" onclick="javascript:toggleLayer('J473')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> there'd be no need to compute it any more.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J473" onclick="javascript:toggleLayer('E473')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> もうそれで計算する必要はないんだから。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="474"><a name="474"><TD id="E474" onclick="javascript:toggleLayer('J474')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So it's actually somewhat complicated doing the substitution correctly checking that the intervening instructions don't change any of these values and other such things.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J474" onclick="javascript:toggleLayer('E474')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから。途中で入ってくる命令とかがこういう値を変えたりしないかとか、そういうのをちゃんとチェックして、差し替えをきちんとやるのはなかなかややこしい。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="475"><a name="475"><TD id="E475" onclick="javascript:toggleLayer('J475')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> When you support such things as auto-increment and auto-decrement addressing, which I do now, you also have to do various checks for those to check for situations where what you're doing is not value preserving.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J475" onclick="javascript:toggleLayer('E475')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 自動インクリメントや自動デクリメント・アドレッシングみたいなものをサポートするなら（ぼくはしてるけど）、値を保存するんじゃないような状況についてチェックするのに、いろいろチェックもしなきゃならない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="476"><a name="476"><TD id="E476" onclick="javascript:toggleLayer('J476')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> But after checking all those things, then you take the substituted combined expression and put it through a pattern matcher, which recognizes all the valid instructions of your chosen target machine.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J476" onclick="javascript:toggleLayer('E476')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> でもこういうの全部チェックしたら、差し替えた組み合わせ式をパターン・マッチャーに通して、それが選んだターゲットマシンで有効な命令を全部認識してくれる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="477"><a name="477"><TD id="E477" onclick="javascript:toggleLayer('J477')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And if it's recognized, then you replace those two instructions with the combined one, otherwise you leave them alone.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J477" onclick="javascript:toggleLayer('E477')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それで認識されたら、その 2 つの命令を組み合わせ命令と置き換えて、そうでなきゃそのままにする。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="478"><a name="478"><TD id="E478" onclick="javascript:toggleLayer('J478')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And their technique is to combine two or three instructions related by data flow in this way.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J478" onclick="javascript:toggleLayer('E478')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そして連中の技法ってのは、データフローで関連づけた命令 2 つ 3 つをこうやって組み合わせることなんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="479"><a name="479"><TD id="E479" onclick="javascript:toggleLayer('J479')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> In the Arizona compiler, they actually represent things as text strings like this, and their compiler is horribly slow.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J479" onclick="javascript:toggleLayer('E479')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> アリゾナコンパイラでは、いろんなものをこういう文字列で表現してて、だから連中のコンパイラはとてつもなく遅い。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="480"><a name="480"><TD id="E480" onclick="javascript:toggleLayer('J480')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> First I had some idea of just using their compiler and making changes in it, but it was clear to me I had to rewrite it entirely to get the speed I wanted, so I have rewritten it to use list structure representations for all these expressions.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J480" onclick="javascript:toggleLayer('E480')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 最初はこのコンパイラをそのまま使ってちょっと変えるだけにしようかと思ったけれど、でもぼくの求めるスピードを出すには完全に書き換えるしかないのは明らかだったので、こういう式すべてにリスト構造の記法を使うように書き直した。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="481"><a name="481"><TD id="E481" onclick="javascript:toggleLayer('J481')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Things like this:
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J481" onclick="javascript:toggleLayer('E481')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえばこういうの：
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="482"><a name="482"><TD id="E482" onclick="javascript:toggleLayer('J482')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> (set (reg 2)      (+ (reg 2)    (int 4)))
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J482" onclick="javascript:toggleLayer('E482')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> (set (reg 2)      (+ (reg 2)    (int 4)))
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="483"><a name="483"><TD id="E483" onclick="javascript:toggleLayer('J483')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> This looks like Lisp, but the semantics of these are not quite LISP,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J483" onclick="javascript:toggleLayer('E483')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> なんか LISP っぽいけど、でもこいつの意味はそんなに LISP してない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="484"><a name="484"><TD id="E484" onclick="javascript:toggleLayer('J484')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> because each symbol here is one recognized specially.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J484" onclick="javascript:toggleLayer('E484')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> ここの各シンボルは特別に認識されるものだから。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="485"><a name="485"><TD id="E485" onclick="javascript:toggleLayer('J485')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> There's a particular fixed set of these symbols that is defined, all the ones you need.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J485" onclick="javascript:toggleLayer('E485')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> こういうシンボルの集合が特別に定義されていて、必要なのは全部そこにある。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="486"><a name="486"><TD id="E486" onclick="javascript:toggleLayer('J486')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And each one has a particular pattern of types of arguments,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J486" onclick="javascript:toggleLayer('E486')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そしてそれぞれが特定の引数のパターンを持ってる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="487"><a name="487"><TD id="E487" onclick="javascript:toggleLayer('J487')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> for example: ``reg'' always has an integer, because registers are numbered, but ``+'' takes two subexpressions, and so on.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J487" onclick="javascript:toggleLayer('E487')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえば：「reg」は必ず integer で、それはレジスタに番号がついてるからだけど、「+」は必ずサブの式を二つ持ってて、とかね。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="488"><a name="488"><TD id="E488" onclick="javascript:toggleLayer('J488')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And with each of these expressions is also a data type which says essentially whether it's fixed or floating and how many bytes long it is.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J488" onclick="javascript:toggleLayer('E488')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そしてそれぞれの式にはデータ型があって、それが基本的に、それが固定か浮動か、バイト長はどんだけか、なんてことを指示する。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="489"><a name="489"><TD id="E489" onclick="javascript:toggleLayer('J489')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> It could be extended to handle other things too if you needed to.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J489" onclick="javascript:toggleLayer('E489')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 必要なら、ほかの物を扱えるように拡張することもできる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="490"><a name="490"><TD id="E490" onclick="javascript:toggleLayer('J490')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And the way I do automatic register allocation is that when I initially generate this code, and when I do the combination and all those things, for every variable that conceivably go into a register, I allocate what I call a pseudo register number, which is a number starting at sixteen or whatever is to high to be a real register for your target machine.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J490" onclick="javascript:toggleLayer('E490')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それでぼくが自動レジスタ割り当てをやる方法ってのは、ぼくが最初にコードを生成するとき、組み合わせとかいろいろやるときだけど、レジスタに入りそうな変数にはすべて、自称疑似レジスタ番号ってのを割り振って、これは 16 とかなんとか、そのターゲットのマシンで実際のレジスタになるには大きすぎる番号からはじまる数字だ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="491"><a name="491"><TD id="E491" onclick="javascript:toggleLayer('J491')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So the real registers are numbered zero to fifteen or whatever and above that comes pseudo registers.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J491" onclick="javascript:toggleLayer('E491')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから本物のレジスタは 0 から 15 までとかなんとかに割り当てられてて、そのあとに疑似レジスタがくる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="492"><a name="492"><TD id="E492" onclick="javascript:toggleLayer('J492')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And then one of the last parts of the compiler consists of going through and changing all the pseudo registers to real registers.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J492" onclick="javascript:toggleLayer('E492')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> それで、コンパイラの最後のところで何をやるかというと、ずっと見てって、疑似レジスタを本物のレジスタに変えてくんだ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="493"><a name="493"><TD id="E493" onclick="javascript:toggleLayer('J493')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Again it makes a conflict graph, it sees which pseudo registers are alive at the same point and they of course can't go in the same real register, and then it tries packing pseudo registers into real registers as much as it can, ordering them by priority of how important they are.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J493" onclick="javascript:toggleLayer('E493')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> またもやここでコンフリクトグラフをつくって、どの疑似レジスタ同士が同じ時点で生きてるかを見て、もちろんそれを本物のレジスタの同じところに入れるわけにはいかないので、だからなるべく疑似レジスタを固めてなるべく本物のレジスタに入れるようにして、しかもその重要度に応じて並べるわけ。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="494"><a name="494"><TD id="E494" onclick="javascript:toggleLayer('J494')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> And finally it then has to correct the code for various problems,
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J494" onclick="javascript:toggleLayer('E494')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> そして最後に、いろんな問題に対応してコードを訂正しなきゃならない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="495"><a name="495"><TD id="E495" onclick="javascript:toggleLayer('J495')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> such as happen when there were pseudo registers that don't fit in the real registers, that had to be put into stack slots instead.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J495" onclick="javascript:toggleLayer('E495')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえば本物のレジスタにおさまりきらない疑似レジスタがあって、それをかわりにスタックのスロットに入れなきゃならないとする。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="496"><a name="496"><TD id="E496" onclick="javascript:toggleLayer('J496')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> When that happens on certain machines, some of the instructions may become invalid.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J496" onclick="javascript:toggleLayer('E496')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> 一部のマシンだと、これが起きると命令の一部は無効になっちゃうかもしれない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="497"><a name="497"><TD id="E497" onclick="javascript:toggleLayer('J497')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> For example on the 68000 you can add a register into memory and you can add memory into register, but you can't add one memory location into another.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J497" onclick="javascript:toggleLayer('E497')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> たとえば 68000 だと、レジスタの内容をメモりに加算したり、メモリの内容をレジスタに加算したりはできるけれど、メモリの内容同士の加算はできない。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="498"><a name="498"><TD id="E498" onclick="javascript:toggleLayer('J498')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So if you have an ADD instruction, and you're headed for a 68000 and both of the things end up in memory, it's not valid.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J498" onclick="javascript:toggleLayer('E498')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから ADD 命令があって、68000 を相手にしてて両方の値がメモリにおさまっちゃったら、この命令は無効になる。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="499"><a name="499"><TD id="E499" onclick="javascript:toggleLayer('J499')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> So this final pass goes through and copies things into registers and out of registers as needed to correct those problems.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J499" onclick="javascript:toggleLayer('E499')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> だから最後のパスでは、ずっと見てって、必要に応じていろんなものをレジスタにコピーしたり、戻したりして、こういう問題を片づける。
 </TD></a></TR><!-- TRANS_PAIR END -->
<!-- TRANS_PAIR BEGIN --><TR id="500"><a name="500"><TD id="E500" onclick="javascript:toggleLayer('J500')" BGCOLOR=#F0F0F0 style="visibility : visible" width=50% VALIGN=TOP> Problems can also arise with index registers.
 </TD><TD VALIGN=TOP BGCOLOR=#FFFFFF><BR></TD><TD id="J500" onclick="javascript:toggleLayer('E500')" VALIGN=TOP BGCOLOR=#F0F0F0 style="visibility : visible"> インデックスレジスタも問題になる。
 </TD></a></TR><!-- TRANS_PAIR END -->
</TABLE></span><HR>
<a href="rms-3.htm">prev</a>
<a href="rms-0.htm">0</a>
<a href="rms-1.htm">1</a>
<a href="rms-2.htm">2</a>
<a href="rms-3.htm">3</a>
<4>
<a href="rms-5.htm">5</a>
<a href="rms-6.htm">6</a>
<a href="rms-7.htm">7</a>
<a href="rms-8.htm">8</a>
<a href="rms-9.htm">9</a>
<a href="rms-5.htm">next</a>
<hr>

<h2><a name="preamble">このページにある対訳文について</a></h2>このページの対訳文は，再配布可能な作品（<a href="http://www.gutenberg.org/">Project Gutenberg</a> や<a href="http://www.aozora.gr.jp/">青空文庫</a>や<a href="http://www.genpaku.org/">プロジェクト杉田玄白</a>などの作品）について，日本語文と英語文とを対応付けたものの一つです．その他の対訳作品やダウンロードや著作権などについては，<a href="../index.html">日英対訳文対応付けデータのホームページ</a>を見て下さい．また，オリジナルの日英作品の著作権についてはオリジナルの日本語文および英語文の著作権を見て下さい．なお，著作権上の問題がある作品については，情報通信研究機構自然言語グループ内山将夫（ｍｕｔｉｙａｍａ あっとまーく ｎｉｃｔ どっと ｇｏ どっと ｊｐ）まで連絡していただければ，それらについては削除します．<h3>関連ページ</h3><ul><li>オリジナルの英語文: <a href="../org/rmse.txt">local copy</a><li>オリジナルの日本語文: <a href="../org/rmsj.txt">local copy</a><li><a href="../manual-alignment/rms.alm">対訳データ</a></ul><p>
<script type="text/javascript">
<!--
document.F.CE.checked = false
document.F.CJ.checked = false
// -->
</script>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</BODY></HTML>

