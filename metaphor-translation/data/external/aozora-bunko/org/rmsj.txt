RMS lecture at KTH (Sweden), 30. October 1986.

[Valid HTML 4.0!]  [ [image of the Head of a GNU] ](jpeg 7k) (jpeg 21k)

特許問題のため、gif は使わないのだ。

Copyright (C)1987 Richard M. Stallman and Bjorn Remseth, (C)1998 Yamagata
Hiroo.
Permission statement below

プロジェクト杉田玄白　正式参加作品。詳細は http://www.genpaku.org/ を参照の
こと。

リチャード・M・ストールマン　スウェーデン王立工科大学講演 RMS Lecture at
KTH (Kungliga Tekniska Hogskolan)

記録：Bjorn Remseth 翻訳：山形浩生

(c) 1987 Richard M. Stallman and Bjorn Remseth, (c) 1998 山形浩生

　この日本語訳は書式とファイル形式以外の改変を加えずこの版権表示を残す限り
において自由に再配布が認められる。
　なお、この日本語訳は訳者としては正確無比以上にやった自信はあるものの、そ
の正しさや正確さについては、英語原文の版権所有者も FSF も、なんら保証はしな
いし、また責任を負うものでもない。

講演日：30 October 1986、1998 年 8 月訳

原文最新版：http://www.gnu.org/philosophy/stallman-kth.html
翻訳最新版：http://cruel.org/freeware/rmslecture.html
同 pdf 版：http://cruel.org/freeware/rmslecture.pdf
同 ps 版 (tar+gzipped)：http://cruel.org/freeware/rmslecture.tgz

  ------------------------------------------------------------------------

概要

　1986 年 10 月 30 日に、リチャード・M・ストールマンがスウェーデンのストッ
クホルム市にある王立工科大学で行った講演の講演録。第一部では、1970 年代の
MIT AI 研におけるハッカー文化、商業主義によるその破壊と、それに対抗してハッ
カー文化を再興させるべくフリーソフトの GNU プロジェクト開始をストールマンが
決意するまでの過程が述べられている。第二部では GNU EMACS をはじめとする GNU
プロジェクトそのものについて、歴史的な解説とともに、内部での処理系に関する
考え方の解説も含めて語られている。第三部では、ストールマンの情報著作権や所
有権についての考え方をはじめ、 GNU プロジェクトや FSF の背後にある思想が述
べられる。情報やソフトは社会効用からみても共有されるべきであり、それを妨げ
る著作権やソフト隠匿はまちがっている、と主張されている。

　なお、原文は切れ目のない講演録であり、章分けとその命名および概要の追加は
訳者の判断でやった。

  ------------------------------------------------------------------------

目次

1 イントロ

2 GNU 前史：MIT AI 研

　　2.1 MIT AI 研のハッカー文化とその崩壊

　　2.2 ハッカー文化の再生を目指して

3 GNU プロジェクト

　　3.1 はじめの一歩

　　3.2 GNU EMACS

　　3.3 GDB デバッガ

　　3.4 gcc コンパイラ

　　3.5 TRIX カーネル

4 情報、ソフトと著作権

　　4.1 ソフトの所有とその害

　　4.2 ソフト所有肯定論への反駁

　　4.3 ソフト隠匿との闘い

5　質疑応答

  ------------------------------------------------------------------------

[コメント：これは 1986 年 10 月 30 日に、リチャード・M・ストールマンが、学
生会「Datorforeningen Stacken」の招きでスウェーデンのストックホルム市にある
王立工科大学で行った講演のテープ起こしに、ちょっと手を入れたものだ。だから
変な始まりかたや、口語では自然だけれど字にするとへんてこな語法も入ってる。
これを「もとの講演をゆがめることなく」文語にするにはどうすればいいか、よく
わかんないのだ。]

（訳注：日本語にしちゃえば同じことだけど、講演としての性質を尊重して、ここ
ではなるべくバリバリの口語文体を採用してる。文法的に不正確な日本語もたくさ
んあるけれど、原文の変なとこを残したせいで生じてる部分がほとんどだから、揚
げ足をとらないよーに。）

  ------------------------------------------------------------------------

1. イントロ

　みんながぼくに話してほしい話題は三つあるみたいだね。一つはまず、このハッ
カー集団に話すのにいちばんいいのは、昔の MIT ってのがどんなとこだったのかっ
てことかな、と思った。人工知能研究所のどこがそんなに特別だったのか。でも、
今日きてる人は月曜と火曜に会議にきたのとぜんぜんちがう人だから、GNU プロジ
ェクトがどうなってるかとか、ソフトウェアや情報がなぜ所有できないかとかにつ
いて話すべきだ、とも言われた。ということはつまり全部で三つの話ってことで、
このうち 2 つがそれぞれ 1 時間かかったんだから、みんなかなり長時間ここにい
ることになるわけだ。それで思ったんだけれど、全体を 3 つにわけて、みんな自分
の興味がない部分は外に出られるようにして、それで各部分の終わりにきたら、終
わりだって言うから、みんな外にでて、それでぼくはヤン・ライニングにお願いし
てほかの人を呼んできてもらうようにするってのはどうだろう。（だれかが
「Janne, han trenger ingen mike」 (「Janne、この人マイクなんかいらないよ」)
と言う）ヤン、ひとっ走りして人を呼んできてもらってもいい？

Jmr: マイクを探してるんですけど、なんかこの鍵のかかった箱の中にあるっていう
んですよ。

Rms: うん、昔の AI 研でなら、でっかいハンマーを持ってきてそいつをぶち開けて
ただろうね。その壊れたドアを見て、みんなが必要とするものを鍵かけてしまいこ
もうとするようなヤツも少しは勉強になったろう。でも運のいいことに、ぼくは昔
ブルガリア歌唱法を勉強したことがあって、だからマイクなしでも全然問題ない
よ。 とにかく、話がどの部分か知らせるシステムって要る？　それともずっとすわ
って全部きいてたい？（答：そうだそうだ)

  ------------------------------------------------------------------------

2. GNU 前史：MIT AI 研

2.1 MIT AI 研のハッカー文化とその崩壊

　ぼくがプログラミングをはじめたのは 1969 年のことで、ニューヨークの IBM 研
究所でのことだった。そのあと、コンピュータ科学の学部がある学校があって、ま
あここはほかと似たりよったり。何をすべきか決める教授たちがいて、だれが何を
使っていいか決める連中がいて。ほとんどの人には端末が不足してたんだけれど、
教授たちはほとんどみんなオフィスの中に専用端末を持ってて、これは資源の無駄
なんだけれど、連中の姿勢からすればまあありがちなことだよね。　

　MIT の人工知能研に遊びにいったら、そういうのとは爽快なくらいにちがった精
神があったんだ。たとえば、そこでの端末はみんなのものだと思われてた。だから
自分のオフィスに鍵をかけるような教授は、ドアがぶち破られるというつらい目に
あうわけ。ある教授のオフィスのドアをぶち破るのに使った、でっかい鉄のかたま
りが載った台車をホントにみせてもらったよ。その頃は端末はほんとに少なくて、
システム全部にディスプレイ端末 5 つくらいかな、だからそのうち 1 台がしまい
込まれてると、ものすごい損害だったわけ。　

　その後の数年、ぼくはその考え方に刺激を受けて、何度も天井をのりこえたり床
下を這ったりして、みんなが使いたいマシンのある部屋の鍵を開けてきた。そして
通常は、ドアに鍵をかけるような身勝手なまねはしなさんな、というメモをおいて
った。ドアに鍵をかけるような人は、基本的には自分のことしか考えてないんだ。
もちろんその人たちにもそれなりの理由はあるだろう。何か盗まれそうなものがあ
ってそれに鍵をかけときたいとか。でも同じ部屋にある別のものがしまいこまれち
ゃうと、ほかの人に影響が出るってことは気にもしなかったんだ。これが起きる度
に必ずいえることだけど、それで一回はぼくも指摘したんだけど、別の解決策はあ
るんだ。鍵をかけるかどうかってのはかれらの勝手じゃないんだ。心配なものをし
まっとく場所はほかにもあるし、デスクに鍵をかけることだってできる。でも要す
るに、みんなそんなことをわざわざ考えようとはしないんだよね。「この部屋はお
れのだ、鍵をかけるのもおれの勝手、ほかの連中クソ食らえ」と思ってる。そして
これぞまさに、持ってはいけない精神なんだってことは教え込む必要がある。

　でも、この鍵をかけない精神は、孤立したものじゃなくて、生き様全体の一部だ
ったんだ。AI 研のハッカーたちはいいプログラム、おもしろいプログラムをかくこ
とにすごく熱心だった。そしてもっともっと作業したくてたまんなかったので、端
末に鍵がかかってるなんて黙ってられなかったんだ。あるいはその他、役に立つ仕
事をじゃましようとして人がやるいろんなこととかも。そのちがいってのは、高い
モラルをもってて、自分が何をしようとしてるのか本当に気にかけてる人と、ただ
の仕事でやってる人との差だ。ただの仕事なら、雇い主が馬鹿で、こっちがずっと
何もしないですわってなきゃなんなくたって、だれが気にするもんか。連中の時間
だし、連中の金だし。でもそんなとこでは、大した仕事はできないし、そんなとこ
にいたっておもしろくもなんともない。

　あと、AI 研になかったものといえば、ファイル保護。コンピュータにはセキュリ
ティはまったくなかった。そしてこれはきわめて意識的に選んだ道だった。
Incompatible Timesharing System (ITS) を書いたハッカーたちは、ファイル保護
なんてものは身勝手なシステム管理者が、ほかのみんなに対して権力を行使するの
に使うもんだって思ってた。ハッカーたちは、そんな権力を行使されるのはまっぴ
らだったから、その手の機能は実装しなかった。結果として、システムのどこかが
こわれたら、いつも自分でなおせた。いらいらしながらじっとすわってなきゃなら
ないなんてことは絶対許せないよね、こっちはどこがおかしいかずばりわかって
て、それなのにだれかが、自分を信用してないからそれをさせないと決めてるなん
て。あきらめて家に帰って、朝にだれかがきてシステムをなおしてくれるのを待つ
なんて、しなくていいじゃない。何をしなきゃいけないのか、自分にはその人の10
倍もよくわかってるってのに。

　あと、どんな作業をやるのかについても、教授だの上司だのには決めさせなかっ
た。だってぼくたちの仕事はシステムの改善だったんだもん！　もちろん利用者と
は話をした。だってそうしないと何が必要かわからないからね。でもそれがすんだ
ら、どんな改善が実現可能かいちばんよく判断できるのはぼくたちだったんだ。そ
してぼくちはいつも、システムをこう変えたらいいだろうな、とかほかのシステム
で、こんないかしたアイデアを見たよ、とか、それを使えないものかな、とか話し
てた。だから結果として、そこにはなめらかに機能するアナーキーがあった。そし
てそこでの自分の経験から、ぼくはそれこそ人が生きる最高のやりかただと確信し
てる。

　残念ながら、そういう形の AI 研は破壊されちゃったんだ。何年ものあいだ、AI
研は MIT の別の研究所、コンピュータ科学研に破壊されるんじゃないか、というの
がぼくたちのおそれていたことだった。そこの所長は一種の帝国建設者タイプで、
自分の組織をでかくして MIT の中で昇進するためならなんでもやるような人間で、
いつも AI 研を自分の研究所に吸収しようとしてたんだ。だれもそいつの流儀でな
んか作業したくなかった。そいつは、人は指示に従うべきだとかなんとか、その手
のことを信じてたからね。

　でもその危険に対してはなんとか防衛できたのに、まったく予想してなかったも
のによってぼくたちは破壊されてしまった。それが商業主義だった。1980 年代初期
になって、ハッカーたちがハッと気がつくと、自分たちのやっていることには商売
上の関心がもたれていたわけ。民間企業で働いて金持ちになることが可能になった
んだ。必要なのは、自分の仕事をほかの世界と共有するのをやめて、MIT AI 研をぶ
ちこわせばいいだけ。そしてぼくは手を尽くしてそれを止めようとしたけど、でも
みんなそれをやっちゃったんだ。

　要するに、AI 研にいたぼく以外の有能なプログラマは、みんな雇われてやめちゃ
って、おかげでそれは一時的な変化じゃすまなくなってた。永続的な変化が生じ
た。ハッカー文化の連続性がとぎれちゃったんだよ。新人ハッカーはいつだって古
参ハッカーに惹かれる。だっていちばんおもしろいコンピュータがあって、いちば
んおもしろいことしてる人たちがいて、そして参加したら最高におもしろいスピリ
ットもあったんだから。それがなくなったら、そこを新人に推薦するべき理由もな
くなっちゃって、だから新人もこなくなった。ひらめきを受けるような人もない
し、伝統を学べる人もいないし。ついでに、いいプログラミングを学ぶ人もいな
い。いるのは、使えるプログラムを書く方法なんか実は知らない教授や院生がうじ
ゃうじゃいるだけだから、使えるプログラムの書き方なんか習えるわけがない。だ
からぼくの愛した MIT AI 研はもうなくなった。そして何年か、それをやった人た
ちと闘って連中に罰を与えようとしてから、ぼくはその精神をもった新しいコミュ
ニティづくりに精を出そうと決めたんだ。

　でも、直面せざるを得なかった問題の一つが、独占ソフト（proprietary
software）の問題だった。たとえばハッカーたちが去ってから研究所で起こったこ
との一つは、ぼくたちが開発したマシンやソフトがもうメンテされないってことだ
った。ソフトはもちろん動いたし、だれもそれを変えなければずっと動いてたけ
ど、でもマシンはそうはいかない。マシンは壊れるし、だれもなおせるやつがいな
いから、やがて捨てられる。昔は、ええ確かに保守契約なんてものはあったけど、
でもまあ悪い冗談みたいなもんだった。それって単に、AI 研のエキスパート・ハッ
カーたちが問題を解決してから、パーツを入手するための手段でしかなかった。だ
って修理担当者になおさせたら、何日かかるやらわかんなくて、そんなのやってら
れないよね、すぐ動くようにしてくれないと。だから、やりかたのわかってる人間
がだまって行ってさっさとなおして、それでそいつらはどんな修理担当者より 10
倍も有能だったから、ずっとましな仕事をしたんだ。それでそうすると、こわれた
基板とかが出るから、それをそこにおいといて、修理担当者には「こいつを持って
帰って、新しいのをちょっともってきてくださいね」と言うわけ。

　すごい昔の頃だと、ハッカーたちは Digital からきたマシンのほうも変更した。
たとえば、PDP-10 のてっぺんにのせる呼び出し用ボックスもつくったんだよ。最近
だと、ここ（ストックホルム）でもそういうことをする人はいると思うけど、当時
はかなり異例なことだった。それにうーんと昔、1960 年代初めとかだと、みんなコ
ンピュータを変更して、いろんな新しい命令を足したり、すっごい TSS 機能を足し
たりして、だから MIT の PDP-1 は、引退する頃には 60 年代はじめに Digital が
届けたときの 2 倍くらいの命令を持ってたし、特別なハードウェア・スケジューラ
補助機能や変なメモリマッピング機能なんかもあって、個別ハード装置を特定の
TSS ジョブに割り当てたり、その他ぼくでもほとんど知らないようないろんなこと
になってた。それと確か、一種の拡張アドレッシングモードも組み込んで、インデ
ックスレジスタ修飾とか間接修飾とか追加して、要するに軟弱なマシンだったのを
そこそこ使えるものにまで仕立てたんだ。

　VLSI の欠点の一つは、もうマシンの命令を追加したりできなくなっちゃったこと
だろうね。

　PDP-1 にはまたすごくおもしろい特徴があって、おもしろいプログラムをほんの
数命令で書けちゃうってこと。それ以降のどんなマシンよりも少ない命令数でね。
確かたとえば有名なディスプレイのハック「マンチング・スクウェア」ってのがあ
って、四角がどんどんでかくなって、それがたくさんの小さい四角に分裂して、そ
れがまた大きくなってそれがまた小さいのに分裂するんだけど。これって PDP-1 で
はなんか 5 命令くらいで書かれてた。それとかいろんな美しいディスプレイプログ
ラムが、ほんの数命令で書ける。

　というわけで、これが AI 研の様子だった。でもハッカーたちの文化は、アナキ
ズム以外にはどんなものだったのか？　PDP-1 の頃には、マシンは一度に 1 人のユ
ーザしか使えなかった。少なくとも最初はね。何年かして TSS を書いて、それ用に
たくさんハードを追加した。でも初めの頃は、時間枠を予約しなきゃならなかっ
た。さてもちろん、公式プロジェクトの仕事をしてる教授や学生は、いつも昼間に
やってくる。だから時間がたくさんほしい人たちは、競争の少ない夜を予約する。
これでハッカーたちは夜に働く習慣ができた。TSS が入ってからも、ユーザが少な
かったから夜のほうが時間をとりやすい、CPU サイクルは夜のほうが使えたわけ。
だから作業をいっぱいしたい人は、相変わらず夜にやってきた。でもその頃になる
と、それだけじゃなくなってて、それは自分がもう 1 人じゃなくて、ほかにも何人
かハッカーたちがいたからで、だから社会的な現象になったのね。昼間にきたら、
たぶんいるのは教授や学生とか、マシンをほんとは愛してない連中だけど、夜なら
ばそこにはハッカーがいる。だからハッカーたちは、自分の文化に加わるために夜
にやってきた。そしてハッカーたちはほかの伝統も開始した。朝の 3 時にテイクア
ウトの中華料理を買ってくるとか。だからぼくは、チャイナタウンから戻ってくる
車の中から見た日の出がいくつも記憶に残っている。日の出を見るってのは、すご
く美しいもので、だって一日の中ですごく穏やかな時間だからね。寝る準備をする
にはすばらしい時間帯だ。ちょうど空が白んできて、鳥が鳴き出す頃に家に歩いて
くと、穏やかな満足感が実感としてあるんだ、その晩にやった仕事に対する静謐な
気持ちってのが。

　ほかにもぼくたちのはじめた伝統は、研究室に泊まること。ぼくがはじめてそこ
に行ったときから、研究室には少なくとも一つベッドがあった。そしてぼくは、ほ
かの人よりちょっとばかし研究室で暮らす期間が長かった。1 年か 2 年おきくらい
に、あれやこれやでアパートがなくて、だから研究所で数ヶ月暮らしたりしたん
だ。いつでもすごく快適で、しかも夏にはすごくすずしくていいんだ。でも、研究
所で寝ちゃう人を見かけるのはぜんぜんしょっちゅうで、これもまた熱意のせいだ
よね。とにかく手をとめたくないからできるだけながいこと起きててハッキングす
る。そして完全に疲れきったら、最寄りのやわらかい水平面によじのぼる。すごく
形式張らない雰囲気。

　でもハッカーたちがみんな研究所を離れたら、これは人口構成の変化を招いた。
マシンをほんとは愛してない教授や学生どもは、昔と同じにうじゃうじゃいたか
ら、連中がいまや強い勢力になったわけで、みんな怖がってた。システム管理をし
てくれるハッカーがいなくなったので、連中はこう言ったんだ。「このままじゃ大
変なことになる、商業ソフトを入れなきゃ」そして「そしたらメーカーがメンテも
してくれるよ」だって。やがて連中がまったくまちがってたことが証明されたけ
ど、でも連中はそれをやったんだ。

2.2 ハッカー文化の再生をめざして

　まさにその時に、新しい KL-10 システムがくるはずになってて、そこでの問題
は、それで Incompatible Timesharing System を動かすか、Digital の Twenex シ
ステムを動かすかってことだった。ハッカーたちはたぶん ITS を使うのを支持した
ろうけど、それがいなくなってたから、学者タイプの連中は商業ソフトを使う選択
をして、これはすぐに目に見えて影響が出てきた。なかにはそんなすぐには出てこ
なかったものもあったけど、でもこの問題を考えてみた人ならわかるように、遅か
れ早かれ出てきたんだ。

　一つには、そのソフトはずっと質が悪くて、わかりにくくて、だから本当に必要
な変更をするのがむずかしかったってこと。もう一つの影響は、このソフトにはセ
キュリティがあって、おかげでみんながお互いに協力する機会はどうしても減って
きた。ITS の時代には、だれもがどんなファイルでも見て変えられるってのはいい
ことだと考えられてた。それなりの理由があったからね。それで思い出したけど、
だれかが Macsyma の使い方について助けてくれって言ってきたときに、おもしろい
スキャンダルがもちあがったんだ。Macsyma ってのは MIT で開発したシンボリック
数学プログラム。その人は、Macsyma の作業をしてるある人に、助けてくれってメ
ールを出したら、数時間たって別の人から返事がきた。その人はびっくりしちゃっ
て、「だれそれはあなたのメールを読んでるみたいですよ、ひょっとしてメールの
ファイルの保護がちゃんとしてないんじゃないですか？」「当然でしょう、ぼくた
ちのシステムでは保護されてるファイルなんかない。なんかいけませんか？　あな
たはすぐに答がもらえたし、何が不満なの？　ぼくたちはお互いのメールを読む。
あたりまえじゃん、そうやってあなたみたいな人を見つけて助けてあげるんだか
ら」まったく、自分が得してるのにわかんない人ってのもいるんだからなぁ。

　でももちろん、Twenex にはセキュリティがあっただけでなく、それをデフォルト
で機能させるし、さらにセキュリティが使われてるという前提で設計されてる。だ
から、簡単にできちゃってすごいダメージを与えるようなことってのがたくさんあ
って、うっかりそういうことをしないようにしてくれる唯一の手段がセキュリティ
なんだ。ITS では、そういうことをうっかりやっちゃわないようにするほかのいろ
んな方法が考案されてた。でも Twenex にはそんなものはない。厳格なセキュリテ
ィが機能してて、そういうことをする権限を持つのはボスたちだけだ、と想定して
たからだ。だから、そういううっかりミスを難しくするメカニズムはほかにぜんぜ
んつけてなかった。その結果として、単に Twenex をもってきてセキュリティをオ
フにするとほしいものが手に入るわけじゃなくなってて、そしてその他のメカニズ
ムを入れ込むハッカーたちもいなかったから、みんなセキュリティを使うしかなく
なってた。そしてマシンがやってきて 6 ヶ月ほどしたら、連中はクーデターをはじ
めた。つまり、最初は AI 研で働いてる人はみんな、全セキュリティ機能をオーバ
ーライドする全権を与えるホイールビットをオンにしてもらえるもんだ、という想
定をしてた。でもある日のある午後にやってきてみると、ほとんど全員のホイール
ビットがオフにされてた。

　こんなのがわかったとき、ぼくはそれを打倒した。最初は、たまたまエリート層
に属してるある人のパスワードを知ってたので、それを使ってみんなのビットを戻
せた。二回目には、そいつはパスワードを変えてて、だから所属意識も変わって
て、いまやもう貴族社会の一員だった。そこでぼくはマシンを停止させて、TSS で
ない DDT を使ってつつきまわさなきゃなんなかった。モニタの中でつつきまわし
て、やがて OS をロードさせてパッチがあてられるようにするにはどうしたらいい
かつきとめて、それでパスワードのチェックをオフにして、それからいろんな人の
ホイールビットを戻して、システムメッセージをポストした。説明しとくとこのマ
シンの名前は OZ で、だからこんなシステムメッセージをポストした。「またもや
権力を奪取せんとする試みが行われた。いまのところ、貴族階級の勢力は打倒され
た ―― ラジオ・フリー・OZ」あとで知ったんだけど、「ラジオ・フリー・OZ」と
いうのはファイアサイン劇場で使ってるものの一つなんだね。その頃は知らなかっ
た。

　でも状況はだんだんと、どんどん悪いほうに向かってったね。要はそのシステム
のつくられかたのせいで、それがみんなもっともっとセキュリティを要求するよう
な性質もものだったってこと。しまいにやがて、ぼくはそのマシンを使うのをやめ
なきゃなんなくなってきた。MIT AI 研にパスワードが初めて登場して以来、ぼくは
自分の信念のために立ち上がろう、パスワードなんかあってはならないという信念
にしたがおう、絶対にできるだけわかりやすいパスワードにして、それをみんなに
ばらすようにしようと決心したんだ。ぼくはコンピュータにセキュリティをつける
のはいいととは思わないから、セキュリティ支配が続くのを助けるようなこともす
べきじゃない。「空のパスワード」を使えるシステムでは使うし、それが許されな
いシステムとか、それだとほかの場所からは一切ログインできないとか、その手の
システムとかだと、ぼくはログイン名をパスワードにする。これ以上はないってく
らい自明でしょ。そしてだれかが、そんなことだと他人がきみになってログインで
きちゃうじゃないか、と指摘すると、ぼくはこう言う。「うん、まさにそれがねら
い。だれかがこのマシンのデータを必要とするかもしれない。そのときに、その人
がセキュリティのおかげでバカを見たりすることが絶対ないようにしときたいの
よ」

　それともう一つやるのが、自分のディレクトリやファイルの保護は全部はずす。
だって役に立つソフトをそこに持っていることもよくあって、もしそれにバグがあ
ったら、みんながなおせるようにしときたいから。

　でもこのマシンはまた、「観光」と呼ばれる現象をサポートするようにはできて
いなかった。さて、「観光」ってのは AI 研ではすごく古い伝統で、ほかの形のア
ナーキーといっしょに続いてきてて、これはつまり、部外者にも自由にマシンを使
わせるってこと。さて昔々、だれでもマシンにやってきて、勝手な名前でログイン
できた頃には、これはもう自動的にそうなってた。もし MIT に遊びにきてたら、ロ
グインして作業ができる。後にこれをちょっとは形式化した。これは特に ARPAnet
がはじまって、みんな全国からうちのマシンにつなぐようになったときにそうで、
みんなが認める伝統としてってこと。さて、ぼくたちが期待してたのは、そういう
部外者がプログラミングを実際に学んで、OS を変えはじめることだった。この話を
ほかのどこのシステム管理者にしても、みんな飛び上がるよ。どんな部外者でもマ
シンが使えるなんて匂わせようものなら、その人は言うだろう。「でもそいつがシ
ステムプログラムを変えちゃったらどうすんの？」でもぼくたちにとっては、部外
者がシステムプログラムを変えはじめるってことは、それはつまりその人がコミュ
ニティに貢献するメンバーになろうと本気で興味を示してるってことなんだ。ぼく
たちはいつも、そうするよう奨励してる。最初はもちろん、新しいシステムユーテ
ィリティを書くところから、それも小さいヤツね、そしてそいつが何をやったか監
督して訂正するけど、でもそしたらそれから既存の大きなユーティリティに機能を
追加するほうに向かう。そしてそういうプログラムはもう 10 年とか 15 年とか存
在していて、一部一部ごとに、職人が次々と新しい機能を足してったものなんだ。

　フランスの都市みたいなもんだと言ってもいいかな。ものすごく古い建物に、数
百年後に増築がされて、それがずっといままで続いてるような。コンピュータの世
界だと、1965 年に書きはじめられたソフトってのがそれにあたる。だからぼくたち
はいつも、観光客がシステム管理者になってほしいと思ってて、そしたら雇われる
かもしれない。もちろんシステムプログラムの作業を始めて、まともな仕事ができ
ることを証明してくれればだけど。

　でも ITS のマシンには、これが手に負えなくなるのを防ぐための機能がほかにい
くつかあった。その一つが「スパイ」機能で、だれが何をしてるか、だれでも観察
できる機能だった。そしてもちろん、観光客はスパイするのが大好きで、みんなそ
れがいかしたことだと思って、つまりちょっとイケナイ感じだけれどでも結果とし
て、どっかの観光客が何か面倒を起こすようなまねをしても、必ずだれかがそれを
見てるわけ。それでやがてそいつの友だちはすごく怒りだす。観光が続いてくれる
ためには、観光客が責任ある行動をするかどうかにかかってるのを知ってるから。
それでたいがいは、そいつがだれだか知ってるやつがいて、それでそういうことを
しないように説明してもらえるんだ。それができなかったら、どうするかっていう
と、特定の場所からのアクセスをしばらく完全に切る。そしてそれを戻す頃には、
そいつはどっかよそへ行って、ぼくたちのことは忘れちゃう。だからこれが何年も
何年も何年も続いたんだ。

　でも Twenex システムは、この手のこと用には設計されてなくて、やがて連中は
みんなにパスワードを知られてるぼくを許してくれなくなった。観光客がいつもぼ
くの名前で同時に 2 人も 3 人もログインしてたわけ。だから連中はぼくのアカウ
ントを消すようになった。そしてその頃には、ぼくはどうせ別のマシンで作業して
るほうが多くて、だからやがてあきらめて、もうそっちのスイッチは入れなくなっ
た。それでそれはおしまい。もうあの機械にはずいぶんログインしてないな、自分
のアカウントではもう……（この時点で、RMS はすさまじい拍手にさえぎられる）
年も。

　でも連中が最初にこの Twenex システムを手に入れたら、まずいくつか変更をし
たがった。セキュリティの仕組みを変えたがった。それとそのマシンを ARPAnet と
MIT-CHAOS ネットワークに両方につなぎたがったんだけど、でも結局はそれができ
なくて、そういう変更をするだけの能力をもった人が見つけられなかったんだ。そ
れをするだけの才能がもうなくなってたし、そもそもシステムの変更がむずかしか
った。このシステムはずっとわかりにくくて、それはダメな書かれかたをしてたか
らで、もちろん Digital はそんなことしてくれなくて、だから商業システムなら基
本的にはシステム管理を会社がやってくれるという考え方は、結局まちがってるこ
とが証明されたわけ。システムハッカーに対するニーズは前と変わらなかったの
に、でもシステムハッカーをおびきよせる手段がもうなくなってた。そして最近の
MIT には、Twenex 上でハッキングしたがる人より ITS でハッキングしたがる人の
ほうが多いんだ。

　そしてそうなる最終的な理由ってのは、Twenex は共有できないってことなんだ。
Twenex は独占プログラムで、ソースコードを手に入れるには、ある嫌らしい方法で
それを秘密にしとかなきゃならなくて、これが印象を悪くしてる。その人が無関心
でなければ（そしてコンピュータ業界にはそういう人もいて、自分たちだけが楽し
ければなんでもやって、ほかの人たちと協力してるかなんて一瞬たりとも考えない
ような人たちだけれど、でもそんなソフトの作業をするのがどんなに悲しいことか
わかんないなんて、相当無関心じゃないとアレで、これがさらにマイナス要因だよ
ね）。そしてさらにだめ押しでくるのが、毎年かそこら、新しいリリースってのが
出てきて、それが 50,000 行くらいの追加のコードだらけで、それが全部サルが書
いたみたいな代物。それは連中が「サル 100 万匹にタイプさせれば、いずれなんか
使えるものが出てくる」式システム開発にしたがってるから。

　こういう独占システムで何が起きてるか見たとき、ぼくにははっきりわかった。
かつてのAI研のスピリットをぼくらが持つ唯一の方法は、フリーの OS をつくるこ
とだってのが。フリーソフトだけでつくったシステムができて、それがみんなで共
有できるようになることだって。そうすればみんなに、その改善に参加しようと呼
びかけられる。そしてそこから GNU プロジェクトが出てきたんだ。というわけで、
この話の第二部にやってきたってことだね。

  ------------------------------------------------------------------------

3 GNU プロジェクト

3.1　はじめの一歩

　だいたい 3 年半くらい前に、フリーソフトシステム開発に手をつけるべきだって
のは自分ではっきりしてきた。開発すべきシステムとしては二種類の可能性が LISP
マシンみたいなシステムで、ちょうど開発されたばかりの MIT LISP システムとま
ったく同じだけれど、でもフリーで、しかも特別な LISP マシンじゃなくて、ふつ
うのハードで動くヤツ。そしてもう一つの可能性が、もっと伝統的な OS をつくる
ってことで、その時にはっきりしてたのは、もし伝統的な OS をつくるなら、それ
は UNIX と互換性をもたせるべきだってこと。そうすればいろんなとこの人たちが
乗り換えやすいから。しばらくして、後者をやるべきだと決めたんだけど、その理
由は、ほんとの LISP マシンみたいなものを普通のハードではできないってのが見
えてきたからだったのね。LISP マシンは、実行速度を確保して、同時にランタイム
で堅牢なエラー探知をするために、特殊なハードと特別な書き込み可能なマイクロ
コードを使ってるんだ。エラーって、特にデータタイプのエラー。ふつうのシステ
ムで LISP システムを十分にはやく走らせるには、いろいろ仮定をおくようにしな
きゃなんない。ある引き数が正しいタイプだって仮定して、で、そうでなければシ
ステムはあっさりクラッシュ。

　もちろん外的なチェックを入れることはできるし、やりたきゃ堅牢なプログラム
も書けるけど、結局のところは、そのチェックを入れなければ、関数にまちがった
タイプの引き数を喰わせたら、メモリアドレッシングのエラーとかが起きちゃうっ
てことだ。

　だから結果としては、LISP システムの下で何かが走ってて、そういうエラーを拾
ってくれなきゃなんない。そしてユーザがシステムを動かし続けて、起きたことを
デバッグできるようにしないと。最後に、もし下の OS をつくるんなら、それはい
い OS にしようとも決心した ―― つまりこれは、OS と LISP か、あるいは OS だ
けか、という選択だった。だから、まずは OS をやるべきだろう、そしてそれは
UNIX 互換にすべきだ。最後にこのシステムの名前として英語でいちばんおもしろい
名前を使えるんだと気がついたら、ぼくの選ぶべき道ははっきりした。そのことば
はもちろん GNU で、これは「GNU 's Not Unix」の略。この再帰的な略称は、MIT
周辺のハッカー社会ではすごく古い伝統になってる。ぼくの知る限り、これは TINT
というエディタではじまったはず。これは「Tint Is Not Teco」の略で、それはや
がて「SINE Is Not EMACS 」の略で SINE とか、「Fine Is Not EMACS」で FINE と
か、「Eine Is Not EMACS」で EINE とか、「Zwei Was Eine Initially（Zwei はも
ともと Eine でした）」の ZWEI とか、そしていまはそれが GNU まできたわけ。

（訳注：ドイツ語では Eine は 1 で、Zwei が 2 だというのはもちろんご承知のこ
ととは思いますが……）

　だいたい 2 年半ほど前に実際に GNU の仕事をはじめてから、もう作業の半分く
らいは終えたと言っていいかな。このプロジェクトにとりかかろうとしてたとき、
まずはすでにフリーで出回ってるものは何があるかを探すとこからはじめた。そこ
で見つけたのが、おもしろいポータブルなコンパイラシステムで、これは「The
Free University Compiler Kit」という名前。こんな名前なら、もらえるのかな、
と思った。だから開発した人にメールを送って、 GNU プロジェクトにくれないか、
ときいてみたら、その人は「いや、free は大学にかかることばで、そこで開発して
るソフトはフリーじゃないんです」と言って、でもそれから言うには、かれも UNIX
互換システムがほしくて、それ用のカーネルみたいなものも書いてみたいから、そ
したらぼくがそれ用にユーティリティを書いて、そしたらその両方ともかれの独占
コンパイラといっしょに配布できて、そしたらみんながそのコンパイラを買いたが
るようになるだろう、だって。それでぼくは、ふざけんじゃないよと思って、だか
らそいつに、ぼくの最初のプロジェクトはコンパイラの開発だ、と言ってやった。

　その頃は、コンパイラの最適化について実は大して知らなかった。一度もいじっ
たことがなかったから。でも、その頃フリーだと言われたコンパイラを手に入れら
れた。それが PASTELっていうコンパイラで、作者たちに言わせると「色の薄い
PASCAL」という意味なんだって。

　Pastel はすごく複雑な言語で、パラメータ化された型や明示タイプパラメータ
（explicit type parameter）とか、いろいろ複雑なものを含んでた。コンパイラ自
身ももちろんこの言語で書かれてて、こういう機能の利用を最適化するのに、いろ
いろ複雑な機能を持っていたんだ。たとえばこの言語では string 型はパラメータ
化されていた。特定の長さの文字列がほしければ「string(n)」と書ける。単に
「string」と書けば、パラメータは文脈から決まってくる。で、文字列ってすごく
大事で、それを使ういろんな構造体を高速に走らせるためにも必要で、ということ
はつまり、各種のことを検出するようないろんな機能が必要ってことだよね、たと
えば、宣言されたストリング長が引数で、それが関数の中ではずっと定数であるこ
とを検出するとか、値を保存してそれが生み出すコードを最適化するとか、いろい
ろややこしいこと。でもこのコンパイラの中では、少なくともレジスタ自動割り当
てをどうするかとか、そういうことは読みとれたし、いろいろちがったマシンの扱
い方の考え方もわかった。

　さてこのコンパイラはすでに PASTEL をコンパイルできるので、必要なのは C の
フロントエンドをつけることで、これをやって、それから 68000 用のバックエンド
をつけることだった。68000 がぼくの最初のターゲットマシンになるものと思って
たから。でもここで深刻な問題にぶちあたった。PASTEL 言語は何かを使う前に宣言
しなくていいようになってたので、だから宣言と使用がどんな順序でもよくて、つ
まりは、Pascal の「forward」宣言は使いものにならなくて、おかげでプログラム
をまるごと読み込んで、それをコアにいれといて、一挙に処理するしかなかった。
結果としてコンパイラ内部で使われる中間記憶、つまり必要メモリ量は、ファイル
の大きさに比例して大きくなるわけ。そしてここにはスタック領域も含まれてて、
ものすごいスタック領域が必要で、だから結果としてわかったこと：ぼくの手もと
の 68000 システムではこのコンパイラは走らない。それはそのシステムが最悪の
UNIX で、スタックに 16K ワードとかの上限があって、これってマシン自体にはメ
モリが 6 メガバイトもあるのにだよ、スタックは 16Kw かそこらしかとれないって
の。そしてもちろん、一時的な変数値がかちあってないかとか、あるいは同時に生
きてるのがどれかとかを見るのに、コンフリクト行列を生成するんだけど、これは
ビット単位で4次元行列とかが必要で、大きな関数になるとそれが何百バイトとか何
千バイトにもなる。だからコンパイラは 10 パスくらいかそこらあったんだけど、
その最初のパスはなんとかデバッグして、それをそのマシン用にクロスコンパイル
して、そしてふたを開けてみたら、二番目のやつはそもそも走らない。

3.2　GNU EMACS

　こういう問題をどうしようか考えて、これをなおそうとするのか、それともまっ
たく新しいコンパイラを書こうか考えているうちに、なんやかんやで GNU EMACS の
作業にとりかかった。GNU EMACS は GNU システムの配布分の主要部分。拡張できる
テキストエディタで、ぼくが10年前に開発したオリジナルの EMACS とかなり似てる
けど、こいつは拡張用言語として本物の LISP を使うんだ。エディタ自身は C で実
装されてて、LISP インタープリタも同じく C で実装されてるから、LISP インター
プリタは完全に可搬性があって、エディタの外部に LISP システムを持たなくてい
い。エディタ自身が自前の LISP システムを持ってて、すべての編集コマンドは
LISP で書いてあるから、それをお手本として見て自前の編集コマンドを書いたり、
何からはじめるかとか、そういうのを変えて、自分が本当にほしい編集コマンドに
変えられるんだよ。

　その年の夏、いまから 2 年ほど前、ぼくの友だちがゴスリング EMACS の開発初
期に手伝ったので、ゴスリングからかれのバージョンのゴスリング EMACS を配布し
ていいよ、という許諾をメールで受け取ったと話してくれた。ゴスリングはもとも
と EMACS を書き上げて、それをフリーで配布して、たくさんの人が開発に協力し
て、それはゴスリング自身がマニュアルの中で書いたような、ぼくがもとの EMACS
を開始したのと同じ精神にしたがうというかれ自身のせりふに基づいた期待があっ
たからなんだ。そしたらゴスリングはそいつに著作権をつけて、みんなにそれを再
配布しないと約束させて、あげくにそれをソフトハウスに売って、みんなを後ろか
ら刺して裏切ったんだ。その後ゴスリングと個人的にやりとりしたけど、この歴史
を見て予想されるのと寸分の狂いもないくらい、臆病でふざけたやつだったよ。

　まあとにかく、その友たちがこのプログラムをくれて、それでぼくとしてはトッ
プレベルの編集コマンドを変えて、ぼくの慣れ親しんでるオリジナルの EMACS と互
換性を持たせたかった。それと数値引き数の組み合わせとかいろいろ扱えるように
して、ぼくのほしいような機能を全部扱えると期待できるようにするとか。でもし
ばらくやってるうちに、このエディタの拡張用言語、MOCKLISP っていうんだけど、
それがこの作業用には力不足だってのがわかってきた。計画してることをやるため
には、こいつをすぐにでもすげかえる必要があるってわかった。前にもいつかは
MOCKLISP を本物の LISP に置き換えようと思ってたんだけど、でも真っ先にそれを
やんなきゃっていうのがわかってきた。それで、MOCKLISP がなぜ「MOCK（にせ）」
ってついてるかというと、そこに構造体データタイプがないからなの。LISP リスト
もない。配列もぜんぜんない。LISP シンボルもない。これは名前つきオブジェクト
ね。MOCKLISP ではある名前に対してオブジェクトは一つしかなくて、だから名前を
タイプすると、いつも同じオブジェクトしか戻ってこないの。こいつのおかげでい
ろんなプログラムを書くのがえっらくやっかいで、ホントはそんなふうに使うんじ
ゃないようなややこしいストリング操作で、あれやこれやを処理しなきゃなんなか
ったわけ。

　それで LISP インタープリタを書いて、MOCKLISP をすげかえて、その過程で、エ
ディタの内部データ構造を書き直さなきゃならないこともわかった。ぼくはそうい
うのが LISP オブジェクトになっててほしかったから。LISP とエディタのインター
フェースがクリーンであってほしくて、それはつまり、エディタのバッファやサブ
プロセスやウィンドウやバッファ位置みたいなオブジェクトが、みんな LISP オブ
ジェクトでなきゃだめだってこと。そうじゃないとそれに作用するエディタのプリ
ミティブは LISP データの LISP 関数としてコールできるようにならない。という
ことは、こういうオブジェクトすべてのデータ形式を設計しなおして、それに作用
する関数もみんな書き直して、結果として 6 ヶ月後には、ぼくはエディタのほとん
どすべてを書き直してたってわけ。

　加えて、MOCKLISP でなんか書くのはすごく難しいので、MOCKLISP で書かれたも
のはみんなきたなくて、だから本物の LISP の力を使えるようにそれを書きなおせ
ば、それをみんなもっと強力でもっと単純でもっと高速にできたんだ。だからそれ
をやって、結果としてぼくがそれを配布しはじめときには、受け取ったものでその
まま使われてる部分はほとんどなかった。

　この時点で、ゴスリングがプログラムを売ったと思ってる相手の会社が、ぼくの
友だちがそれを配布する権利にケチをつけはじめて、メールはバックアップのテー
プに入ってて見つからなかった。そしてゴスリングは、そんな許可は与えてないと
否定する。そこでおかしなことが起きた。かれはこの会社と交渉してたんだけど、
この会社がいちばん気にしてるのは、自分たちが配布してるのと似たようなものが
出回っちゃ困るってことだったようなの。かれもまだ配布してたし、かれの職場 ―
― Megatest 社ね ―― も、かれがぼくにくれたのと同じものを配布してて、それ
はかれの変更の入ったゴスリング EMACS で、だからかれは連中とそれを配布するの
をやめるという合意をして、GNU EMACS を使うのに切り替えて、それでそしたら連
中は、かれが実はやっぱり許諾を得てたんだってことを認めて、そうすればおそら
くみんな満足ってことになるはずだった。そしてこの会社はぼくに相談をもちかけ
てて、GNU EMACS を配布させろ、もちろんそれはフリーだけど、でもいろんなサポ
ートや補助を売りたいから、その作業の手伝いにぼくを雇いたいって言う。だから
その後、連中の気が変わってその契約にサインするのを拒否して、ネットワーク
に、ストールマンにはプログラムを配布する権利はないというメッセージをポスト
したってのは、ちょっと変なんだよね。別に連中は何かするとか言ったわけじゃな
くて、単にいずれいつの日か何か手をうたないかどうかははっきりしないとか言っ
ただけ。そしてそれだけでみんなびびっちゃって、もうだれも使わなくなって、こ
れは悲しいことだ。

　（ときどき、一生かけてやるのに一番いい仕事ってのは、どっかで商売上の機密
になってる独占ソフトのでかい山をみつけて、それを街角で配って歩いて、もう機
密でもなんでもなくしてしまうことじゃないかと思って、みんなの手に新しいフリ
ーソフトをわたしたいならそのほうが自分で新しいソフトなんかを書くよりも、ぼ
くとしてはずっと効率のいいやりかたじゃないかと思うんだけれど、みんなそれを
受け取るのさえ怖がるほど臆病なんだもんな）

　というわけで、残り全部を自分で書き直すしかなくて、だからそれをやって、そ
れに一週間半くらいかかった。というわけで、やつらは大勝利をおさめてさぞ満足
だろうよ。そしてぼくは、それ以降はどんな形であってもやつらとは協力なんかす
るもんか。

3.3　GDB デバッガ

　で、GNU EMACS がそこそこ安定してから、というのはなんだかんだで1年半ほどか
かったんだけど、それからシステムのほかの部分に戻った。GDB っていうデバッガ
を開発して、これはCコード用のシンボリック・デバッガで、最近配布に入れるよう
にした。このデバッガは、かなりの部分が DBX の精神にのっとったもので、これは
バークレー UNIX についてくるデバッガね。コマンドは、何をしたいかを示すこと
ばと、それに続く引き数で構成される。このデバッガでは、コマンドはみんな短縮
形が使えて、よく使うコマンドは 1 文字の短縮形になってるんだけど、独自の短縮
形も好きなように使える。充実した HELP 機能もあって、HELP のあとになんでもい
いけどコマンドやサブコマンドまでタイプすると、そのコマンドの使い方が詳しく
説明される。もちろん C の表現をタイプすれば、どれでもその値を返してくれる。

　ほかにも、シンボリック C デバッガでは珍しいことができたりする。たとえば、
どのメモリアドレスにあるどの C データ型も参照できるんだよ。値を調べたり、値
を入れたりできる。だからたとえばあるアドレスのワードに浮動小数点の値を入れ
たければ、「これこれのアドレスにある FLOAT 型か DOUBLE 型のオブジェクトをよ
こせ」といって、それに割り当てればいい。もう一つできるのが、これまで調べて
みた値を全部調べられんの。調べた値は全部「値ヒストリー」にのっかる。このヒ
ストリーのどの要素でも、その番号で参照できるし、ただのドル記号（$）を使えば
最後の要素を簡単に呼び出せる。こうすると、リスト構造をトレースするのがすご
く楽になる。別の構造体を指すポインタを含むような C 構造体があったとするでし
ょ、そしたらたとえば PRINT *$.next みたいなことができて、これはつまり「さっ
きみせてくれたものの次のフィールドをとってきて、それが指してる構造体を表示
しろ」ってことだ。そしてこのコマンドは繰り返せて、そのたびごとにリストの次
の構造体が見られる。でも、ぼくがこれまで見た C デバッガだと、毎回もっと長い
コマンドをタイプしなきゃなんないんだよね。そしてこの機能と、単に CR を押し
たら直前のコマンドを繰り返す、という機能と組み合わせると、これはすごく便
利。リストの中で自分が見たい要素について、どんどん CR を押してけばいい。

　あとデバッガの中で外部設定できる変数もある。いくらでも。ドル記号のあとに
名前をつければ、それで変数。こういう変数値をどんな C データ型にでもアサイン
して、あとで検討できる。これがなんの役にたつかというと、たとえば：もし調べ
たい値がなんかあったとして、それをたくさん参照するのがわかってたら、ヒスト
リーの中でその値を覚えとくより、名前をつけちゃったほうがいいかもしれない。
あるいは、条件ブレークをセットするときにも使えるかも。条件つきブレークは、
シンボリックデバッガにはよくある機能で、「プログラムのここまできたら止ま
れ、ただしこの条件式が真の場合だけね」と言うわけ。デバッガの変数は、プログ
ラム内の変数と、デバッガ変数内に保存した変数値とをくらべさせてくれる。これ
はほかにも、数えるのに使える。だって値の割付は要するにCの式でしょ、だから
$hoge を 5 増やすには $hoge+=5 でもいいし、あるいは単に $hoge++ でやっても
いい。これを条件付きブレークでもできるから、このブレークポイントに 10 回目
にきたらブレークとかするのにはお手軽でしょ、 $hoge--==0 をするんだよね。み
んな、ついてきてる？　hoge を減らしてって、それがゼロになってたらブレークし
ろってこと。そしてそれから $hoge を、スキップしたい回数にセットして、それで
行ける。これを配列の中の要素を見るのにも使える。たとえばポインタの配列があ
って、そしたらこんなことする：

     PRINT X[$hoge++]

でもその前にまずこれ：

     SET $hoge=0

　オッケー、で、こうしたら（と「Print」式をさす）、X のゼロ番目の要素が出て
くる。で、もう一回やったらそれは一番目の要素で、それでこれがもし構造体への
ポインタなら、たぶんここ（PRINT 式の X の前）にアステリスク（*）を入れて、
そしたら毎回これはこの配列の要素がさしてる次の構造体をだしてくる。そしても
ちろん、改行をおすだけでこれを繰り返せる。これ一つだけ繰り返すんじゃ不十分
なら、ユーザ定義コマンドをつくればいい。「Define むにゃむにゃ」とやって、そ
れからコマンドを何行か入れて、「end」とやる。これでもう「むにゃむにゃ」コマ
ンドが定義されて、それが入れた行を実行する。で、こういう定義をコマンドファ
イルに入れておくとすごく便利なの。ディレクトリごとにコマンドファイルを持っ
て、そこを作業ディレクトリにしてデバッガを起動すると、それが勝手にロードさ
れるようにしておける。だから各プログラムごとに、ユーザ定義コマンドをいろい
ろ定義しておいて、便利な形でそのプログラムのデータ構造にアクセスできるよう
にしとける。そういうユーザ定義コマンド用にドキュメンテーションだってつくれ
るんだよ。そうするともとからのコマンドとまったく同じように、「help」機能で
処理されるんだ。

　このデバッガでもう一つ珍しいのが、スタックからフレームを捨てられるってこ
と。デバッグしてるプログラムで何が起きてるか見られるだけじゃなくて、それを
好き放題変えられるってのが大事だと思うんだ。だから問題を一つ見つけて何がダ
メかわかったら、そのコードが正しかったかのようにあちこちなおしてから、コン
パイルしなおさなくても次のバグを見つけにいけるわけだよ。ということは、プロ
グラムのデータ領域を思い通りに直せるだけじゃなくて、コントロールのフローを
好きに変えられなきゃならない。このデバッガでは、こんなふうにしてコントロー
ルのフローをすごく直接的に変えられる：

     SET $PC=<なんか数字>

　こうやってプログラムカウンタを変えるの。それとスタックポインタもセットで
きるし、あるいはこういうふうにでも：

     SET $SP+=<なんとか>

　スタックポインタをちょっと増やしたいなと思うでしょ。でもついでに、プログ
ラムのどこか途中からはじめたいとして、だからプログラムカウンタをそのソース
行にあわせるよね。でもそれで、その関数を呼んだのがまちがいで、その関数呼び
たくなかった！　としたら？　たとえばその関数がどうしようもなくいかれてて、
実はそこから戻ってきて、その関数のやるべきだったことを手でやりたいとした
ら？　それには 「RETURN」 命令を使う。スタックフレームを選んで 「RETURN」と
やると、そのスタックフレームや、その中にあるやつ全部が捨てられて、その関数
からすぐに戻ってきたような感じになって、しかもそこから返ってくるはずの値も
指定できる。実行は続かないよ。返ってきたようなふりをして、そこでまたプログ
ラムを止めるから、ほかのものもどんどん変えられる。

　このくらいいろいろまとまってると、プログラムの中で何が起きてるか、かなり
細かくコントロールがきくわけよ。

　これに加えて、もう一つちょっとおもしろいこと。C にはストリング定数があっ
て、デバッガ内で計算してる数式にストリング定数を使ったらどうなるか？　デバ
ッグしてるプログラム内にストリングをつくらなきゃなんない。だからつくってく
れる。デバッグ中のプログラム内で MALLOC へのコールをやってくれて、MALLOC を
走らせて、それからコントロールを取り戻す。こうやって、知らないうちにストリ
ング定数を置く場所を見つけてくれるの。

　いずれこのデバッガが本物の GNU システム上で動くようになるときには、その下
で動いてる全プロセスの内部状態を調べられるような機能をつけるつもり。たとえ
ばメモリマップの状態を見ようとかね、どのページが存在して、どれが読めて、ど
れが書き込めるか見て、あと下部プログラムの終了状態（terminal status）を見る
とか。もうかなりコマンドはあるんだ。このデバッガは、UNIX のデバッガとはちが
って、終了状態をデバッガやデバッグ中のプログラムと完全に切り離してる。だか
らそのままのモード（raw mode）で動くプログラムも見られるし、割り込み駆動入
力をするプログラムでも動くし、それにデバッグ中のプログラムが実際に使ってる
ものの終了状態についても調べてくれるコマンドがある。一般にデバッガというの
は、下部プロセスで起こってることはすべてわかるようにすべきだと思うな。

3.4 gcc コンパイラ

　 GNU システムのうちすでに存在する主要部分は二つある。一つは新しい C コン
パイラ（訳注：もちろんこの時点ではまだ gcc という名前はなかった。）で、もう
一つは TRIX カーネルだ。

　新しい C コンパイラは、この春から今年いっぱい書いてたもの。ついに PASTEL
は捨てようと決めたんだ。この C コンパイラは PASTEL からのアイデアをもらって
て、アリゾナ大学ポータブル・オプチマイザからのアイデアももらってる。連中の
おもしろいアイデアは、いろんな種類のマシンを単純な命令の生成で扱うことで、
ターゲットのマシンが許せばそれをいくつか組み合わせて複雑な命令にするんだ。
これを総合的にやるために、命令が数学式の記法で書かれてる。たとえば ADD 命令
はこんな感じで書かれる：

     r[3]=r[2]+4

これはコンパイラ内部での命令の表現形。2 番レジスタの中身をとって、それに 4
を足して 3 番レジスタに入れろという命令。こういうふうにすれば、あらゆるマシ
ン用にあらゆる命令を表現できる。それでかれらは実際に、すべての命令をこの形
式で表現して、それを組み合わせる段階になったら、ある表現式をべつので置き換
えて、もっと複雑な式をつくって組み合わせて命令にするわけ。

　ときどき、最初の命令の結果がそれ以上使われるかどうかに応じて、割りつけ演
算子を 2 つ持つような組み合わせ命令をつくんなきゃならない。この値（と何かを
指さす）用に 1 つと、こっちの値（と何かを指さす）用に 1 つ、こっちは 2 番目
の命令からきた値と差し替えるのね。でもこの値を 1 回しか使わないなら、差し替
えたあとは捨てちゃえる。もうそれで計算する必要はないんだから。だから。途中
で入ってくる命令とかがこういう値を変えたりしないかとか、そういうのをちゃん
とチェックして、差し替えをきちんとやるのはなかなかややこしい。自動インクリ
メントや自動デクリメント・アドレッシングみたいなものをサポートするなら（ぼ
くはしてるけど）、値を保存するんじゃないような状況についてチェックするの
に、いろいろチェックもしなきゃならない。

　でもこういうの全部チェックしたら、差し替えた組み合わせ式をパターン・マッ
チャーに通して、それが選んだターゲットマシンで有効な命令を全部認識してくれ
る。それで認識されたら、その 2 つの命令を組み合わせ命令と置き換えて、そうで
なきゃそのままにする。そして連中の技法ってのは、データフローで関連づけた命
令 2 つ 3 つをこうやって組み合わせることなんだ。

　アリゾナコンパイラでは、いろんなものをこういう文字列で表現してて、だから
連中のコンパイラはとてつもなく遅い。最初はこのコンパイラをそのまま使ってち
ょっと変えるだけにしようかと思ったけれど、でもぼくの求めるスピードを出すに
は完全に書き換えるしかないのは明らかだったので、こういう式すべてにリスト構
造の記法を使うように書き直した。たとえばこういうの：

     (set (reg 2)      (+ (reg 2)    (int 4)))

　なんか LISP っぽいけど、でもこいつの意味はそんなに LISP してない。ここの
各シンボルは特別に認識されるものだから。こういうシンボルの集合が特別に定義
されていて、必要なのは全部そこにある。そしてそれぞれが特定の引数のパターン
を持ってる。たとえば：「reg」は必ず integer で、それはレジスタに番号がつい
てるからだけど、「+」は必ずサブの式を二つ持ってて、とかね。そしてそれぞれの
式にはデータ型があって、それが基本的に、それが固定か浮動か、バイト長はどん
だけか、なんてことを指示する。必要なら、ほかの物を扱えるように拡張すること
もできる。

　それでぼくが自動レジスタ割り当てをやる方法ってのは、ぼくが最初にコードを
生成するとき、組み合わせとかいろいろやるときだけど、レジスタに入りそうな変
数にはすべて、自称疑似レジスタ番号ってのを割り振って、これは 16 とかなんと
か、そのターゲットのマシンで実際のレジスタになるには大きすぎる番号からはじ
まる数字だ。だから本物のレジスタは 0 から 15 までとかなんとかに割り当てられ
てて、そのあとに疑似レジスタがくる。それで、コンパイラの最後のところで何を
やるかというと、ずっと見てって、疑似レジスタを本物のレジスタに変えてくん
だ。またもやここでコンフリクトグラフをつくって、どの疑似レジスタ同士が同じ
時点で生きてるかを見て、もちろんそれを本物のレジスタの同じところに入れるわ
けにはいかないので、だからなるべく疑似レジスタを固めてなるべく本物のレジス
タに入れるようにして、しかもその重要度に応じて並べるわけ。

　そして最後に、いろんな問題に対応してコードを訂正しなきゃならない。たとえ
ば本物のレジスタにおさまりきらない疑似レジスタがあって、それをかわりにスタ
ックのスロットに入れなきゃならないとする。一部のマシンだと、これが起きると
命令の一部は無効になっちゃうかもしれない。たとえば 68000 だと、レジスタの内
容をメモりに加算したり、メモリの内容をレジスタに加算したりはできるけれど、
メモリの内容同士の加算はできない。だから ADD 命令があって、68000 を相手にし
てて両方の値がメモリにおさまっちゃったら、この命令は無効になる。だから最後
のパスでは、ずっと見てって、必要に応じていろんなものをレジスタにコピーした
り、戻したりして、こういう問題を片づける。

　インデックスレジスタも問題になる。何かをインデックスにしてアドレスを決め
るとき、そのインデックス値がメモリに入ってたら、そのコードはほとんどの場合
役にたたなくなる。ただし、間接アドレッシングでそれができるマシンは別だけ
ど。インデックスレジスタに自動インクリメントとかかけてるときには、その値を
レジスタに入れて、命令をやって、インクリメントした値をほんとにあるべきメモ
リのスロットに戻してやらなきゃならないかもしれない。

　まだまだいろいろ小細工の余地はあって、ぼくもまだ十分に効率よくなるほどの
細工は実装しきってない。

　このコンパイラは、C のコードをとって、それを実質的にはCデータ型の注釈がつ
いた構文ツリーに変えるパーサーを持つことでいまは動いてる。それから次のパス
ではそのツリーをながめて、こんな（ LISP 状の）コードを生成する。それから最
適化パスがいくつかある。一つには、ジャンプからジャンプ、ジャンプへのジャン
プ、.+1 へのジャンプなんかを扱うもので、こんなのはみんなすぐに簡素化でき
る。それからよくある副次式の認識、さらに基本ブロック探し、それからデータフ
ロー分析をして、どの命令にどの値が使われて、その後まったく使われないのはど
れかがわかる。そしてそれぞれの命令を、それが使う値の生成場所とリンクさせ
て、だから疑似レジスタ R[28] を生成するある命令があって、別の命令があとで
R[28] を使って、それが R[28] を使う最初の場所だったら、二番目のやつが最初の
やつを戻って指すようにして、このポインタが、命令を組み合わせようとするとき
の制御に使われる。隣り合った命令を組み合わせるんじゃなくて、ある値を使う命
令と、それを生成する命令とを組み合わせるの。間にほかの命令がはさまっていて
も、ここでは関係なくて、単に介入してきたりしないかどうかチェックしなきゃな
らないだけ。それで組み合わせ機能が動的レジスタ割り当てをやって、そして最後
に、アセンブリコードにする部分がくる。

　アリゾナコンパイラでは、命令認識部分は LEX で生成されてた。マシン記述はた
だの LEX プログラムで、LEX はそれを C 関数にして、有効な命令を文字列として
認識する。ぼくがかわりにつけたのは、特別な専用デシジョン・ツリーで、まるで
LISP みたいなこの構文で書かれたマシン記述から生成される。そしてこの認識部分
は、コンパイラ内のいろんな部分のためのサブルーチンとして使われてる。

　いまんとこ、このコンパイラは PCC くらいの速度で走る。レジスタ割り当ての小
細工をするなといえば、目に見えて速くはなって、それだと PCC とレジスタの割り
当ては同じ。超小細工モードだと、PCC よりずっと上手にレジスタ割り当てをやっ
て、ぼくの見立てでは VAX だと VAX 用のどの C コンパイラよりもいいコードを生
成してくれるね。

　68000 だとコードはまだ理想的とはいえない。前段で、十分に先を見通してない
から、最高とはいえないようなことをしてる部分が見える。前段では選択の余地が
あって、だからそいつが一番いいと思うことをやるんだけれど、でも別のやりかた
をしてくれたら後段のほうが頭がいいから、もっといい処理をしてくれたはず。だ
けど前段は、後段がそんなことしてくれるとは知らないので、だからそういうので
もっと手を入れないと。

　ときどきこのせいで、レジスタが無用に解放されちゃう。だって、何かがメモリ
のほうにおさまって、それをレジスタにコピーしなきゃならなかったら、まずはそ
れをコピーするためのレジスタが必要になる。これはつまり、すでに割り当てたレ
ジスタを持ってきて、一時的な値をスタックのスロットに蹴り出すってことだ。も
ちろんそういうのがレジスタからメモリにいっちゃうと、さらにほかの命令が無効
になるかもしれなくて、だから何度も何度もチェックが必要になる。ときどきこい
つは、何かをレジスタにコピーしなきゃと思うんだけど、でもそんな必要がなかっ
たりして、すると必要以上のレジスタを解放しちゃって、使えるレジスタを使い切
らなかったりするんだ。

　（質問: 32000 用のコードジェネレータはありますか？）まだだけど、でも言っ
とくと、要るのはコードジェネレータじゃなくて、ただのマシンの記述だけね。そ
のマシンの命令が全部こんなふうに（LISP っぽい形式で）リストしてあればいい。
だから実際問題として、どの引数がレジスタに入れてとかどのレジスタにとかいう
制約条件の考え方を実装するところは別にして、これは 68000 には必要だけど VAX
では不要だった話なんだけど、でもそれを別にすれば、このコンパイラを VAX から
68000 に移植するのはほんの数日しかかからなかった。だから、すごく簡単に移植
できるんだ。

　コンパイラはいまはアセンブラ・コードを生成して、デバッグ情報を DBX の求め
る形式でも出せるし、GDB の特別な内部形式でも出せる。ぼくに言わせれば、この
コンパイラで手をいれなきゃいけないのは、あとたった 3 分野だけ。

   * 「プロファイリング」機能をつけなきゃならない。UNIX のコンパイラにある
     やつ。
   * レジスタ割り当てをもう少し賢くしないとダメ。出力にバカな代物が出てこな
     いようにする。
   * 最後に、いろんなバグがあるし、ちゃんと扱えてないものがある。自分自身は
     コンパイルはできてるんだけどね。

　これだけやるのに、まあ数ヶ月もあればってとこで、そしたらコンパイラをリリ
ースする。

3.5 TRIX カーネル

　システムの中ですでに存在する大きな部分がカーネル。(質問：休みは？) ああ、
うん、そういや休憩を忘れてたね。とりあえずカーネルの話だけ終わらせてよ。5
分ほどですむから。そしたら休憩にしよう。

　で、カーネルには TRIX （ぼくの知る限りでは、何の略でもないみたい）ってい
うシステムを使う予定（訳注：不詳。きいたことない。でも、すでにマルチサーバ
式の OS らしきものは構想されているのがわかる。なおここでは、この 1986 年の
時点でカーネルがまもなくできそうな雰囲気だが、実際に GNU のカーネルである
HURD がまがりなりにもリリースされたのは、1997 年になってからのことだっ
た。）。これは MIT の研究プロジェクトで開発されたもので、リモート・プロシー
ジャ・コールに基づいてる。だからプログラムはドメインと呼ばれてる。各ドメイ
ンはアドレス空間といろんな機能（capability）で、機能（capability）ってのは
まさに、ドメインを呼び出す能力なんだ。どのドメインもそれを呼び出す
「capability ports」（機能ポート）がつくれて、そしてシステムコールとほかの
ユーザドメインをコールするのとがまったく同じ。どっちをしてるのかすら区別で
きない。だからほかのユーザプログラムでデバイスを簡単に実装できる。ファイル
システムも、透過的にユーザプログラムで実装できる。さらにネットワークごしに
通信するのも透過的。ほかのドメインを直接呼んでるつもりでも、実はネットワー
クサーバのドメインを呼んでるかもしれない。コールで与えた情報をとって、それ
をネットワーク越しに別のサーバプログラムに渡して、それがこんどはあなたの話
そうとしてるドメインを呼び出す。でも、あなたとその相手のドメインには、そう
いう動きはまったく見えずに起こる。

　TRIX カーネルは動くし、ごく限られたかたちで UNIX と互換性もあるんだけれ
ど、でもまだまだだね。いまのところ、ディスク上では古くさい UNIX ファイルシ
ステムが使ってるのと同じ構造を使ったファイルシステムを持ってる。おかげでデ
バッグはやさしいよ。ファイルを UNIX でセットして、それを TRIX で走らせたり
できるから。でもこのファイルシステムは、ぼくが必要だと思う機能をぜんぜん持
ってない。

　どうしても追加するべきだと思う機能としては、バージョン番号、削除ファイル
の復活、ファイルがいつどこでテープにバックアップされたかの情報、ファイルの
詳細更新（atomic superseding of files）。UNIX でいいと思うのは、ファイルが
書き込まれているときには、いつでもどうなってるか見られるってことね。たとえ
ば「tail」を使ってどこまで進んだか見るとか、あれっていいよね。それでプログ
ラムが、ファイル書きかけで死んだりしたら、どこまで行ったかも見られる。こう
いうのっていいんだけど、でもこの書きかけの出力が、いずれ期待してた完全な出
力にまちがえられるようなことは、絶対にあってはならない。その前のバージョン
もちゃんと見られて、新しいバージョンが完全に正しくできるまでは、それを使お
うとする人みんなに使われるべきでしょ。ということはつまり、新しいバージョン
はファイルシステムの中で見えなきゃダメだけれど、でも名前は予定されてた名前
じゃいけないってことだ。作業が完了してはじめてリネームされるようにしない
と。これはまさに ITS がそうで、だけどここでは、各ユーザプログラムがそれを明
示的にやる必要があった。ユーザプログラムに UNIX と互換性を持たせるには、こ
れを目に見えない形でやる必要がある。

　バージョン番号を、いまの UNIX のユーザプログラムにフィットさせるための、
すごい小細工っぽい方式を考えてある。それでこれって、ファイル名をそのまま指
定してバージョン番号を略すと、ふつうの形で名前を指定するってこと。でもファ
イル名をはっきり指定したければ、たとえばはっきりどのバージョンを使いたいか
指定するとか、あるいはぜんぜんバージョンを使いたくなければ、ファイル名の最
後にピリオドをつける。だからもし「HOGE」っていうファイル名を与えたら、これ
はつまり「HOGE のバージョンを全部見て、最新のヤツをもっといで」という意味。
でも「HOGE.」といえば、「純粋に HOGE という名前だけのファイルを持っといで、
それ以外はいらないよ」ってこと。「HOGE.3.」ってのは「ずばり HOGE.3 って名前
のファイル」で、これはもちろん HOGE のバージョン3そのもの。出力では、単に
「HOGE」といったら、これはいずれ「HOGE」の新しいバージョンをつくるけれど、
でも「HOGE.」と指定すれば、純粋に「HOGE」という名前のファイルに書き込む。

　さて、細かいところを全部つめて、問題が残ってないかとか、UNIX がファイル名
にピリオドをつけたらいかれるかかなんとか、同じ行動をさせるようにするには、
いろいろまだハードルが残ってはいる。

　出力用に、名前がピリオドで終わるファイルを開いたら、その名前をすぐに開い
て、だから同じ UNIX の振る舞いが得られるようにしたい。書きかけの出力がその
まま見えるようになって、でもピリオドで終わらない名前に出力したら、閉じたと
きには新しいバージョンがあらわれて、しかもそれを明示的に閉じないと新しいバ
ージョンにならない。システムがクラッシュしたとかなんとかで、ジョブが死んだ
ためにファイルが閉じたら、それは名前が変わる。

　そしてこのアイデアは、「スター・マッチング」に結びつけられる。つまり、ピ
リオドで終わらない名前はバージョン番号のついてない名前とマッチするようにな
るってわけ。だからあるディレクトリにこんなファイルがあったとしよう：

     ho.1　　ho.2　　ge.8

　ここで「*」と言ったら、それは：

     ho　　ge

に相当する。名前をとって、バージョン番号をそこから除いて、それで区別がつく
ものを選ぶから。でも「*.」といえば、絶対名を全部とってきて、それにピリオド
をつけて、それに対してマッチしたのをさがす。だから存在する個別バージョンが
すべてあてはまる。同じようにして「*.c」と「*.c.」のちがいもわかるよね。こい
つ（最初の）は基本的にバージョンなしの「.c」ファイルすべてをさすんだけど、
こいつ（二番目）は全バージョンをさす……わけじゃないな、それだと「*.c.*.」
とやんなきゃいけないのか。まだ細かいところはつめきってないんだ。

　もう一つ、ユーザからは見えない機能でしかも確実に互換性があるのが、ファイ
ルシステムのフェイルセーフさってこと。つまり、全情報をディスクにちゃんとし
た順序で書けば、うまくそれができれば「停止」ボタンをいつ押しても、それでデ
ィスク上のファイルシステムがいかれるようなことは絶対ないふうにできる。これ
のやりかたはよく知られてる。なんでみんなそれを無視するのか、想像もつかない
よ。もう一つのアイデアは、さらに情報の冗長性をもたせる。これをやるかどうか
はよくわからないけど、でも各ファイルに名前を全部入れて、だからディスク上の
ディレクトリが壊れても、それをディスクのほかの中身から再構築することが可能
になるようにする方法について、ちょっと考えがあるんだ。

　あと、ファイルの任意の一部を細かく（atomically）更新できるようにするには
どうしたらいいか、ぼくはわかってるつもりだ。つまりファイルの一部分を新しい
データで更新して置き換えるときに、それだとファイルを読もうとすれば、見える
のは古いデータだけとか新しいデータだけとかね。できると思う。しかもファイル
をロックしたりとかもしなくてね、ぜんぜん。

　ネットワークのサポートとしては、いずれこのシステム用に TCP/IP を実装する
つもり。それと実質的に UUCP に相当するものとして、KERMIT がつかえると思う。

　シェルは確かもう書き上がってるはず。二つのモードがあって、一つは BOURNE
シェル風で、同じプログラムが別のモードでは C シェル風になる。まだこいつはぼ
くの手元には届いてないから、どのくらい手をかけなきゃなんないかもわかんない
や。それ以外にもたくさんユーティリティがある。MAKE はあるし、LS も、あと
BISON っていう YACC にかわるものもあって、配布されてる。LEX にかなり近いも
のもできてるんだけど、完全に互換性はないので、ちょっと作業が必要。そして全
体として、これからやんなきゃならないことは、もう済んだことよりはずっと少な
いんだけれど、でもまだまだたくさん手伝いがいるんだ。

　みんながしょっちゅうきくのが「いつになったら完成するの」ってこと。もちろ
んぼくだって、いつできんのかなんてわかりゃしないけど、これはぼくにすべき正
しい質問じゃない。もしその人がそれにお金を払う気なら、そりゃずばりどんなも
のをいつ手に入れられるか知りたがるのは当然だ。でも、お金を払うことにはなら
ないんだから、きみたちがきくべき正しい質問は「もっとはやく完成させるため
に、どんな手伝いをしたらいいですか」なんだ。プロジェクトのリストがあって、
MIT のファイルにおいてあるんだけど、手伝いたい人はこのインターネットアドレ
スにメールをくれれば、プロジェクトのリストを送ってあげる。（こいつ、うまく
動くかな（とチョークを見つめて言う）。これ、読める？ RMS@GNU.ORG だよ（カラ
オケ風に色が変わる通り）。で、ここでちょっと休憩といこうか。そして休憩が終
わったら、ぼくはすごい問題発言をいろいろするからね。いま帰っちゃだめだよ。
いま帰ったら、ホントの山場をみのがすからね。

　[ここで15分休憩]

  ------------------------------------------------------------------------

4 情報、ソフトと著作権

　 GNU ソフトの入手法を言っとくようにと言われた。で、一つの方法はもちろん、
もしそれを持ってる友だちがいたら、それをコピーすればいいけど、でもそういう
友だちがいなかったら、そしてインターネットにもつながってなかくて、だから
FTP も使えないなら、配布テープを注文してフリーソフトウェア財団（FSF）にお金
を送ってくれればいい。もちろん、フリーソフトは無料配布ってのとは別物なんだ
よ。この話はまたあとで詳しくやる。

　ここに取り出しましたるは EMACS のマニュアルだけど、きれいに印刷製本したや
つ。写真製版してオフセット印刷してある。EMACS の配布パッケージに入ってるソ
ースから自分で印刷してもいいし、こっちのやつを FSF から買ってくれてもいい。
あとでここにきて、こいつを見てみて、それとこれには注文書もあってあとでそれ
を写したりとか、あとこの（表紙の）絵もおもしろがってもらえたりする。こいつ
（と、絵の中でヌーにまたがったRMSに追いかけられてる人物を指さす）は、びびっ
てるソフト隠匿者。あとでこいつの話もしよう。

　ソフトウェアってのは比較的新しい現象だ。人がソフトを配布し出したのは、せ
いぜい 30 年前かな。だれかがそれを商売にしようと思いついたのは、たった 20
年ほど昔だ。人がどうするかについて、なんの前例もないし、だれが何の権利を持
ってるかもわからない世界だった。そして、アナロジーでほかの分野の伝統を持ち
込めたんだけど、その際のアイデアがいくつかあった。

　ヨーロッパの教授たちがお気に入りのアナロジーは、プログラムと数学とのアナ
ロジー。プログラムってのは一種の大きな数式みたいなもんだ。さて伝統的には、
だれも数式を所有したりはできない。だれでもそれを写して使える。

　一般の人にいちばん意味があるアナロジーは、料理のレシピだろう。考えてみれ
ば、日常生活でプログラムにいちばん近いものっていえばレシピなんだよ。ちがい
といえば、レシピは人が従うもので、機械が自動的にやることじゃないってこと。
確かにレシピにはソースコードとオブジェクトコードの差はないけれど、でもいち
ばん近いのは事実。そしてだれもレシピを所有することは認められていない。

　でも選ばれたアナロジーは、本とのアナロジーで、本には著作権がある。そし
て、なぜそれが選ばれたのか？　それは、この選択をすることでいちばん利益を被
る人が選択権を与えられたからだ。プログラムを使う人じゃなくて、書く人が決定
を認められて、そしてみんなはまったくの利己的な決断をくだして、おかげでプロ
グラミングの世界は醜いところに変わってしまった。

　ぼくがこの世界に入ってきたとき、1971 年に MIT で働きだしたとき、ぼくたち
の開発したプログラムが共有されないかもなんて考えは、議論すらされなかった。
そしてスタンフォードも CMU もみんな、DIGITAL でさえそうだった。当時の
DIGITAL からの OS は無料だった。それにぼくも、PDP-11 クロスアセンブラとかあ
れこれプログラムをもらうことがよくあって、それをポートして ITS で動くように
して、いろんな機能も加えた。そのプログラムには版権はなかったんだ。

　こいつが変わりはじめたのは、やっと 1970 年代後半に入ってからのことなんだ
よ。ぼくはぼくらの共有精神にはすごく感激した。ぼくたちは、願わくば役に立つ
ことをやっていて、人々がそれを使えれば幸せだった。だから最初の EMACS を開発
したとき、MIT の外の人がそれを使いたいな、と言い出したとき、ぼくはそれが
EMACS「コミューン」のものだ、だから EMACS を使うにはそのコミューンの一員じ
ゃなきゃだめで、それはつまり、自分が改良を加えたらそれを貢献する責任がある
んだという意味だよ、と言った。オリジナルの EMACS への改良はすべてぼくに送ら
なきゃならなかったんだ。そうすれば新しいバージョンの EMACS にそれを入れて、
コミュニティの全員がメリットを得られる。

　でも CMU で SCRIBE が開発されて、それが会社に売られたときに、これが破壊さ
れはじめた。これはいろんな大学のぼくたちみんなにとって大問題だった。みんな
の目の前に大きな誘惑がおかれて、協力をやめるのがすごく儲かるようになって、
協力を信じているぼくたちは、協力するように説得する材料がなにもなかった。は
っきりと、一人また一人と、寝返って社会との協力をやめて、ぼくたちの中ですご
く良心の強い人だけが協力を続けるだけになるだろう。そしてまさにそうなったわ
け。

　プログラミングの世界は醜いところになっちゃったよね。みんなシニカルで、同
じ分野の人たちやユーザに意地悪にしたらいくら儲かるかな、と考えてる。

　ぼくは、ソフトを所有するという慣行は物質的にも無駄が多く、精神面でも社会
的に有害で邪悪なものだと断言したい。この 3 つはすべて相互に関係しあってる。
なぜ精神的に有害かと言えば、それはコンピュータに触れるあらゆる社会人にかか
わるからで、その接触を明らかに他人に対して無駄の多い形でやらせる慣行だから
だ。そして自分だけの利益のために何かをして、しかもそれが自分の助かるよりも
他人に害を与えるほうが大きいことを知ってやるたびに、心の中でそんなことを正
当化するために、きみはシニカルになるしかない。そしてそれは、意図的に社会で
行われた作業を無駄にするものであり、社会の退廃を招いているがゆえに邪悪なん
だ。

　まず、ソフトウェアとか、その他一般的に役に立つ情報を所有しようとすること
で、どんな害が生じるかを説明しよう。それからその慣行を弁護するような議論に
反論して、この現象とどうやって闘えばいいか、そしてぼくがどうやって闘ってる
かを話そう。

4.1 ソフトの所有とその害

　情報の所有という考え方は、3つの異なるレベルで有害だ。3 つのレベルで物質的
に有害だし、それぞれの物質的な害は、対応する精神的な害を伴う。

　最初のレベルでは、それは単に、利用者がそのソフトを使うのをじゃまするんだ
けど、実は使う人が少なくてもプログラミングの作業が減るわけじゃない。プログ
ラムの利用にお値段がついたらこれはみんながプログラムを使わないインセンティ
ブ、というのはこの手のソフト隠匿者どもが大好きなことばなんだけど、使わない
インセンティブになって、これは無駄だ。たとえばあるプログラムにお値段がつい
て、だから使う人間の数が半減しちゃったら、プログラムの半分は無駄になったこ
とになる。同じだけの作業が、半分の富しかつくりださなかったんだから。

　さて実は、プログラムが使いたい人みんなに出回るようにするには、特別なこと
は何もしなくていい。みんなコピーくらい自分でちゃんとできるし、だからいずれ
はみんなの手に入る。プログラムを書いたら、あとはすわってて、みんなのしたい
ようにさせればいいの。でも、そうはならない。かわりにだれかが意図的にプログ
ラムの共有を妨害しようとする。そしてそれどころか、そいつが妨害しようとする
だけじゃなくて、ほかの人を手伝わせるよう圧力かける。ユーザが守秘契約にサイ
ンしたら、その人は要するにほかの仲間のユーザたちを売り渡したってことだ。黄
金律にしたがって「ぼくはこのソフトが好きだ、ぼくの隣人もこのソフトが気に入
るだろう、だから二人ともそれが持てるようにしよう」というかわりに、そいつは
こう言ってるんだ。「いいよ、おれにくれよ。隣人なんか地獄に堕ちろ！　おれも
そいつを隣人の手に入らないようにするのに手を貸すからさ、とにかくおれにく
れ！」　そしてこの精神が、精神的に有害なんだ。この「隣人なんか地獄に堕ち
ろ、このおれにコピーをよこせ」という態度が。

　守秘契約とかなんとかにサインしたからってんでぼくに何かのコピーをくれない
ような人に出くわしてから、ほかのだれかがぼくにその手のものにサインしろって
言ったときには、そんなのがまちがってるのはわかった。自分がやられてあんなに
腹がたったことを、このぼくが人にやれるわけないでしょ。

　でもこれは、害の中で最初のレベルにすぎない。第二のレベルは、人がプログラ
ムを変えたいときに生じる。だって、使いたい人みんなに完全にあったプログラム
なんてないもの。人は料理に手を加えるでしょ。塩を減らすとか、ちょっとピーマ
ンを入れるとかさ、同じように、プログラムだって自分のほしい効果を得るには手
直しがいるんだ。

　さて、ソフト所有者たちは、人がプログラムを変えようがどうしようが、実はぜ
んぜん気にしてないんだけれど、ただ連中の目的のためには、人にそんなことをさ
せないほうが都合がいい。ソフトが独占ソフトだと、ソースは手に入らないし、変
えられないし、おかげでプログラマにとってはすごく無駄な作業が増えて、ユーザ
もいらいらがつのる。たとえば、何ヶ月も銀行でプログラマやって、新しいプログ
ラムを書いてた友だちの話なんだけど、それにはほとんど大丈夫な市販ソフトがあ
ったんだけれど、でもかれらの求めるものそのものってわけじゃなくて、その差が
あるおかげで、その市販ソフトは使いものにならなかったんだ。そこの部分だけ変
える労力はほんのわずかですんだだろうね。でもそのプログラムのソースがなかっ
たから、それは不可能だった。彼女はゼロからはじめるしかなくて、だからたくさ
ん仕事を無駄にした。世界でこんな風に時間を無駄にしているプログラマが、どの
くらいいるのかは神のみぞ知る、だよね。

　それと、あるソフトがその場しのぎには使えるけれど、でもしっくりこないこと
がある。たとえば MIT にはじめてグラフィックプリンタがきたとき、ソフトは自分
で書いて、いろいろすてきな機能をつけたんだ。たとえば自分のジョブが印刷し終
わったらメッセージを送ってくれるとか、自分のジョブがキューに入ってる時に紙
切れになったら教えてくれるとか、ほかにもいろいろほしいような機能を入れた。
その後、もっとずっといいグラフックプリンタが入って、最初のレーザプリンタだ
ったんだけど、でもそのソフトは Xerox のもので、それは変えられなかった。で、
そういう機能とかも入れてくれないし、ぼくたちが足すこともできなかったし、だ
から「その場しのぎ」の代物で我慢しなきゃならなかった。自分たちには、それを
なおす意志もやる気も能力も十分にあることがわかってるのに、それが許されてな
いってのは、すごくいらだたしかったね。これって妨害工作だよ。

　それと、コンピュータを使ってるのに、コンピュータはわけわからん、仕組みが
わからんと言う人がたくさんいる。うん、そりゃわかりっこないよね。自分の使っ
てるソフトが読めないんだもん。プログラムの正しい書き方を学ぶ唯一の方法、そ
してプログラムがどう動いてるのかを知る唯一の方法は、ソースコードを読むこと
なんだもん。

　だから思うんだけど、コンピュータをただの道具としてしか考えない利用者って
のは、実はソースコードを秘密にしとく習慣のせいで生まれた、ニワトリか卵か式
の悪循環なのかもしれないよ。

　さてこの種の物質的害に伴う精神的な害は、自分さえよければという精神だ。人
が長時間コンピュータシステムを使ってると、そのコンピュータシステムの設定は
その人が住まう都市になる。ちょうど自分の家や家具の配置が、その中ですむぼく
たちの生活を規定するように、ぼくたちの使うコンピュータシステムもそうで、自
分たちにあうようにコンピュータシステムを変えられなければ、ぼくたちの生活は
実は他人に支配されてることになる。そしてこれに気がついた人は、ある意味でモ
ラルが低下するんだ。「こういうのを変えようとしても無駄だよ、ずっとこうやっ
てひどいままなんだから。不満をいうのさえ無駄だ。とにかく時間をつぎ込んで…
…これがすんだらぼくがどっかへ行こう、そしてもうこのことは考えないようにし
よう」　公徳心ってのもがあるのに物事の改善が許されないと、結果としてこの手
の精神、この手のやる気のなさが生じるんだ。

　第三のレベルの害は、ソフトウェア開発者自身の間のやりとり。あらゆる知識分
野は、人が他人の成果の上に積み上げられるときにいちばんはやく進歩する、でも
情報の所有権は、まさに他人がそうしないようにするためにつくられてる。もし人
が他人の成果に積み上げられたら、その所有権ははっきりしなくなって、だからみ
んな、その分野への新規参入がゼロからはじめるしかないように手を打って、おか
げでその分野の進歩が大幅に後れる。

　だからわかるでしょ。表計算ソフトが別々の会社からたくさん出てるけど、みん
なそれがそれまでどうやってきたのか見てみるという恩恵なしにやってる。そりゃ
確かに、最初に書かれた表計算ソフトは完璧じゃなかった。たぶん、一部のコンピ
ュータでしか動かなくて、なにかをするときにもいちばんいい方法ではやらなかっ
た。だから、それを部分的に書き換えたい人が出てくる理由はいろいろあったろ
う。でも、自分の改善したいところだけを書き直せばいいんだったら、作業量はず
っと少なくて済んだよね。システムのある部分をよくする方法は見えるかもしれな
いけれど、同じシステムの別の部分なんかぜんぜんマシにできないかもしれない。
いや、同じくらいのレベルに達するのだって、えらく苦労するかもしれない。自分
の好きなところをとって、自分がひらめいた部分だけをやりなおせたら、あらゆる
面で前より優れたシステムが手に入って、まったく新しいシステムを書くよりもず
っと作業は減る。そりゃシステムをゼロから書き直すといいこともあるのはみんな
知ってる。でもそれは、古いのをまず読んでからの話だ。

　だからプログラミング業界の人たちは、時間をたくさん無駄にする方法を編み出
したわけで、おかげで表面上は、本当に必要なのよりもずっとたくさんのプログラ
マが必要になったように見える。なぜプログラマ不足なんてことが言われるのか？
　知的所有権のおかげで、プログラマたちは自分のやる仕事の半分を無駄にするよ
うな仕組みにしちゃったからだよ。だからみんなが知的所有権システムを指さして
「ほら、こんなに雇用を生み出してる、産業がこんなにでかくなってるじゃない
か」なんて言うけど、それが証明してるのは、実はみんながお金と時間をたくさん
無駄にしてるってことなんだ。プログラマの生産性を上げる話をするときでも、高
度なツールがどうのこうのといえば、連中は喜ぶけど、でもプログラマのやってる
よけいなことを削ることで生産性をあげるって話になると、とたんに反対する。そ
うなったら雇われてるプログラマの数が減るからって。これってちょっと、分裂症
じみた議論だと思わない？

　そしてこのレベルの物質的害に対応する精神的な害は、科学的な協力精神に及ぼ
す害だ。これは昔はすごく強くて、戦争してる国同士の科学者ですら協力を続けて
た、自分たちがやってるのが戦争とは何にも関係なくて、人類の長期的なメリット
のためなんだってのがわかってたから。最近じゃみんな、もう人類の長期的なメリ
ットのことなんか気にもしない。

　プログラムの利用をじゃまするのがどんなことか理解するには、仮にここにサン
ドイッチがあって、食べられるけれど、食べてもなくならないとしよう。あなたが
食べて、別の人がその同じサンドイッチを食べて、何度でも食べて、それでも毎回
もとのと同じだけ栄養がある。

　それでやるべきいちばんいいこと、このサンドイッチを使って何をすべきかとい
えば、おなかのすいた人たちがいるところにそれを持ってくことだ。なるべく多く
の口にそれを与えて、なるべく多くの人の腹を満たすようにすることだ。このサン
ドイッチを食べることに、値段なんか絶対つけちゃいけない。値段をつけたら金が
なくて食べられない人が出てくるからで、そうしたらそれは無駄になる。

　プログラムってのはこのサンドイッチみたいなものなんだけれど、でももっとい
いもので、なぜかといえば同時にいろんなところにあって同時に食べられて、どん
どん別の人に使ってもらえるから。このサンドイッチがみんなをあらゆる場所で永
遠に食べてもらえるのに、だれかがそれを自分の所有物だと決めたせいで、それが
実現できないでいるんだ。

4.2 ソフト所有肯定論への反駁

　さて、プログラムを所有できると信じてる人たちは、ふつうはそれを正当化する
のに 2 つの議論を持ち出す。最初の議論は、「おれが書いたんだ、おれの魂の申し
子だ、わが心、わが魂がここにはこもってる。それを他人が奪い取るなんて？　ど
こまでいってもこいつはおれのもんだ、おれのおれのおれのぉっ！」というやつ。
でも不思議なことに、こういうこと言う人のほとんどは、そのソフトは勤め先の会
社のものだっていう合意書にサインしてるんだよね。

　だからこれって、簡単に自分をごまかして何かが重要だと思いこんでしまえるこ
との一つだと思う。同じくらい簡単に、そんなのぜんぜん大事じゃないと自分を説
得することもできるんだ。

　こういう人はこの論法を使って、人がこのプログラムを変えるやりかたまでコン
トロールする権利を要求するんだ。「だれにもわたしの芸術作品をめちゃくちゃに
させてなるものか」って。じゃあ、これからつくろうと思ってる料理を発明した人
が、それはその人の芸術作品だからってきみの料理の仕方をどうこうする権利があ
ったらどうなると思う？　塩を使わないようにしようと思っても、そいつは「ダメ
ダメ、わたしがこの料理を設計したんだから、これはこんだけ塩をいれなきゃダ
メ！」「でも、ぼくは医者に塩をとめられてるんですよ、どうしましょう？」

　明らかに、プログラムを使ってる人のほうが、その現場に近いんだ。プログラム
の利用はその人に直接はねかえってくるけど、それを書いた人には、一種のごく抽
象的な関係しかない。したがって、人々に自分自身のくらしをできる限り好きなよ
うにさせるという趣旨からして、そういうことを決めるのはそのユーザであるべき
なんだ。

　連中の二番目の議論は、経済的なものだ。「プログラムを書いても報酬が得られ
ないじゃないか」と言うわけで、ここには確かにホントの問題がちょっとはある。
でも連中のいうことのかなりの部分は混乱してる。そしてどこが混乱してるかって
いうと、「たくさんの人がプログラミングするようにしたいなら、ほかの手段で生
計をたてなくてもいいような仕組みをつくらなきゃ」というのと、その一方では
「いまのシステムじゃなきゃダメだ、プログラミングで金持ちにならなきゃ」とい
うのとでは、話がまるっきしちがうってこと。生きてけるだけの賃金を得るのと、
少なくとも最近のアメリカのプログラマがもらってるような給料をもらうってのと
では、話がぜんぜんちがう。みんながいつも言うのは「じゃあおれはどうやって喰
ってけばいいんだ？」ってことだけれど、実際には「こいつは食えるか」ってこと
じゃなくて「こいつは寿司（訳注：高くて高級なぜいたくな飯という意味）が食え
るか」ってことで、「雨つゆがしのげるか」ってことじゃなくてホントに言いたい
のは「高級マンションが買えるか」ってことなんだ。

　いまの方式は、最大限の儲けを得るためにソフト開発に投資しようと思った人の
選んだシステム。システム開発をサポートするための唯一の方法だからこうなって
るわけじゃないんだ。実は、ほんの 10 年とか 15 年とか前のごく最近までは、ソ
フト開発をほかの方法でサポートするのがあたりまえだったんだ。たとえば
DIGITAL の OS は 1970 年代初期までフリーだったけれど、フリーの OS っての
は、70 年代初期ですら、ちゃんと給料もらってる人が開発してたんだよ。役に立つ
プログラムの多くは大学で開発されてる。最近だとこういうプログラムは売られる
ことが多いけど、15 年前ならふつうはフリーで、それでもみんな給料がもらえてた
んだ。

　プログラムみたいなものだと、これは無限サンドイッチとか、道とかみたいなも
ので、一回はつくらなきゃダメだけど、一度つくったらもうそれを何回使おうが関
係なくて、使うのにコストもかかんないなら、使うのに値段なんかつけないほうが
一般的にいい。そして、いまでもぼくたちがつくって、作った人に金を払うような
そういうものってのはたくさんある。たとえばそこらの道がそうだよね。お金を払
わずに道を造ってくれる人を見つけるのは無理だ。道をつくるのはプログラミング
とちがってクリエイティブじゃないし、楽しくもない。でも、世の中にはたくさん
道があって、それに支払うだけの金も捻出されてる。そしてそのほうが、ずっとい
いよね。でもこういうことだってできる。「企業に道をつくらせて勝手に料金所を
つけさせて、街角を曲がるたびに通行料を支払うようにしよう。そしていい場所に
道を敷いた企業は儲かって、そうでないのは倒産するようにしよう」

　だれかが、何かを隠匿することで大金を儲ける方法を編み出すと、変なことが起
きる。それまでは、たぶんその分野にすごく情熱をもっていて、熱心に働く人たち
がたくさんいたんだ。唯一の問題は、その人たちはそもそも喰っていけるのか、と
いうことだけ。たとえば数学者を考えてみると、純粋数学者に支給されるお金より
も、純粋数学者志望者のほうがずっと多い。そして支払われたとしても、大した額
じゃないし、あまりいい暮らしもできない。ミュージシャンとなるともっとひど
い。時間の大半を費やしてミュージシャンになろうとしてる人が、平均的なミュー
ジシャンでどのくらい稼いでるかっていう統計を見たことがある。マサチューセッ
ツでは、確か州平均所得の半分以下だったんだよ。かつかつで暮らしてけるくらい
で、つらいよね。でも、そうしたがる人はたくさんいる。そこへ、何かをすること
ですごくたくさん稼げるようになったとしよう。するとそういう人たちは消えて、
みんなこう言うんだ。「そのくらい儲からなきゃ、だれもやりゃしないよ」

　そしてぼくは、これがプログラミングの分野でおこるのを見てきた。AI 研で働い
てて、大した給料もなかったのに仕事が大好きだった人たちが、いまでは年に 5 万
ドルはもらわなきゃとても働けないよ、なんて言う。どうしちゃったわけ？　人の
前に大金を儲ける可能性をぶら下げてやると、似たようなことをしてるほかの人た
ちが、そんだけの金を稼いでるのを見ると、みんな自分たちも同じくらい稼ぐべき
だという気になって、だから昔ながらのやりかたを続けようという人はだれもいな
い。そしてこれが起きちゃったら、人に大金を払うしか手がないんだと思いこむの
は簡単なんだけれど、でもそりゃちがう。もし大金を儲ける可能性がなかったら、
ちょっとのお金でもそれをやろうって人が出てくるだろう。特にそれがクリエイテ
ィブでおもしろいことなら。

4.3 ソフト隠匿との闘い

　AI 研のユニークな世界が破壊されるのを見てきて、ソフトを売るのがその核心な
んだってことも見てきたし、さらにはさっき説明したように、ああいう社会を手に
入れるにはフリーソフトが必要なんだってことも見てきた。でもそれからいろいろ
考えてみて、ソフト隠匿がいろんな形で社会全てを傷つけることに思い当たったん
だ。特に、人々に隣人を売り渡すよう圧力をかけて、それが社会の退廃を招いてる
ってことに。道で人が刺されてるのを見ても、黙ってようとするのと同じ精神だ
よ。そこらじゅうの企業がしょっちゅう示してるのがわかる、あの精神だよね。そ
して、ぼくは自分が道を選べるのがはっきりしてた。その世界の一部となって、自
分の送ってる人生について不幸に感じ続けるか、それともそれと闘うか。だからぼ
くは闘うことにした。ぼくはキャリアを捧げて、ソフト共有コミュニティの再建に
努めてきたし、一般にとって有用な情報を員臆するという現象を終わらせようと努
力してきた。そして GNU システムは、この目的達成のための手段なんだ。社会的な
目的のための、技術的な手段だ。 GNU システムによって、ぼくはソフト隠匿者ども
の脅しに対してユーザたちにワクチンをあげたいんだ。

　いま現在、この隠匿者どもは基本的に、人のコンピュータを粗大ゴミにしてしま
う力を持ってる。アメリカでは、だいたい 50 年くらい前に、マフィアとかでそう
いう連中がいた。店やバーに行って、特にもちろん違法なバーだよね。それでこう
言う。「ここらへんじゃあ、最近火事が多いですなあ。あんたんとこも、火事なん
かになったらいやだよねえ。おれたちなら、あんたを火事から守ってやれるんだ
よ、月に 1,000 ドル払ってくれるだけで、ここで火事が起きないようにしてやる
よ」これがいわゆる「保護恐喝」ってやつ。さていまはだれかがこう言う。「なか
なかいいコンピュータをお持ちですな、それでいろいろソフトも使ってらっしゃ
る。さて、そのソフトに消えてほしくなければ、警察に追われる身になりたくなけ
れば、わたしに 1,000 ドル払いなさい。そしたらこのプログラムをライセンス付き
で売ってあげよう」これが人呼んで「ソフト保護恐喝」。

　ホント、連中がなにやってるかといえば、ほかの人がやるべきことをしようとす
んのをじゃましてるだけじゃん。なのに、連中はわれわれに対しても自分自身に対
しても、自分たちがなにか有益な機能を果たしてるようなふりをしてみせてる。
で、ぼくの願いは、ソフトウェア・マフィアの連中がやってきて「そのプログラム
がコンピュータから消えてもいいのか？」と言ったら、利用者たちが「おまえなん
かもうこわくないぞ、ぼくにはこのフリーの GNU ソフトがあるんだ。もうおまえた
ちは手も足も出ないんだぞ」と言えることなんだ。

　さて、ソフト所有を正当化する議論として出てくるのが、みんなにものをつくる
インセンティブを与えるってやつだ。ぼくは私企業の考え方には一般的に賛成だ
し、ほかの人が喜んで使ってくれるものをつくってお金を得たいな、と思うのにも
賛成だけれど、ソフトの分野ではこれが収拾つかない状態になってきてる。独占ソ
フトをつくるのは、同じプログラムをつくってそれをフリーにするのとでは、社会
への貢献度がぜんぜんちがう。社会の富への貢献が起こるのは、そのプログラムが
使われたときだけなんだ。プログラムが使われるのを妨害したら、その貢献は起き
ないんだ。だから社会が必要としている貢献は、みんながえらくインセンティブを
もってつくってる独占ソフトではなくて、ぼくたちが本当に求めてる貢献はフリー
ソフトで、ぼくたちの社会が収拾つかなくなっているのは、それがあまり役にたた
ないことをするインセンティブを人に与えて、役に立つことをするインセンティブ
をぜんぜん与えてないからだ。だから私企業の基本的な考え方がここではおかしく
なっていて、だから社会自体が神経症気味とさえ言えるかもね。だってさ、個人が
他人に対して、その個人自身にとってよくない行動を推奨するとき、その人は神経
症なんだから。ここでは社会がそういうふうに行動してる。プログラマに、社会に
とってよくないことをするように奨励してるんだから。

　ぼくは変わり者なんだ。自分が社会のよき一員で、何かを社会に貢献していると
感じていたいんだよ、うまいこと社会をカモにしてるなんて感じるよりはね。だか
らぼくは、いまの自分の道を選んだ。でもだれでも、自分が実は役にたってないこ
とでお金をもらってるという気分は、多少なりともすっきりしないものを感じてる
んだ。だから、こんなまちがったことをするためのインセンティブなんて考え方を
擁護するのはやめて、みんなに正しいことを奨励するような仕組みを考えつく努力
くらいはしようではないの。その正しいことってのは、フリーソフトをつくること
なんだ。

　ご静聴どうも。

  ------------------------------------------------------------------------

5 質疑応答

[このあと、RMS は一時間ばかり質問に答えた。ここには質疑応答のほんの一部しか
入れていない。テープが悪かったし、そのすべてをまともに書き出す暇がなかった
ので、悪しからず]

Q：だれかあなたを訴えたりとか、面倒を起こそうとしたことはありますか？

A：そういうもめごとを唯一起こそうとしたのは、ゴスリング EMACS の持ち主、と
いうか自称持ち主、詐称持ち主どもだけだな。それをのぞけば、あやをつける手が
かりがないから、大して何もしようがないよね。ところで、あることを考えさせ
て、あることを考えなくさせるためにことばが使われてることに、みんなもっと注
意してほしいなと思うんだ。いまこの分野での用語は、自称詐称ソフトウェア所有
者たちが選んだもので、なるべくソフトウェアを、所有物になる物質的ものと同じ
物だと思わせて、そのちがいを見過ごすようにしてあるんだ。これのいちばん明白
な例が「海賊」ってことば。よき市民として隣人とソフトを共有しようとする人間
を表現するのに、「海賊」ということばを使うのは拒否してほしいんだ。

　話しそこねてたけど、著作権の考え方は印刷術の後に発明された。古代には、著
者はおたがい自由にコピーしあってたし、それがまちがってるとも思われなかった
し、すごい役にたったりもした。一部の著者が後世に伝えられたのは、断片的では
あっても、その一部がほかの著作の中でまとまって引用されてたおかげなんだ。

　これは、本というものが一部ずつ筆写するものだったからそうなった。10 部つく
るのは、1 部つくるのの 10 倍手間がかかった。そこへ印刷術が発明されて、だか
らといって人は本の筆写ができなくなったわけではないけれど、でも印刷するのに
比べたら、筆写はえらく面倒で、実質的に不可能といってよくなったわけね。

　本が大量生産でしかつくれなくなったら、著作権が意味を持つようになってき
て、そしてそれは読書大衆の自由を奪ったりもしなかった。印刷術を持っていない
一般大衆の一員である人は、どのみち本をコピーできなかったから、著作権ができ
たって、別に自由を失うわけじゃなかった。だから技術的な変化のために著作権が
発明されて、道徳的にも筋が通ってたわけ。いまはその反対の変化が起きてる。情
報の個別コピーがどんどんよくなってきてて、やがて技術が究極にまで進歩すれ
ば、どんな情報でもコピーできるようになるというのが見えてきた。 [テープを裏
返すので中断]

　だからぼくたちは、著作権なんか無意味だった古代世界と同じ状況に戻ってるん
だ。

　ぼくたちの所有物の概念を考えてみると、それは物質的なものからきている。物
質的なものは、ほぼ保存則にしたがう。うん、確かにチョークは半分に折れるか
ら、正確にはちがうし、すりへるし、消費もされる。でも基本的にこれは（と椅子
を指さす）、椅子一脚だ。指をパチンとならしてこれを二つにするわけにはいかな
い。これをもう一つ手に入れるには、最初のやつをつくったのと同じようにつくる
しかない。原材料がもっといるし、もっと労働もいるし、だからぼくたちの所有物
の考え方は、そういう事実にあてはまるよう、道徳的に納得がいくかたちで発展し
てきたんだ。

　だれでもコピーできる情報なら、話はちがってくる。だからそれにあてはまる道
徳的な態度もちがう。ぼくたちの道徳的な態度というのは、何かをしたら人がどれ
だけ助かるか、人がどれだけ害を被るか考えることで決まってくる。ものだと、こ
の椅子をとってくことはできるけど、これをコピーすることはできない。そしてき
みがこの椅子をもっていったら、それで何かが生まれるわけじゃないから、これは
まったく正当化できない。だれかが「おれはこの椅子一脚をつくる作業をしたんだ
し、こいつを持てるやつが一人しかいないんなら、それはおれだろう」と言ったと
したら、確かにみんな「うん、そりゃ筋が通ってる」と言うだろう。だれかが「お
れはこのディスクにビットを刻んだんだ、だからこいつおれから奪ったら承知しな
いぞ」と言ったら、うん、これも確かに筋が通ってる。そのディスクを一人しか持
てないんなら、じゃあそれはそのディスクの所有者でいいよ。

　でもだれかがやってきてこう言ったとする。「あんたのディスクはこわさない
よ、ただまったく同じものを魔法で作り出して、それを持ってくから、あんたはい
ままでどおりディスクを使えばいいんだよ」　そしたらこれは「ぼくは魔法の椅子
コピー機を持ってて、きみはいままで通り椅子を楽しんですわったりできて、いつ
でも手元においとけて、でもぼくもその椅子が使えるんだ」というのとおなじで、
これはいいことだ。

　つくんなくていいんなら、指をパチンと鳴らせば複製できるんなら、すばらしい
ことだ。でもこの技術の変化は、個別コピーを所有して個別コピーで金を儲けよう
とする人にはお気に召さない。連中の考えは、保存する物体にしか通用しない。だ
からなんとかプログラムを実体のある物質みたいにしようとする。ソフト屋にいっ
てプログラムを買うと、なんか本みたいなものについてくるでしょう。不思議じゃ
ない？　あれはみんなに、自分が買ってるのが物体なんだと思ってほしくて、本当
はデジタルのコピー可能なデータを手に入れたんだと気がつかないでほしいからな
の。

　コンピュータって結局のところ、万能マシンでしょ。たぶんみんな、ユニバーサ
ルチューリングマシンについては勉強してるよね。ほかのどんなマシンでも模倣で
きるマシンね。万能マシンがすばらしいのは、ほかのマシンを模倣できるだけじゃ
なくて、その指示をコピーして変えられるってことだ。これってまさに、物質では
できないことだ。そしてこれがまさに、ソフトウェア隠匿者どもがみんなにやらせ
るまいとしてることなんだ。万能マシンという技術変化のメリットは享受したがっ
てるくせに、一般社会にはそのメリットを手に入れさせたくないんだよ。

　基本的に連中は「物の時代」を温存しようとしてるんだけれど、でもそんな時代
はもう終わってる。だからぼくたちも、正しいとか間違ってるとかの考え方を、ぼ
くたちが住む世界の実状にあわせてシンクロさせるべきなんだ。

Q：つまり結局のところ、情報の所有権の問題なんですね。情報を所有することが正
しいような場合というのは、あるんでしょうか。どう思います？

A： 一般的な利用価値のない情報なら、あるいは個人的な情報なら、所有オッケー
だと思う。言い換えると、なにかのやりかたじゃなくて、それでどうするつもりか
という情報。他人にとっての価値が疑わしいもの、あなたからお金をむしり取るに
は使えても、それで何かを作り出したりはできないような情報。ぼくに言わせれ
ば、そういうものを秘密にして統制するのはまったく問題ない。でも創造に係わる
情報、人が使って楽しめる情報、そしてそれを持ってる人が多ければ多いほど、も
っと利用されて楽しまれるような情報、そういうのは必ずコピーを推奨すべきなん
だ。

  ------------------------------------------------------------------------

Go to GNU's home page.

FSF & GNU 関連の問い合わせや質問は gnu@gnu.org までどうぞ。 FSF への コンタ
クト方法。

このページに関する質問や問い合わせは YAMAGATA Hiroo (hiyori13@mailhost.net)
まで。

Copyright (C) 1987 Richard Stallman and Bjorn Remseth, (C) 1998 Yamagata
Hiroo

Permission is granted to make and distribute verbatim copies of this
transcript as long as the copyright and this permission notice appear.
　この日本語訳は書式とファイル形式以外の改変を加えずこの版権表示を残す限り
において自由に再配布が認められる。

[Valid HTML 4.0!]  Updated: 10 Jan 2000 hiroo

  ------------------------------------------------------------------------
