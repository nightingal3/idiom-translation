RMS lecture at KTH (Sweden), 30. October 1986.


概要

　1986 年 10 月 30 日に、リチャード・M・ストールマンがスウェーデンのストックホルム市にある王立工科大学で行った講演の講演録。第一部では、1970 年代のMIT AI 研におけるハッカー文化、商業主義によるその破壊と、それに対抗してハッカー文化を再興させるべくフリーソフトの GNU プロジェクト開始をストールマンが決意するまでの過程が述べられている。第二部では GNU EMACS をはじめとする GNUプロジェクトそのものについて、歴史的な解説とともに、内部での処理系に関する考え方の解説も含めて語られている。第三部では、ストールマンの情報著作権や所有権についての考え方をはじめ、 GNU プロジェクトや FSF の背後にある思想が述べられる。情報やソフトは社会効用からみても共有されるべきであり、それを妨げる著作権やソフト隠匿はまちがっている、と主張されている。

　なお、原文は切れ目のない講演録であり、章分けとその命名および概要の追加は訳者の判断でやった。
  ------------------------------------------------------------------------

目次

1 イントロ

2 GNU 前史：MIT AI 研

　　2.1 MIT AI 研のハッカー文化とその崩壊

　　2.2 ハッカー文化の再生を目指して

3 GNU プロジェクト

　　3.1 はじめの一歩

　　3.2 GNU EMACS

　　3.3 GDB デバッガ

　　3.4 gcc コンパイラ

　　3.5 TRIX カーネル

4 情報、ソフトと著作権

　　4.1 ソフトの所有とその害

　　4.2 ソフト所有肯定論への反駁

　　4.3 ソフト隠匿との闘い

5　質疑応答

  ------------------------------------------------------------------------

[コメント：これは 1986 年 10 月 30 日に、リチャード・M・ストールマンが、学生会「Datorforeningen Stacken」の招きでスウェーデンのストックホルム市にある王立工科大学で行った講演のテープ起こしに、ちょっと手を入れたものだ。
RMS (Richard M. Stallman) Lecture at KTH (Kungliga Tekniska H?gskolan (Royal Institute of Technology)) Stocholm Sweden.
Arranged by the student society ``Datorf?reningen Stacken'' 30. October 1986
[Note: This is a slightly edited transcript of the talk.

だから変な始まりかたや、口語では自然だけれど字にするとへんてこな語法も入ってる。
As such it contains false starts, as well as locutions that are natural in spoken English but look strange in print.

これを「もとの講演をゆがめることなく」文語にするにはどうすればいいか、よくわかんないのだ。]
It is not clear how to correct them to written English style without ' doing violence to the original speech'.]

（訳注：日本語にしちゃえば同じことだけど、講演としての性質を尊重して、ここではなるべくバリバリの口語文体を採用してる。文法的に不正確な日本語もたくさんあるけれど、原文の変なとこを残したせいで生じてる部分がほとんどだから、揚げ足をとらないよーに。）

  ------------------------------------------------------------------------

1. イントロ

みんながぼくに話してほしい話題は三つあるみたいだね。
It seems that there are three things that people would like me to talk about.

一つはまず、このハッカー集団に話すのにいちばんいいのは、昔の MIT ってのがどんなとこだったのかってことかな、と思った。
On the one hand I thought that the best thing to talk about here for a club of hackers, was what it was like at the MIT in the old days.

人工知能研究所のどこがそんなに特別だったのか。
What made the Artificial Intelligence Lab such a special place.

でも、今日きてる人は月曜と火曜に会議にきたのとぜんぜんちがう人だから、GNU プロジェクトがどうなってるかとか、ソフトウェアや情報がなぜ所有できないかとかについて話すべきだ、とも言われた。
But people tell me also that since these are totally different people from the ones who were at the conference Monday and Tuesday that I ought to talk about what's going on in the GNU project and that I should talk about why software and information can not be owned,

ということはつまり全部で三つの話ってことで、このうち 2 つがそれぞれ 1 時間かかったんだから、みんなかなり長時間ここにいることになるわけだ。
which means three talks in all, and since two of those subjects each took an hour it means we're in for a rather long time.

それで思ったんだけれど、全体を 3 つにわけて、みんな自分の興味がない部分は外に出られるようにして、それで各部分の終わりにきたら、終わりだって言うから、みんな外にでて、それでぼくはヤン・ライニングにお願いしてほかの人を呼んできてもらうようにするってのはどうだろう。
So I had the idea that perhaps I could split it in to three parts, and people could go outside for the parts they are not interested in, and that then when I come to the end of a part I can say it's the end and people can go out and I can send Jan Rynning out to bring in the other people.

（だれかが「Janne, han trenger ingen mike」 (「Janne、この人マイクなんかいらないよ」)と言う）
(Someone else says: ``Janne, han trenger ingen mike'' (translation: ``Janne, he doesn't need a mike'')).

ヤン、ひとっ走りして人を呼んできてもらってもいい？
Jan, are you prepared to go running out to fetch the other people?

Jmr: マイクを探してるんですけど、なんかこの鍵のかかった箱の中にあるっていうんですよ。
Jmr: I am looking for a microphone, and someone tells me it is inside this locked box.

Rms: うん、昔の AI 研でなら、でっかいハンマーを持ってきてそいつをぶち開けてただろうね。
Rms: Now in the old days at the AI lab we would have taken a sledgehammer and cracked it open,

その壊れたドアを見て、みんなが必要とするものを鍵かけてしまいこもうとするようなヤツも少しは勉強になったろう。
and the broken door would be a lesson to whoever had dared to lock up something that people needed to use.

でも運のいいことに、ぼくは昔ブルガリア歌唱法を勉強したことがあって、だからマイクなしでも全然問題ないよ。
Luckily however I used to study Bulgarian singing, so I have no trouble managing without a microphone.

とにかく、話がどの部分か知らせるシステムって要る？
Anyway, should I set up this system to notify you about the parts of the talk,

それともずっとすわって全部きいてたい？
or do You just like to sit through all of it?

（答：そうだそうだ)
(Answer: Yeaaah)

  ------------------------------------------------------------------------

2. GNU 前史：MIT AI 研

2.1 MIT AI 研のハッカー文化とその崩壊

ぼくがプログラミングをはじめたのは 1969 年のことで、ニューヨークの IBM 研究所でのことだった。
When I started programming, it was 1969, and I did it in an IBM laboratory in New York.

そのあと、コンピュータ科学の学部がある学校があって、まあここはほかと似たりよったり。
After that I went to a school with a computer science department that was probably like most of them.

何をすべきか決める教授たちがいて、だれが何を使っていいか決める連中がいて。
There were some professors that were in charge of what was supposed to be done, and there were people who decided who could use what.

ほとんどの人には端末が不足してたんだけれど、教授たちはほとんどみんなオフィスの中に専用端末を持ってて、これは資源の無駄なんだけれど、連中の姿勢からすればまあありがちなことだよね。
There was a shortage of terminals for most people, but a lot of the professors had terminals of their own in their offices, which was wasteful, but typical of their attitude.

MIT の人工知能研に遊びにいったら、そういうのとは爽快なくらいにちがった精神があったんだ。
When I visited the Artificial Intelligence lab at MIT I found a spirit that was refreshingly different from that.

たとえば、そこでの端末はみんなのものだと思われてた。
For example: there, the terminals was thought of as belonging to everyone,

だから自分のオフィスに鍵をかけるような教授は、ドアがぶち破られるというつらい目にあうわけ。
and professors locked them up in their offices on pain of finding their doors broken down.

ある教授のオフィスのドアをぶち破るのに使った、でっかい鉄のかたまりが載った台車をホントにみせてもらったよ。
I was actually shown a cart with a big block of iron on it, that had been used to break down the door of one professors office, when he had the gall to lock up a terminal.

その頃は端末はほんとに少なくて、システム全部にディスプレイ端末 5 つくらいかな、だからそのうち 1 台がしまい込まれてると、ものすごい損害だったわけ。
There were very few terminals in those days, there was probably something like five display terminals for the system, so if one of them was locked up, it was a considerable disaster.　

その後の数年、ぼくはその考え方に刺激を受けて、何度も天井をのりこえたり床下を這ったりして、みんなが使いたいマシンのある部屋の鍵を開けてきた。
In the years that followed I was inspired by that ideas, and many times I would climb over ceilings or underneath floors to unlock rooms that had machines in them that people needed to use,

そして通常は、ドアに鍵をかけるような身勝手なまねはしなさんな、というメモをおいてった。
and I would usually leave behind a note explaining to the people that they shouldn't be so selfish as to lock the door.

ドアに鍵をかけるような人は、基本的には自分のことしか考えてないんだ。
The people who locked the door were basically considering only themselves.

もちろんその人たちにもそれなりの理由はあるだろう。
They had a reason of course,

何か盗まれそうなものがあってそれに鍵をかけときたいとか。
there was something they thought might get stolen and they wanted to lock it up,

でも同じ部屋にある別のものがしまいこまれちゃうと、ほかの人に影響が出るってことは気にもしなかったんだ。
but they didn't care about the other people they were affecting by locking up other things in the same room.

これが起きる度に必ずいえることだけど、それで一回はぼくも指摘したんだけど、別の解決策はあるんだ。鍵をかけるかどうかってのはかれらの勝手じゃないんだ。
Almost every time this happened, once I brought it to their attention, that it was not up to them alone whether that room should be locked, they were able to find a compromise solution:

心配なものをしまっとく場所はほかにもあるし、デスクに鍵をかけることだってできる。
some other place to put the things they were worried about, a desk they could lock, another little room.

でも要するに、みんなそんなことをわざわざ考えようとはしないんだよね。
But the point is that people usually don't bother to think about that.

「この部屋はおれのだ、鍵をかけるのもおれの勝手、ほかの連中クソ食らえ」と思ってる。
They have the idea: ``This room is Mine, I can lock it, to hell with everyone else'',

そしてこれぞまさに、持ってはいけない精神なんだってことは教え込む必要がある。
and that is exactly the spirit that we must teach them not to have.

でも、この鍵をかけない精神は、孤立したものじゃなくて、生き様全体の一部だったんだ。
But this spirit of unlocking doors wasn't an isolated thing, it was part of an entire way of life.

AI 研のハッカーたちはいいプログラム、おもしろいプログラムをかくことにすごく熱心だった。
The hackers at the AI lab were really enthusiastic about writing good programs, and interesting programs.

そしてもっともっと作業したくてたまんなかったので、端末に鍵がかかってるなんて黙ってられなかったんだ。
And it was because they were so eager to get more work done, that they wouldn't put up with having the terminals locked up,

あるいはその他、役に立つ仕事をじゃましようとして人がやるいろんなこととかも。
or lots of other things that people could do to obstruct useful work.

そのちがいってのは、高いモラルをもってて、自分が何をしようとしてるのか本当に気にかけてる人と、ただの仕事でやってる人との差だ。
The differences between people with high morale who really care about what they're trying to do, and people who think of it as just a job.

ただの仕事なら、雇い主が馬鹿で、こっちがずっと何もしないですわってなきゃなんなくたって、だれが気にするもんか。
If it's just a job, who cares if the people who hired you are so stupid they make you sit and wait,

連中の時間だし、連中の金だし。
it's their time, their money

でもそんなとこでは、大した仕事はできないし、そんなとこにいたっておもしろくもなんともない。
but not much gets done in a place like that, and it's no fun to be in a place like that.

あと、AI 研になかったものといえば、ファイル保護。
Another thing that we didn't have at the AI lab was file protection.

コンピュータにはセキュリティはまったくなかった。
There was no security at all on the computer.

そしてこれはきわめて意識的に選んだ道だった。
And we very consciously wanted it that way.

Incompatible Timesharing System (ITS) を書いたハッカーたちは、ファイル保護なんてものは身勝手なシステム管理者が、ほかのみんなに対して権力を行使するのに使うもんだって思ってた。
The hackers who wrote the Incompatible Timesharing System decided that file protection was usually used by a self-styled system manager to get power over everyone else.

ハッカーたちは、そんな権力を行使されるのはまっぴらだったから、その手の機能は実装しなかった。
They didn't want anyone to be able to get power over them that way, so they didn't implement that kind of a feature.

結果として、システムのどこかがこわれたら、いつも自分でなおせた。
The result was, that whenever something in the system was broken, you could always fix it.

いらいらしながらじっとすわってなきゃならないなんてことは絶対許せないよね、こっちはどこがおかしいかずばりわかってて、それなのにだれかが、自分を信用してないからそれをさせないと決めてるなんて。
You never had to sit there in frustration because there was NO WAY, because you knew exactly what's wrong, and somebody had decided they didn't trust you to do it.

あきらめて家に帰って、朝にだれかがきてシステムをなおしてくれるのを待つなんて、しなくていいじゃない。
You don't have to give up and go home, waiting for someone to come in in the morning and fix the system

何をしなきゃいけないのか、自分にはその人の10倍もよくわかってるってのに。
when you know ten times as well as he does what needs to be done.

あと、どんな作業をやるのかについても、教授だの上司だのには決めさせなかった。
And we didn't let any professors or bosses decide what work was going to be done either,

だってぼくたちの仕事はシステムの改善だったんだもん！
because our job was to improve the system!

もちろん利用者とは話をした。
We talked to the users of course;

だってそうしないと何が必要かわからないからね。
if you don't do that you can't tell what's needed.

でもそれがすんだら、どんな改善が実現可能かいちばんよく判断できるのはぼくたちだったんだ。
But after doing that, we were the ones best able to see what kind of improvements were feasible,

そしてぼくちはいつも、システムをこう変えたらいいだろうな、とかほかのシステムで、こんないかしたアイデアを見たよ、とか、それを使えないものかな、とか話してた。
and we were always talking to each other about how we'd like to see the system changed, and what sort of neat ideas we'd seen in other systems and might be able to use.

だから結果として、そこにはなめらかに機能するアナーキーがあった。
So the result is that we had a smoothly functioning anarchy,

そしてそこでの自分の経験から、ぼくはそれこそ人が生きる最高のやりかただと確信してる。
and after my experience there, I'm convinced that that is the best way for people to live.

残念ながら、そういう形の AI 研は破壊されちゃったんだ。
Unfortunately the AI lab in that form was destroyed.

何年ものあいだ、AI研は MIT の別の研究所、コンピュータ科学研に破壊されるんじゃないか、というのがぼくたちのおそれていたことだった。
For many years we were afraid the AI lab would be destroyed by another lab at MIT, the Lab for Computer Science,

そこの所長は一種の帝国建設者タイプで、自分の組織をでかくして MIT の中で昇進するためならなんでもやるような人間で、いつも AI 研を自分の研究所に吸収しようとしてたんだ。
whose director was a sort of empire builder type, doing everything he could to get himself promoted within MIT, and make his organization bigger, and he kept trying to cause the AI lab to be made a part of his lab,

だれもそいつの流儀でなんか作業したくなかった。
and nobody wanted to do things his way

そいつは、人は指示に従うべきだとかなんとか、その手のことを信じてたからね。
because he believed that people should obey orders and things like that.

でもその危険に対してはなんとか防衛できたのに、まったく予想してなかったものによってぼくたちは破壊されてしまった。
But that danger we managed to defend against, only to be destroyed by something we had never anticipated,

それが商業主義だった。
and that was commercialism.

1980 年代初期になって、ハッカーたちがハッと気がつくと、自分たちのやっていることには商売上の関心がもたれていたわけ。
Around the early 80's the hackers suddenly found that there was now commercial interest in what they were doing.

民間企業で働いて金持ちになることが可能になったんだ。
It was possible to get rich by working at a private company.

必要なのは、自分の仕事をほかの世界と共有するのをやめて、MIT AI 研をぶちこわせばいいだけ。
All that was necessary was to stop sharing their work with the rest of the world and destroy the MIT-AI lab,

そしてぼくは手を尽くしてそれを止めようとしたけど、でもみんなそれをやっちゃったんだ。
and this is what they did despite all the efforts I could make to prevent them.

要するに、AI 研にいたぼく以外の有能なプログラマは、みんな雇われてやめちゃって、おかげでそれは一時的な変化じゃすまなくなってた。
Essentially all the competent programmers except for me, at the AI lab were hired away, and this caused more than a momentary change,

永続的な変化が生じた。
it caused a permanent transformation

ハッカー文化の連続性がとぎれちゃったんだよ。
because it broke the continuity of the culture of hackers.

新人ハッカーはいつだって古参ハッカーに惹かれる。
New hackers were always attracted by the old hackers;

だっていちばんおもしろいコンピュータがあって、いちばんおもしろいことしてる人たちがいて、そして参加したら最高におもしろいスピリットもあったんだから。
there were the most fun computers and the people doing the most interesting things, and also a spirit which was a great deal of fun to be part of.

それがなくなったら、そこを新人に推薦するべき理由もなくなっちゃって、だから新人もこなくなった。
Once these things were gone, there is nothing to recommend the place to anyone new, so new people stopped arriving.

ひらめきを受けるような人もないし、伝統を学べる人もいないし。
There was no-one they could be inspired by, no-one that they could learn those traditions from.

ついでに、いいプログラミングを学ぶ人もいない。
In addition no-one to learn how to do good programming from.

いるのは、使えるプログラムを書く方法なんか実は知らない教授や院生がうじゃうじゃいるだけだから、使えるプログラムの書き方なんか習えるわけがない。
With just a bunch of professors and graduate students, who really don't know how to make a program work, you can't learn to make good programs work.

だからぼくの愛した MIT AI 研はもうなくなった。
So the MIT AI lab that I loved is gone.

そして何年か、それをやった人たちと闘って連中に罰を与えようとしてから、ぼくはその精神をもった新しいコミュニティづくりに精を出そうと決めたんだ。
and after a couple of years of fighting against the people who did it to try to punish them for it I decided that I should dedicate my self to try to create a new community with that spirit.

でも、直面せざるを得なかった問題の一つが、独占ソフト（proprietary software）の問題だった。
But one of the problems I had to face was the problem of proprietary software (18k characters).

たとえばハッカーたちが去ってから研究所で起こったことの一つは、ぼくたちが開発したマシンやソフトがもうメンテされないってことだった。
For example one thing that happened at the lab, after the hackers left, was that the machines and the software that we had developed could no longer be maintained.

ソフトはもちろん動いたし、だれもそれを変えなければずっと動いてたけど、でもマシンはそうはいかない。
The software of course worked, and it continued to work if nobody changed it, but the machines did not.

マシンは壊れるし、だれもなおせるやつがいないから、やがて捨てられる。
The machines would break and there would be no-one who could fix them and eventually they would be thrown out.

昔は、ええ確かに保守契約なんてものはあったけど、でもまあ悪い冗談みたいなもんだった。
In the old days, yes we had service contracts for the machines, but it was essentially a joke.

それって単に、AI 研のエキスパート・ハッカーたちが問題を解決してから、パーツを入手するための手段でしかなかった。
That was a way of getting parts after the expert hackers from the AI lab fixed the problem.

だって修理担当者になおさせたら、何日かかるやらわかんなくて、そんなのやってられないよね、すぐ動くようにしてくれないと。
Because if you let the field-service person fix it it would take them days, and you didn't want to do that, you wanted it to work.

だから、やりかたのわかってる人間がだまって行ってさっさとなおして、それでそいつらはどんな修理担当者より 10倍も有能だったから、ずっとましな仕事をしたんだ。
So, the people who knew how to do those things would just go and fix it quickly, and since they were ten times as competent as any field service person, they could do a much better job.

それでそうすると、こわれた基板とかが出るから、それをそこにおいといて、修理担当者には「こいつを持って帰って、新しいのをちょっともってきてくださいね」と言うわけ。
And then they would have the ruined boards, they would just leave them there and tell the field service person ``take these back and bring us some new ones''.

すごい昔の頃だと、ハッカーたちは Digital からきたマシンのほうも変更した。
In the real old days our hackers used to modify the machines that came from Digital also.

たとえば、PDP-10 のてっぺんにのせる呼び出し用ボックスもつくったんだよ。
For example, they built paging-boxes to put on the PDP-10's.

最近だと、ここ（ストックホルム）でもそういうことをする人はいると思うけど、当時はかなり異例なことだった。
Nowadays I think there are some people here [in Stocholm] who do such things too, but it was a pretty unusual thing in those days.

それにうーんと昔、1960 年代初めとかだと、みんなコンピュータを変更して、いろんな新しい命令を足したり、すっごい TSS 機能を足したりして、だから MIT の PDP-1 は、引退する頃には 60 年代はじめに Digital が届けたときの 2 倍くらいの命令を持ってたし、特別なハードウェア・スケジューラ補助機能や変なメモリマッピング機能なんかもあって、個別ハード装置を特定のTSS ジョブに割り当てたり、その他ぼくでもほとんど知らないようないろんなことになってた。
And the really old days, the beginning of the 1960's people used to modify computers adding all sorts of new instructions and new fancy timesharing features, so that the PDP-1 at MIT by the time it was retired in the mid-seventies had something like twice as many instructions as it had when it was delivered by Digital in the early sixties, and it had special hardware scheduler assisting features and strange memory-mapping features making it possible to assign individual hardware devices to particular timesharing jobs and lots of things that I hardly really know about.

それと確か、一種の拡張アドレッシングモードも組み込んで、インデックスレジスタ修飾とか間接修飾とか追加して、要するに軟弱なマシンだったのをそこそこ使えるものにまで仕立てたんだ。
I think they also built in some kind of extended addressing modes they added index registers and indirect addressing, and they turned it essentially from a weak machine into a semi-reasonable one.

VLSI の欠点の一つは、もうマシンの命令を追加したりできなくなっちゃったことだろうね。
I guess it is one of the disadvantages of VLSI that it's no longer so feasible to add instructions to your machines.

PDP-1 にはまたすごくおもしろい特徴があって、おもしろいプログラムをほんの数命令で書けちゃうってこと。
The PDP-1 also had a very interesting feature, which is that it was possible to interesting programs in very few instructions.

それ以降のどんなマシンよりも少ない命令数でね。
Fewer that any other machine since then.

確かたとえば有名なディスプレイのハック「マンチング・スクウェア」ってのがあって、四角がどんどんでかくなって、それがたくさんの小さい四角に分裂して、それがまた大きくなってそれがまた小さいのに分裂するんだけど。
I believe for example that the famous display hack ``munching squares'' which made squares that get bigger and break up into lots of smaller squares which gets bigger and break up into smaller squares.

これって PDP-1 ではなんか 5 命令くらいで書かれてた。
That was written in something like five instructions on the pdp-1.

それとかいろんな美しいディスプレイプログラムが、ほんの数命令で書ける。
And many other beautiful display programs could be written in few instructions.

というわけで、これが AI 研の様子だった。
So, that was the AI lab.

でもハッカーたちの文化は、アナキズム以外にはどんなものだったのか？
But what was the culture of hackers like aside from their anarchism?

PDP-1 の頃には、マシンは一度に 1 人のユーザしか使えなかった。
In the days of the PDP-1 only one person could use the machine,

少なくとも最初はね。
at the beginning at least.

何年かして TSS を書いて、それ用にたくさんハードを追加した。
Several years later they wrote a timesharing system, and they added lots of hardware for it.

でも初めの頃は、時間枠を予約しなきゃならなかった。
But in the beginning you just had to sign up for some time.

さてもちろん、公式プロジェクトの仕事をしてる教授や学生は、いつも昼間にやってくる。
Now of course the professors and the students working on official projects would always come in during the day.

だから時間がたくさんほしい人たちは、競争の少ない夜を予約する。
So, the people who wanted to get lots of time would sign up for time at night when there were less competition,

これでハッカーたちは夜に働く習慣ができた。
and this created the custom of hackers working at night.

TSS が入ってからも、ユーザが少なかったから夜のほうが時間をとりやすい、CPU サイクルは夜のほうが使えたわけ。
Even when there was timesharing it would still be easier to get time, you could get more cycles at night, because there were fewer users.

だから作業をいっぱいしたい人は、相変わらず夜にやってきた。
So people who wanted to get lots of work done, would still come in at night.

でもその頃になると、それだけじゃなくなってて、それは自分がもう 1 人じゃなくて、ほかにも何人かハッカーたちがいたからで、だから社会的な現象になったのね。
But by then it began to be something else because you weren't alone, there were a few other hackers there too, and so it became a social phenomenon.

昼間にきたら、たぶんいるのは教授や学生とか、マシンをほんとは愛してない連中だけど、夜ならばそこにはハッカーがいる。
During the daytime if you came in, you could expect to find professors and students who didn't really love the machine, whereas if during the night you came in you would find hackers.

だからハッカーたちは、自分の文化に加わるために夜にやってきた。
Therefore hackers came in at night to be with their culture.

そしてハッカーたちはほかの伝統も開始した。
And they developed other traditions

朝の 3 時にテイクアウトの中華料理を買ってくるとか。
such as getting Chinese food at three in the morning.

だからぼくは、チャイナタウンから戻ってくる車の中から見た日の出がいくつも記憶に残っている。
And I remember many sunrises seen from a car coming back from Chinatown.

日の出を見るってのは、すごく美しいもので、だって一日の中ですごく穏やかな時間だからね。
It was actually a very beautiful thing to see a sunrise, cause' that's such a calm time of day.

寝る準備をするにはすばらしい時間帯だ。
It's a wonderful time of day to get ready to go to bed.

ちょうど空が白んできて、鳥が鳴き出す頃に家に歩いてくと、穏やかな満足感が実感としてあるんだ、その晩にやった仕事に対する静謐な気持ちってのが。
It's so nice to walk home with the light just brightening and the birds starting to chirp, you can get a real feeling of gentle satisfaction, of tranquility about the work that you have done that night.

ほかにもぼくたちのはじめた伝統は、研究室に泊まること。
Another tradition that we began was that of having places to sleep at the lab.

ぼくがはじめてそこに行ったときから、研究室には少なくとも一つベッドがあった。
Ever since I first was there, there was always at least one bed at the lab.

そしてぼくは、ほかの人よりちょっとばかし研究室で暮らす期間が長かった。
And I may have done a little bit more living at the lab than most people

1 年か 2 年おきくらいに、あれやこれやでアパートがなくて、だから研究所で数ヶ月暮らしたりしたんだ。
because every year of two for some reason or other I'd have no apartment and I would spend a few months living at the lab.

いつでもすごく快適で、しかも夏にはすごくすずしくていいんだ。
And I've always found it very comfortable, as well as nice and cool in the summer.

でも、研究所で寝ちゃう人を見かけるのはぜんぜんしょっちゅうで、これもまた熱意のせいだよね。
But it was not at all uncommon to find people falling asleep at the lab, again because of their enthusiasm;

とにかく手をとめたくないからできるだけながいこと起きててハッキングする。
you stay up as long as you possibly can hacking, because you just don't want to stop.

そして完全に疲れきったら、最寄りのやわらかい水平面によじのぼる。
And then when you're completely exhausted, you climb over to the nearest soft horizontal surface.

すごく形式張らない雰囲気。
A very informal atmosphere.

でもハッカーたちがみんな研究所を離れたら、これは人口構成の変化を招いた。
But when the hackers all left the lab this caused a demographic change,

マシンをほんとは愛してない教授や学生どもは、昔と同じにうじゃうじゃいたから、連中がいまや強い勢力になったわけで、みんな怖がってた。
because the professors and the students who didn't really love the machine were just as numerous as before, so they were now the dominant party, and they were very scared.

システム管理をしてくれるハッカーがいなくなったので、連中はこう言ったんだ。
Without hackers to maintain the system, they said,

「このままじゃ大変なことになる、商業ソフトを入れなきゃ」
``we're going to have a disaster, we must have commercial software'',

そして「そしたらメーカーがメンテもしてくれるよ」だって。
and they said ``we can expect the company to maintain it''.

やがて連中がまったくまちがってたことが証明されたけど、でも連中はそれをやったんだ。
It proved that they were utterly wrong, but that's what they did.



2.2 ハッカー文化の再生をめざして

まさにその時に、新しい KL-10 システムがくるはずになってて、そこでの問題は、それで Incompatible Timesharing System を動かすか、Digital の Twenex システムを動かすかってことだった。
That was exactly when a new KL-10 system was supposed to arrive, and the question was, would it run the Incompatible Timesharing System or would it run digital's Twenex system.

ハッカーたちはたぶん ITS を使うのを支持したろうけど、それがいなくなってたから、学者タイプの連中は商業ソフトを使う選択をして、これはすぐに目に見えて影響が出てきた。
Once the hackers were gone who probably would have supported using ITS, the academic types chose to run the commercial software, and this had several immediate effects.

なかにはそんなすぐには出てこなかったものもあったけど、でもこの問題を考えてみた人ならわかるように、遅かれ早かれ出てきたんだ。
Some of them weren't actually so immediate but they followed inevitably as anyone who thought about it would see.

一つには、そのソフトはずっと質が悪くて、わかりにくくて、だから本当に必要な変更をするのがむずかしかったってこと。
One thing was that that software was much more poorly written, and harder to understand; therefore making it harder for people to make the changes that were in fact needed.

もう一つの影響は、このソフトにはセキュリティがあって、おかげでみんながお互いに協力する機会はどうしても減ってきた。
Another was, that that software came with security, which had the inevitable effect of causing people to cooperate with each other less.

ITS の時代には、だれもがどんなファイルでも見て変えられるってのはいいことだと考えられてた。
In the old days on ITS it was considered desirable that everyone could look at any file, change any file,

それなりの理由があったからね。
because we had reasons to.

それで思い出したけど、だれかが Macsyma の使い方について助けてくれって言ってきたときに、おもしろいスキャンダルがもちあがったんだ。
I remember one interesting scandal where somebody sent a request for help in using Macsyma.

Macsyma ってのは MIT で開発したシンボリック数学プログラム。
Macsyma is a symbolic algebra program that was developed at MIT.

その人は、Macsyma の作業をしてるある人に、助けてくれってメールを出したら、数時間たって別の人から返事がきた。
He sent to one of the people working on it a request for some help, and he got an answer a few hours later from somebody else.

その人はびっくりしちゃって、
He was horrified, he sent a message

「だれそれはあなたのメールを読んでるみたいですよ、ひょっとしてメールのファイルの保護がちゃんとしてないんじゃないですか？」
``so-and-so must be reading your mail, can it be that mail files aren't properly protected on your system?''

「当然でしょう、ぼくたちのシステムでは保護されてるファイルなんかない。
``Of course, no file is protected on our system.

なんかいけませんか？
What's the problem?

あなたはすぐに答がもらえたし、何が不満なの？
You got your answer sooner; why are you unhappy?

ぼくたちはお互いのメールを読む。
Of course we read each other's mail

あたりまえじゃん、そうやってあなたみたいな人を見つけて助けてあげるんだから」
so we can find people like you and help them.''

まったく、自分が得してるのにわかんない人ってのもいるんだからなぁ。
Some people just don't know when they're well off.

でももちろん、Twenex にはセキュリティがあっただけでなく、それをデフォルトで機能させるし、さらにセキュリティが使われてるという前提で設計されてる。
But of course Twenex not only has security, and by default turns on security, but it's also designed with the assumption that security is in use.

だから、簡単にできちゃってすごいダメージを与えるようなことってのがたくさんあって、うっかりそういうことをしないようにしてくれる唯一の手段がセキュリティなんだ。
So there are lots of things that are very easy to do that can cause a lot of damage, and the only thing that would stop you from doing them by accident, is security.

ITS では、そういうことをうっかりやっちゃわないようにするほかのいろんな方法が考案されてた。
On ITS we evolved other means of discouraging people from doing those things by accident,

でも Twenex にはそんなものはない。
but on Twenex you didn't have them

厳格なセキュリティが機能してて、そういうことをする権限を持つのはボスたちだけだ、と想定してたからだ。
because they assumed that there was going to be be strict security in effect and only the bosses were going to have the power to do them.

だから、そういううっかりミスを難しくするメカニズムはほかにぜんぜんつけてなかった。
So they didn't put in any other mechanism to make it hard to do by accident.

その結果として、単に Twenex をもってきてセキュリティをオフにするとほしいものが手に入るわけじゃなくなってて、そしてその他のメカニズムを入れ込むハッカーたちもいなかったから、みんなセキュリティを使うしかなくなってた。
The result of this is that you can't just take Twenex and turn of the security and have what you'd really like to have, and there were no longer the hackers to make the changes to put in those other mechanisms, so people were forced to use the security.

そしてマシンがやってきて 6 ヶ月ほどしたら、連中はクーデターをはじめた。
And about six months after the machine was there they started having some coups d'etat.

つまり、最初は AI 研で働いてる人はみんな、全セキュリティ機能をオーバーライドする全権を与えるホイールビットをオンにしてもらえるもんだ、という想定をしてた。
That is, at first we had the assumption that everyone who worked for the lab was going to have the wheel bit which gave full powers to override all security measures,

でもある日のある午後にやってきてみると、ほとんど全員のホイールビットがオフにされてた。
but some days you'd come in some afternoon and find out that the wheel bits of just about everybody had been turned off.

こんなのがわかったとき、ぼくはそれを打倒した。
When I found out about those, I overthrew them.

最初は、たまたまエリート層に属してるある人のパスワードを知ってたので、それを使ってみんなのビットを戻せた。
The first time, I happened to know the password of one of the people who was included among the elite, so I was able to use that to turn everyone back on.

二回目には、そいつはパスワードを変えてて、だから所属意識も変わってて、いまやもう貴族社会の一員だった。
The second time he had changed his password, he had now changed his sympathies, he was now part of the aristocratic party.

そこでぼくはマシンを停止させて、TSS でない DDT を使ってつつきまわさなきゃなんなかった。
So, I had to bring the machine down and use non-timeshared DDT to poke around.

モニタの中でつつきまわして、やがて OS をロードさせてパッチがあてられるようにするにはどうしたらいいかつきとめて、それでパスワードのチェックをオフにして、それからいろんな人のホイールビットを戻して、システムメッセージをポストした。
I poked around in the monitor for a while, and eventually figured out how to get it to load itself in and let me patch it, so that I could turn off password checking and then I turned back on a whole bunch of people's wheel bits and posted a system message.

説明しとくとこのマシンの名前は OZ で、だからこんなシステムメッセージをポストした。
I have to explain that the name of this machine was OZ, so I posted a system message saying:

「またもや権力を奪取せんとする試みが行われた。
``There was another attempt to seize power.

いまのところ、貴族階級の勢力は打倒された ―― ラジオ・フリー・OZ」
So far the aristocratic forces have been defeated - Radio Free OZ''

あとで知ったんだけど、「ラジオ・フリー・OZ」というのはファイアサイン劇場で使ってるものの一つなんだね。
Later I discovered that ``Radio Free OZ'' is one of the things used by Firesign Theater.

その頃は知らなかった。
I didn't know that at the time.

でも状況はだんだんと、どんどん悪いほうに向かってったね。
But gradually things got worse and worse,

要はそのシステムのつくられかたのせいで、それがみんなもっともっとセキュリティを要求するような性質もものだったってこと。
it's just the nature of the way the system had been constructed forced people to demand more and more security.

しまいにやがて、ぼくはそのマシンを使うのをやめなきゃなんなくなってきた。
Until eventually I was forced to stop using the machine, because I refused to have a password that was secret.

MIT AI 研にパスワードが初めて登場して以来、ぼくは自分の信念のために立ち上がろう、パスワードなんかあってはならないという信念にしたがおう、絶対にできるだけわかりやすいパスワードにして、それをみんなにばらすようにしようと決心したんだ。
Ever since passwords first appeared at the MIT-AI lab I had come to the conclusion that to stand up for my belief, to follow my belief that there should be no passwords, I should always make sure to have a password that is as obvious as possible and I should tell everyone what it is.

ぼくはコンピュータにセキュリティをつけるのはいいととは思わないから、セキュリティ支配が続くのを助けるようなこともすべきじゃない。
Because I don't believe that it's really desirable to have security on a computer, I shouldn't be willing to help uphold the security regime.

「空のパスワード」を使えるシステムでは使うし、それが許されないシステムとか、それだとほかの場所からは一切ログインできないとか、その手のシステムとかだと、ぼくはログイン名をパスワードにする。
On the systems that permit it I use the ``empty password'', and on systems where that isn't allowed, or where that means you can't log in at all from other places, things like that, I use my login name as my password.

これ以上はないってくらい自明でしょ。
It's about as obvious as you can get.

そしてだれかが、そんなことだと他人がきみになってログインできちゃうじゃないか、と指摘すると、ぼくはこう言う。
And when people point out that this way people might be able to log in as me, i say

「うん、まさにそれがねらい。
``yes that's the idea,

だれかがこのマシンのデータを必要とするかもしれない。
somebody might have a need to get some data from this machine.

そのときに、その人がセキュリティのおかげでバカを見たりすることが絶対ないようにしときたいのよ」
I want to make sure that they aren't screwed by security''


それともう一つやるのが、自分のディレクトリやファイルの保護は全部はずす。
And an other thing that I always do is I always turn of all protection on my directory and files,

だって役に立つソフトをそこに持っていることもよくあって、もしそれにバグがあったら、みんながなおせるようにしときたいから。
because from time to time I have useful programs stored there and if there's a bug I want people to be able to fix it.

でもこのマシンはまた、「観光」と呼ばれる現象をサポートするようにはできていなかった。
But that machine wasn't designed also to support the phenomenon called ``tourism''.

さて、「観光」ってのは AI 研ではすごく古い伝統で、ほかの形のアナーキーといっしょに続いてきてて、これはつまり、部外者にも自由にマシンを使わせるってこと。
Now ``tourism'' is a very old tradition at the AI lab, that went along with our other forms of anarchy, and that was that we'd let outsiders come and use the machine.

さて昔々、だれでもマシンにやってきて、勝手な名前でログインできた頃には、これはもう自動的にそうなってた。
Now in the days where anybody could walk up to the machine and log in as anything he pleased this was automatic:

もし MIT に遊びにきてたら、ログインして作業ができる。
if you came and visited, you could log in and you could work.

後にこれをちょっとは形式化した。
Later on we formalized this a little bit,

これは特に ARPAnetがはじまって、みんな全国からうちのマシンにつなぐようになったときにそうで、みんなが認める伝統としてってこと。
as an accepted tradition specially when the Arpanet began and people started connecting to our machines from all over the country.

さて、ぼくたちが期待してたのは、そういう部外者がプログラミングを実際に学んで、OS を変えはじめることだった。
Now what we'd hope for was that these people would actually learn to program and they would start changing theoperating system.

この話をほかのどこのシステム管理者にしても、みんな飛び上がるよ。
If you say this to the system manager anywhere else he'd be horrified.

どんな部外者でもマシンが使えるなんて匂わせようものなら、その人は言うだろう。
If you'd suggest that any outsider might use the machine, he'll say

「でもそいつがシステムプログラムを変えちゃったらどうすんの？」
``But what if he starts changing our system programs?''

でもぼくたちにとっては、部外者がシステムプログラムを変えはじめるってことは、それはつまりその人がコミュニティに貢献するメンバーになろうと本気で興味を示してるってことなんだ。
But for us, when an outsider started to change the system programs, that meant he was showing a real interest in becoming a contributing member of the community.

ぼくたちはいつも、そうするよう奨励してる。
We would always encourage them to do this.

最初はもちろん、新しいシステムユーティリティを書くところから、それも小さいヤツね、そしてそいつが何をやったか監督して訂正するけど、でもそしたらそれから既存の大きなユーティリティに機能を追加するほうに向かう。
Starting, of course, by writing new system utilities, small ones, and we would look over what they had done and correct it, but then they would move on to adding features to existing, large utilities.

そしてそういうプログラムはもう 10 年とか 15 年とか存在していて、一部一部ごとに、職人が次々と新しい機能を足してったものなんだ。
And these are programs that have existed for ten years or perhaps fifteen years, growing piece by piece as one craftsman after an other added new features.

フランスの都市みたいなもんだと言ってもいいかな。
Sort of like cities in France you might say,

ものすごく古い建物に、数百年後に増築がされて、それがずっといままで続いてるような。
where you can see the extremely old buildings with additions made a few hundred years later all the way up to the present.

コンピュータの世界だと、1965 年に書きはじめられたソフトってのがそれにあたる。
Where in the field of computing, a program that was started in 1965 is essentially that.

だからぼくたちはいつも、観光客がシステム管理者になってほしいと思ってて、そしたら雇われるかもしれない。
So we would always hope for tourists to become system maintainers, and perhaps then they would gethired,

もちろんシステムプログラムの作業を始めて、まともな仕事ができることを証明してくれればだけど。
after they had already begun working on system programs and shown us that they were capable of doing good work.

でも ITS のマシンには、これが手に負えなくなるのを防ぐための機能がほかにいくつかあった。
But the ITS machines had certain other features that helped prevent this from getting out of hand,

その一つが「スパイ」機能で、だれが何をしてるか、だれでも観察できる機能だった。
one of these was the ``spy'' feature, where anybody could watch what anyone else was doing.

そしてもちろん、観光客はスパイするのが大好きで、みんなそれがいかしたことだと思って、つまりちょっとイケナイ感じだけれどでも結果として、どっかの観光客が何か面倒を起こすようなまねをしても、必ずだれかがそれを見てるわけ。
And of course tourists loved to spy, they think it's such a neat thing, it's a little bit naughty you see, but the result is that if any tourist starts doing anything that causes trouble there's always somebody else watching him. 

それでやがてそいつの友だちはすごく怒りだす。
So pretty soon his friends would get very mad

観光が続いてくれるためには、観光客が責任ある行動をするかどうかにかかってるのを知ってるから。
because they would know that the continued existence of tourism depended on tourists being responsible.

それでたいがいは、そいつがだれだか知ってるやつがいて、それでそういうことをしないように説明してもらえるんだ。
So usually there would be somebody who would know who the guy was, and we'd be able to let him leave us alone.

それができなかったら、どうするかっていうと、特定の場所からのアクセスをしばらく完全に切る。
And if we couldn't, then what we would do was we would turn off access from certain places completely, for a while,

そしてそれを戻す頃には、そいつはどっかよそへ行って、ぼくたちのことは忘れちゃう。
and when we turned it back on, he would have gone away and forgotten about us. 

だからこれが何年も何年も何年も続いたんだ。
And so it went on for years and years and years.

でも Twenex システムは、この手のこと用には設計されてなくて、やがて連中はみんなにパスワードを知られてるぼくを許してくれなくなった。
But the Twenex system wasn't designed for this sort of thing, and eventually they wouldn't tolerate me with my password that everybody knew,

観光客がいつもぼくの名前で同時に 2 人も 3 人もログインしてたわけ。
tourists always logging in as me two or three at a time,

だから連中はぼくのアカウントを消すようになった。
so they started flushing my account.

そしてその頃には、ぼくはどうせ別のマシンで作業してるほうが多くて、だからやがてあきらめて、もうそっちのスイッチは入れなくなった。
And by that time I was mostly working on other machines anyway, so eventually I gave up and stopped ever turning it on again.

それでそれはおしまい。
And that was that.

もうあの機械にはずいぶんログインしてないな、自分のアカウントではもう……（この時点で、RMS はすさまじい拍手にさえぎられる）年も。
I haven't logged in on that machine as myself ... [At this point RMS is interrupted by tremendous applause] ... for.

でも連中が最初にこの Twenex システムを手に入れたら、まずいくつか変更をしたがった。
But when they first got this Twenex system they had several changes in mind that they wanted to make.

セキュリティの仕組みを変えたがった。
Changes in the way security worked.

それとそのマシンを ARPAnet とMIT-CHAOS ネットワークに両方につなぎたがったんだけど、でも結局はそれができなくて、そういう変更をするだけの能力をもった人が見つけられなかったんだ。
They also wanted to have the machine on both the ARPA network and the MIT-chaos network, and it turns out that they were unable to do this, that they couldn't get anyone who was sufficiently competent to make such changes.

それをするだけの才能がもうなくなってたし、そもそもシステムの変更がむずかしかった。
There was no longer talent available to do it, and it was to hard to change.

このシステムはずっとわかりにくくて、それはダメな書かれかたをしてたからで、もちろん Digital はそんなことしてくれなくて、だから商業システムなら基本的にはシステム管理を会社がやってくれるという考え方は、結局まちがってることが証明されたわけ。
That system was much harder to understand, because it was to poorly written, and of course, Digital wouldn't do these things, so their ideas that a commercial system would essentially maintain it self, proved to be mistaken.

システムハッカーに対するニーズは前と変わらなかったのに、でもシステムハッカーをおびきよせる手段がもうなくなってた。
They had just as much need for system hackers, but they had no longer the means to entice system hackers.

そして最近のMIT には、Twenex 上でハッキングしたがる人より ITS でハッキングしたがる人のほうが多いんだ。
And nowadays at MIT there are more people interested in hacking on ITS, than there are interested in hacking on Twenex.

そしてそうなる最終的な理由ってのは、Twenex は共有できないってことなんだ。
And the final reason why this is so, is that Twenex can't be shared.

Twenex は独占プログラムで、ソースコードを手に入れるには、ある嫌らしい方法でそれを秘密にしとかなきゃならなくて、これが印象を悪くしてる。
Twenex is a proprietary program and you're only allowed to have the sources if you keep them secret in certain nasty ways, and this gives them a bad flavor.

その人が無関心でなければ
Unless a person is oblivious

（そしてコンピュータ業界にはそういう人もいて、自分たちだけが楽しければなんでもやって、ほかの人たちと協力してるかなんて一瞬たりとも考えないような人たちだけれど、でもそんなソフトの作業をするのがどんなに悲しいことかわかんないなんて、相当無関心じゃないとアレで、これがさらにマイナス要因だよね）。
(which some people in computers are, there's some people who'll do anything if it's fun for them, and won't think for a minute whether they're cooperating with anyone else, but you'd have to be pretty oblivious to not to notice what a sad thing it is to work on a program like that, and that is a further discouragement).

そしてさらにだめ押しでくるのが、毎年かそこら、新しいリリースってのが出てきて、それが 50,000 行くらいの追加のコードだらけで、それが全部サルが書いたみたいな代物。
And if that isn't enough there is the fact that every year or so they're going to give you a new release full of 50 000 additional lines of code all written by monkeys.

それは連中が「サル 100 万匹にタイプさせれば、いずれなんか使えるものが出てくる」式システム開発にしたがってるから。
Because they generally follow the ``million monkeys typing, and eventually they'll come up with something useful'' school of system development.

こういう独占システムで何が起きてるか見たとき、ぼくにははっきりわかった。
It was clear to me from what I saw happening to these proprietary systems

かつてのAI研のスピリットをぼくらが持つ唯一の方法は、フリーの OS をつくることだってのが。
that the only way we could have the spirit of the old AI lab was to have a free operating system.

フリーソフトだけでつくったシステムができて、それがみんなで共有できるようになることだって。
To have a system made up of free software which could be shared with anyone.

そうすればみんなに、その改善に参加しようと呼びかけられる。
So that we could invite everyone to join in improving it.

そしてそこから GNU プロジェクトが出てきたんだ。
And that's what led up to the GNU project.

というわけで、この話の第二部にやってきたってことだね。
So I guess we've arrived at the second part of the talk.

  ------------------------------------------------------------------------

3 GNU プロジェクト

3.1　はじめの一歩

だいたい 3 年半くらい前に、フリーソフトシステム開発に手をつけるべきだってのは自分ではっきりしてきた。
About three and a half year ago it was clear to me that I should start developing a free software system.

開発すべきシステムとしては二種類の可能性が LISPマシンみたいなシステムで、ちょうど開発されたばかりの MIT LISP システムとまったく同じだけれど、でもフリーで、しかも特別な LISP マシンじゃなくて、ふつうのハードで動くヤツ。
I could see two possible kinds of systems to develop: One: A LISP-machine-like system, essentially a system just like the MIT LISP machine system that had just been developed, except free, and running on general purpose hardware, not on special LISP machines.

そしてもう一つの可能性が、もっと伝統的な OS をつくるってことで、その時にはっきりしてたのは、もし伝統的な OS をつくるなら、それは UNIX と互換性をもたせるべきだってこと。
And the other possibility was a more conventional operating system, and it was clear to me that if I made a conventional operating system, I should make it compatible with UNIX, 

そうすればいろんなとこの人たちが乗り換えやすいから。
because that would make it easy for people all around to switch to it.

しばらくして、後者をやるべきだと決めたんだけど、その理由は、ほんとの LISP マシンみたいなものを普通のハードではできないってのが見えてきたからだったのね。
After a little while, I concluded I should do the latter and the reason was, that I saw that you can't have something really like the LISP machine system on general purpose hardware.

LISP マシンは、実行速度を確保して、同時にランタイムで堅牢なエラー探知をするために、特殊なハードと特別な書き込み可能なマイクロコードを使ってるんだ。
The LISP machine system uses special hardware plus special writable microcode to gain both good execution speed and robust detection of errors at runtime, 

エラーって、特にデータタイプのエラー。
specially data-type errors.

ふつうのシステムで LISP システムを十分にはやく走らせるには、いろいろ仮定をおくようにしなきゃなんない。
In order to make a LISP system run fast enough on ordinary hardware, you have to start making assumptions.

ある引き数が正しいタイプだって仮定して、で、そうでなければシステムはあっさりクラッシュ。
Assuming that a certain argument is the right type, and then if it isn't the system just crashes.

もちろん外的なチェックを入れることはできるし、やりたきゃ堅牢なプログラムも書けるけど、結局のところは、そのチェックを入れなければ、関数にまちがったタイプの引き数を喰わせたら、メモリアドレッシングのエラーとかが起きちゃうってことだ。
Of course you can put in explicit checks, you can write a robust program if you want, but the fact is that you are going to get things like memory addressing errors when you feed a function an argument of the wrong type if you did NOT put in things to check for it.

だから結果としては、LISP システムの下で何かが走ってて、そういうエラーを拾ってくれなきゃなんない。
So the result is then that you need something running underneath the LISP system to you catch these errors,

そしてユーザがシステムを動かし続けて、起きたことをデバッグできるようにしないと。
and give the user the ability to keep on running, and debug what happened to him.

最後に、もし下の OS をつくるんなら、それはいい OS にしようとも決心した ―― つまりこれは、OS と LISP か、あるいは OS だけか、という選択だった。
Finally I concluded that if I was going to have to have a operating system at a lower level, I might as well make a good operating-system--that it was a choice between an operating system and the lisp, or just an operating system;

だから、まずは OS をやるべきだろう、そしてそれはUNIX 互換にすべきだ。
therefore I should do the operating system first, and I should make it compatible with UNIX.

最後にこのシステムの名前として英語でいちばんおもしろい名前を使えるんだと気がついたら、ぼくの選ぶべき道ははっきりした。
Finally when I realized that I could use the most amusing word in the English language as a name for this system, it was clear which choice I had to make.

そのことばはもちろん GNU で、これは「GNU 's Not Unix」の略。
And that word is of course GNU, which stands for ``Gnu's Not Unix''.

この再帰的な略称は、MIT周辺のハッカー社会ではすごく古い伝統になってる。
The recursive acronym is a very old tradition among the hacker community around MIT.

ぼくの知る限り、これは TINTというエディタではじまったはず。
It started, I believe, with an editor called TINT,

これは「Tint Is Not Teco」の略で、それはやがて「SINE Is Not EMACS 」の略で SINE とか、「Fine Is Not EMACS」で FINE とか、「Eine Is Not EMACS」で EINE とか、「Zwei Was Eine Initially（Zwei はもともと Eine でした）」の ZWEI とか、そしていまはそれが GNU まできたわけ。（訳注：ドイツ語では Eine は 1 で、Zwei が 2 だというのはもちろんご承知のこととは思いますが……）
which means: ``Tint Is Not Teco'', and later on it went through names such as ``SINE'' for ``SINE Is Not Emacs'', and FINE for ``Fine Is Not Emacs'', and EINE for ``Eine Is Not Emacs'', and ZWEI for ``Zwei Was Eine Initially'', and ultimately now arrives at GNU.

だいたい 2 年半ほど前に実際に GNU の仕事をはじめてから、もう作業の半分くらいは終えたと言っていいかな。
I would say that since the time about two and a half years ago when I actually started working on GNU, I've done more than half of the work.

このプロジェクトにとりかかろうとしてたとき、まずはすでにフリーで出回ってるものは何があるかを探すとこからはじめた。
When I was getting ready to start working on the project, I first started looking around for what I could find already available free. 

そこで見つけたのが、おもしろいポータブルなコンパイラシステムで、これは「TheFree University Compiler Kit」という名前。
I found out about an interesting portable compiler system which was called ``the free university compiler kit'',

こんな名前なら、もらえるのかな、と思った。
and I thought, with a name like that, perhaps I could have it.

だから開発した人にメールを送って、 GNU プロジェクトにくれないか、ときいてみたら、その人は
So, I sent a message to the person who had developed it asking if he would give it to the GNU project,

「いや、free は大学にかかることばで、そこで開発してるソフトはフリーじゃないんです」と言って、
and he said ``No, the university might be free, but the software they develop isn't'',

でもそれから言うには、かれも UNIX互換システムがほしくて、それ用のカーネルみたいなものも書いてみたいから、そしたらぼくがそれ用にユーティリティを書いて、そしたらその両方ともかれの独占コンパイラといっしょに配布できて、そしたらみんながそのコンパイラを買いたがるようになるだろう、だって。
but he then said that he wanted to have a UNIX compatible system too, and he wanted to write a sort of kernel for it, so why didn't I then write the utilities, and they could both be distributed with his proprietary compiler, to encourage people to buy that compiler.

それでぼくは、ふざけんじゃないよと思って、だからそいつに、ぼくの最初のプロジェクトはコンパイラの開発だ、と言ってやった。
And I thought that this was despicable and so I told him that my first project would be a compiler.

その頃は、コンパイラの最適化について実は大して知らなかった。
I didn't really know much about optimizing compilers at the time,

一度もいじったことがなかったから。
because I'd never worked on one.

でも、その頃フリーだと言われたコンパイラを手に入れられた。
But I got my hands on a compiler, that I was told at the time was free.

それが PASTELっていうコンパイラで、作者たちに言わせると「色の薄いPASCAL」という意味なんだって。
It was a compiler called PASTEL, which the authors say means ``off-color PASCAL''.

Pastel はすごく複雑な言語で、パラメータ化された型や明示タイプパラメータ（explicit type parameter）とか、いろいろ複雑なものを含んでた。
Pastel was a very complicated language including features such as parametrized types and explicit type parameters and many complicated things.

コンパイラ自身ももちろんこの言語で書かれてて、こういう機能の利用を最適化するのに、いろいろ複雑な機能を持っていたんだ。
The compiler was of course written in this language, and had many complicated features to optimize the use of these things.

たとえばこの言語では string 型はパラメータ化されていた。
For example: the type ``string'' in that language was a parameterized type;

特定の長さの文字列がほしければ「string(n)」と書ける。
you could say ``string(n)'' if you wanted a string of a particular length;

単に「string」と書けば、パラメータは文脈から決まってくる。
you could also just say ``string'', and the parameter would be determined from the context.

で、文字列ってすごく大事で、それを使ういろんな構造体を高速に走らせるためにも必要で、ということはつまり、各種のことを検出するようないろんな機能が必要ってことだよね、たとえば、宣言されたストリング長が引数で、それが関数の中ではずっと定数であることを検出するとか、値を保存してそれが生み出すコードを最適化するとか、いろいろややこしいこと。
Now, strings are very important, and it is necessary for a lot of constructs that use them to run fast, and this means that they had to have a lot of features to detect such things as: when the declared length of a string is an argument that is known to be constant throughout the function, to save to save the value and optimize the code they're going to produce, many complicated things.

でもこのコンパイラの中では、少なくともレジスタ自動割り当てをどうするかとか、そういうことは読みとれたし、いろいろちがったマシンの扱い方の考え方もわかった。
But I did get to see in this compiler how to do automatic register allocation, and some ideas about how to handle different sorts of machines.

さてこのコンパイラはすでに PASTEL をコンパイルできるので、必要なのは C のフロントエンドをつけることで、これをやって、それから 68000 用のバックエンドをつけることだった。
Well, since this compiler already compiled PASTEL, what i needed to do was add a front-end for C, which I did, and add a back-end for the 68000 

68000 がぼくの最初のターゲットマシンになるものと思ってたから。
which I expected to be my first target machine.

でもここで深刻な問題にぶちあたった。
But I ran into a serious problem.

PASTEL 言語は何かを使う前に宣言しなくていいようになってたので、だから宣言と使用がどんな順序でもよくて、つまりは、Pascal の「forward」宣言は使いものにならなくて、おかげでプログラムをまるごと読み込んで、それをコアにいれといて、一挙に処理するしかなかった。
Because the PASTEL language was defined not to require you to declare something before you used it, the declarations and uses could be in any order, in other words: Pascal's ``forward'' declaration was obsolete, because of this it was necessary to read in an entire program, and keep it in core, and then process it all at once.

結果としてコンパイラ内部で使われる中間記憶、つまり必要メモリ量は、ファイルの大きさに比例して大きくなるわけ。
The result was that the intermediate storage used in the compiler, the size of the memory needed, was proportional to the size of your file.

そしてここにはスタック領域も含まれてて、ものすごいスタック領域が必要で、だから結果としてわかったこと：ぼくの手もとの 68000 システムではこのコンパイラは走らない。
And this also included stack-space, you needed gigantic amounts of stack space, and what I found as a result was: that the 68000 system available to me could not run the compiler.

それはそのシステムが最悪のUNIX で、スタックに 16K ワードとかの上限があって、これってマシン自体にはメモリが 6 メガバイトもあるのにだよ、スタックは 16Kw かそこらしかとれないっての。
Because it was a horrible version of Unix that gave you a limit of something like 16K words of stack, this despite the existence of six megabytes in the machine, you could only have 16Kw of stack or something like that.

そしてもちろん、一時的な変数値がかちあってないかとか、あるいは同時に生きてるのがどれかとかを見るのに、コンフリクト行列を生成するんだけど、これはビット単位で4次元行列とかが必要で、大きな関数になるとそれが何百バイトとか何千バイトにもなる。
And of course to generate its conflict matrix to see which temporary values conflicted, or was alive at the same time as which others, it needed a quadratic matrix of bits, and that for large functions that would get it to hundreds of thousands of bytes.

だからコンパイラは 10 パスくらいかそこらあったんだけど、その最初のパスはなんとかデバッグして、それをそのマシン用にクロスコンパイルして、そしてふたを開けてみたら、二番目のやつはそもそも走らない。
So i managed to debug the first pass of the ten or so passes of the compiler, cross compiled on to that machine, and then found that the second one could never run.



3.2　GNU EMACS

こういう問題をどうしようか考えて、これをなおそうとするのか、それともまったく新しいコンパイラを書こうか考えているうちに、なんやかんやで GNU EMACS の作業にとりかかった。
While I was thinking about what to do about these problems and wondering whether I should try to fix them or write entirely new compiler, in a roundabout fashion I began working on GNU Emacs.

GNU EMACS は GNU システムの配布分の主要部分。
GNU Emacs is the main distributed portion of the GNU system.

拡張できるテキストエディタで、ぼくが10年前に開発したオリジナルの EMACS とかなり似てるけど、こいつは拡張用言語として本物の LISP を使うんだ。
It's an extensible text editor a lot like the original emacs which I developed ten years ago, except that this one uses actual LISP as its extension language.

エディタ自身は C で実装されてて、LISP インタープリタも同じく C で実装されてるから、LISP インタープリタは完全に可搬性があって、エディタの外部に LISP システムを持たなくていい。
The editor itself is implemented in C, as is the LISP interpreter, so the LISP interpreter is completely portable, and you don't need a LISP system external to the editor.

エディタ自身が自前の LISP システムを持ってて、すべての編集コマンドはLISP で書いてあるから、それをお手本として見て自前の編集コマンドを書いたり、何からはじめるかとか、そういうのを変えて、自分が本当にほしい編集コマンドに変えられるんだよ。
The editor contains its own LISP system, and all of the editing commands are written in LISP so that they can provide you with examples to look at for how to write your own editing commands, and things to start with, so you can change them into the editing commands that you really want.

その年の夏、いまから 2 年ほど前、ぼくの友だちがゴスリング EMACS の開発初期に手伝ったので、ゴスリングからかれのバージョンのゴスリング EMACS を配布していいよ、という許諾をメールで受け取ったと話してくれた。
In the summer of that year, about two years ago now, a friend of mine told me that because of his work in early development of Gosling Emacs, he had permission from Gosling in a message he had been sent to distribute his version of that.

ゴスリングはもともと EMACS を書き上げて、それをフリーで配布して、たくさんの人が開発に協力して、それはゴスリング自身がマニュアルの中で書いたような、ぼくがもとの EMACSを開始したのと同じ精神にしたがうというかれ自身のせりふに基づいた期待があったからなんだ。
Gosling originally had set up his Emacs and distributed it free and gotten many people to help develop it, under the expectation based on Gosling's own words in his own manual that he was going to follow the same spirit that I started with the original Emacs.

そしたらゴスリングはそいつに著作権をつけて、みんなにそれを再配布しないと約束させて、あげくにそれをソフトハウスに売って、みんなを後ろから刺して裏切ったんだ。
Then he stabbed everyone in the back by putting copyrights on it, making people promise not to redistribute it and then selling it to a software-house.

その後ゴスリングと個人的にやりとりしたけど、この歴史を見て予想されるのと寸分の狂いもないくらい、臆病でふざけたやつだったよ。
My later dealings with him personally showed that he was every bit as cowardly and despicable as you would expect from that history.

まあとにかく、その友たちがこのプログラムをくれて、それでぼくとしてはトップレベルの編集コマンドを変えて、ぼくの慣れ親しんでるオリジナルの EMACS と互換性を持たせたかった。
But in any case, my friend gave me this program, and my intention was to change the editing commands at the top level to make them compatible with the original Emacs that I was used to.

それと数値引き数の組み合わせとかいろいろ扱えるようにして、ぼくのほしいような機能を全部扱えると期待できるようにするとか。
And to make them handle all the combinations of numerical arguments and so on that one might expect that they would handle and have all the features that I wanted.

でもしばらくやってるうちに、このエディタの拡張用言語、MOCKLISP っていうんだけど、それがこの作業用には力不足だってのがわかってきた。
But after a little bit of this, I discovered that the extension language of that editor, which is called MOCKLISP, was not sufficient for the task.

計画してることをやるためには、こいつをすぐにでもすげかえる必要があるってわかった。
I found that that I had to replace it immediately in order to do what I was planning to do.

前にもいつかはMOCKLISP を本物の LISP に置き換えようと思ってたんだけど、でも真っ先にそれをやんなきゃっていうのがわかってきた。
Before I had had the idea of someday perhaps replacing MOCKLISP with real LISP, but what I found out was that it had do be done first.

それで、MOCKLISP がなぜ「MOCK（にせ）」ってついてるかというと、そこに構造体データタイプがないからなの。
Now, the reason that MOCKLISP is called MOCK, is that it has no kind of structure datatype:

LISP リストもない。
it does not have LISP lists;

配列もぜんぜんない。
it does not have any kind of array.

LISP シンボルもない。
It also does not have LISP symbols,

これは名前つきオブジェクトね。
which are objects with names:

MOCKLISP ではある名前に対してオブジェクトは一つしかなくて、だから名前をタイプすると、いつも同じオブジェクトしか戻ってこないの。
for any particular name, there is only one object, so that you can type in the name and you always get the same object back.

こいつのおかげでいろんなプログラムを書くのがえっらくやっかいで、ホントはそんなふうに使うんじゃないようなややこしいストリング操作で、あれやこれやを処理しなきゃなんなかったわけ。
And this tremendously hampers the writing of many kinds of programs, you have to do things by complicated string-manipulation that don't really go that way.

それで LISP インタープリタを書いて、MOCKLISP をすげかえて、その過程で、エディタの内部データ構造を書き直さなきゃならないこともわかった。
So I wrote a LISP interpreter and put it in in place of MOCKLISP and in the process I found that I had to rewrite many of the editor's internal data structures

ぼくはそういうのが LISP オブジェクトになっててほしかったから。
because I wanted them to be LISP objects.

LISP とエディタのインターフェースがクリーンであってほしくて、それはつまり、エディタのバッファやサブプロセスやウィンドウやバッファ位置みたいなオブジェクトが、みんな LISP オブジェクトでなきゃだめだってこと。
I wanted the interface between the LISP and the editor to be clean, which means that objects such as editor buffers, sub-processes, windows and buffer-positions, all have to be LISP objects, 

そうじゃないとそれに作用するエディタのプリミティブは LISP データの LISP 関数としてコールできるようにならない。
so that the editor primitives that work on them are actually callable as LISP functions with LISP data.

ということは、こういうオブジェクトすべてのデータ形式を設計しなおして、それに作用する関数もみんな書き直して、結果として 6 ヶ月後には、ぼくはエディタのほとんどすべてを書き直してたってわけ。
This meant that I had to redesign the data formats of all those objects and rewrite all the functions that worked on them, and the result was that after about six months I had rewritten just about everything in the editor.

加えて、MOCKLISP でなんか書くのはすごく難しいので、MOCKLISP で書かれたものはみんなきたなくて、だから本物の LISP の力を使えるようにそれを書きなおせば、それをみんなもっと強力でもっと単純でもっと高速にできたんだ。
In addition, because it is so hard to write things in MOCKLISP, all the things that had been written in MOCKLISP were very unclean and by rewriting them to take advantage of the power of real LISP, I could make them much more powerful and much simpler and much faster.

だからそれをやって、結果としてぼくがそれを配布しはじめときには、受け取ったものでそのまま使われてる部分はほとんどなかった。
So I did that, and the result was that when I started distributing this program only a small fraction remained from what I had received.

この時点で、ゴスリングがプログラムを売ったと思ってる相手の会社が、ぼくの友だちがそれを配布する権利にケチをつけはじめて、メールはバックアップのテープに入ってて見つからなかった。
At this point, the company that Gosling thinks he sold the program to challenged my friend's right to distribute it, and the message was on backup tapes, so he couldn't find it.

そしてゴスリングは、そんな許可は与えてないと否定する。
And Gosling denied having given him permission.

そこでおかしなことが起きた。
And then a strange thing happened.

かれはこの会社と交渉してたんだけど、この会社がいちばん気にしてるのは、自分たちが配布してるのと似たようなものが出回っちゃ困るってことだったようなの。
He was negotiating with this company, and it seemed that the company mainly was concerned with not having anything distributed that resembled what they were distributing.

かれもまだ配布してたし、かれの職場 ―― Megatest 社ね ―― も、かれがぼくにくれたのと同じものを配布してて、それはかれの変更の入ったゴスリング EMACS で、だからかれは連中とそれを配布するのをやめるという合意をして、GNU EMACS を使うのに切り替えて、それでそしたら連中は、かれが実はやっぱり許諾を得てたんだってことを認めて、そうすればおそらくみんな満足ってことになるはずだった。
See, he was still distributing, and the company where he worked, which is Megatest, was still distributing the same thing he had given me, which really was an old version of Gosling Emacs with his changes, and so he was going to make an agreement with them where he would stop distributing that, and would switch to using GNU Emacs, and they would then acknowledge that he really had the permission after all, and then supposedly everyone would be happy.

そしてこの会社はぼくに相談をもちかけてて、GNU EMACS を配布させろ、もちろんそれはフリーだけど、でもいろんなサポートや補助を売りたいから、その作業の手伝いにぼくを雇いたいって言う。
And this company was talking to me about wanting to distribute GNU Emacs, free of course, but also sell various sorts of supporting assistance, and they wanted to hire me to help do the work.

だからその後、連中の気が変わってその契約にサインするのを拒否して、ネットワークに、ストールマンにはプログラムを配布する権利はないというメッセージをポストしたってのは、ちょっと変なんだよね。
So it's sort of strange that they then changed their mind and refused to sign that agreement, and put up a message on the network saying that I wasn't allowed to distribute the program.

別に連中は何かするとか言ったわけじゃなくて、単にいずれいつの日か何か手をうたないかどうかははっきりしないとか言っただけ。
They didn't actually say that they would do anything, they just said that it wasn't clear whether they might ever someday do something.

そしてそれだけでみんなびびっちゃって、もうだれも使わなくなって、これは悲しいことだ。
And this was enough to scare people so that no one would use it any more, which is a sad thing.

（ときどき、一生かけてやるのに一番いい仕事ってのは、どっかで商売上の機密になってる独占ソフトのでかい山をみつけて、それを街角で配って歩いて、もう機密でもなんでもなくしてしまうことじゃないかと思って、みんなの手に新しいフリーソフトをわたしたいならそのほうが自分で新しいソフトなんかを書くよりも、ぼくとしてはずっと効率のいいやりかたじゃないかと思うんだけれど、みんなそれを受け取るのさえ怖がるほど臆病なんだもんな）
(Sometimes I think that perhaps one of the best things I could do with my life is: find a gigantic pile of proprietary software that was a trade secret, and start handing out copies on a street corner so it wouldn't be a trade secret any more, and perhaps that would be a much more efficient way for me to give people new free software than actually writing it myself; but everyone is too cowardly to even take it.)

というわけで、残り全部を自分で書き直すしかなくて、だからそれをやって、それに一週間半くらいかかった。
So I was forced to rewrite all the rest that remained, and I did that, it took me about a week and a half.

というわけで、やつらは大勝利をおさめてさぞ満足だろうよ。
So they won a tremendous victory.

そしてぼくは、それ以降はどんな形であってもやつらとは協力なんかするもんか。
And I certainly wouldn't ever cooperate with them in any fashion after that.



3.3　GDB デバッガ

で、GNU EMACS がそこそこ安定してから、というのはなんだかんだで1年半ほどかかったんだけど、それからシステムのほかの部分に戻った。
Then after GNU Emacs was reasonably stable, which took all in all about a year and a half, I started getting back to other parts of the system.

GDB っていうデバッガを開発して、これはCコード用のシンボリック・デバッガで、最近配布に入れるようにした。
I developed a debugger which I called GDB which is a symbolic debugger for C code, which recently entered distribution.

このデバッガは、かなりの部分が DBX の精神にのっとったもので、これはバークレー UNIX についてくるデバッガね。
Now this debugger is to a large extent in the spirit of DBX, which is a debugger that comes with Berkeley Unix.

コマンドは、何をしたいかを示すことばと、それに続く引き数で構成される。
Commands consist of a word that says what you want to do, followed by arguments.

このデバッガでは、コマンドはみんな短縮形が使えて、よく使うコマンドは 1 文字の短縮形になってるんだけど、独自の短縮形も好きなように使える。
In this debugger, commands can all be abbreviated, and the common commands have single character abbreviations, but any unique abbreviation is always allowed.

充実した HELP 機能もあって、HELP のあとになんでもいいけどコマンドやサブコマンドまでタイプすると、そのコマンドの使い方が詳しく説明される。
There are extensible HELP facilities, you can type HELP followed by any command or even subcommands, and get a lengthy description of how to use that command.

もちろん C の表現をタイプすれば、どれでもその値を返してくれる。
Of course you can type any expression in C, and it will print the value.

ほかにも、シンボリック C デバッガでは珍しいことができたりする。
You can also do some things that are not usual in symbolic C debuggers,

たとえば、どのメモリアドレスにあるどの C データ型も参照できるんだよ。
for example: You can refer to any C datatype at any memory address, 

値を調べたり、値を入れたりできる。
either to examine the value, or to assign the value.

だからたとえばあるアドレスのワードに浮動小数点の値を入れたければ、
So for example if you want to store a floating point value in a word at a certain address,

「これこれのアドレスにある FLOAT 型か DOUBLE 型のオブジェクトをよこせ」といって、
you just say: ``Give me the object of type FLOAT or DOUBLE at this address''

それに割り当てればいい。
and then assign that.

もう一つできるのが、これまで調べてみた値を全部調べられんの。
Another thing you can do is to examine all the values that have been examined in the past.

調べた値は全部「値ヒストリー」にのっかる。
Every value examined gets put on the ``value history''.

このヒストリーのどの要素でも、その番号で参照できるし、ただのドル記号（$）を使えば最後の要素を簡単に呼び出せる。
You can refer to any element in the history by its numerical position, or you can easily refer to the last element with just dollar-sign.

こうすると、リスト構造をトレースするのがすごく楽になる。
And this makes it much easier to trace list structure.

別の構造体を指すポインタを含むような C 構造体があったとするでしょ、そしたらたとえば PRINT *$.next みたいなことができて、
If you have any kind of C structure that contains a pointer to another one, you can do something like ``PRINT *$.next'',

これはつまり「さっきみせてくれたものの次のフィールドをとってきて、それが指してる構造体を表示しろ」ってことだ。
which says: ``Get the next field out of the last thing you showed me, and then display the structure that points at''.

そしてこのコマンドは繰り返せて、そのたびごとにリストの次の構造体が見られる。
And you can repeat that command, and each time you'll see then next structure in the list.

でも、ぼくがこれまで見た C デバッガだと、毎回もっと長いコマンドをタイプしなきゃなんないんだよね。
Whereas in every other C debugger that I've seen the only way to do that is to type a longer command each time.

そしてこの機能と、単に CR を押したら直前のコマンドを繰り返す、という機能と組み合わせると、これはすごく便利。
And when this is combined with the feature that just typing carriage-return repeats the last command you issued, it becomes very convenient.

リストの中で自分が見たい要素について、どんどん CR を押してけばいい。
Just type carriage-return for each element in the list you want to see.

あとデバッガの中で外部設定できる変数もある。
There are also explicitly settable variables in the debugger,

いくらでも。
any number of them.

ドル記号のあとに名前をつければ、それで変数。
You say dollar-sign followed by a name, and that is a variable.

こういう変数値をどんな C データ型にでもアサインして、あとで検討できる。
You can assign these variables values of any C datatype and then you can examine them later.

これがなんの役にたつかというと、たとえば：もし調べたい値がなんかあったとして、それをたくさん参照するのがわかってたら、ヒストリーの中でその値を覚えとくより、名前をつけちゃったほうがいいかもしれない。
Among the things that these are useful for are: If there's a particular value that you're going to examine, and you know you are going to refer to it a lot, then rather than remember its number in the history you might give it a name.

あるいは、条件ブレークをセットするときにも使えるかも。
You might also find use for them when you set conditional breakpoints.

条件つきブレークは、シンボリックデバッガにはよくある機能で、
Conditional breakpoints are a feature in many symbolic debuggers,

「プログラムのここまできたら止まれ、ただしこの条件式が真の場合だけね」と言うわけ。
you say ``stop when you get to this point in the program, but only if a certain expression is true''.

デバッガの変数は、プログラム内の変数と、デバッガ変数内に保存した変数値とをくらべさせてくれる。
The variables in the debugger allow you to compare a variable in the program with a previous value of that variable that you saved in a debugger variable.

これはほかにも、数えるのに使える。
Another thing that they can be used for is for counting,

だって値の割付は要するにCの式でしょ、だから$hoge を 5 増やすには $hoge+=5 でもいいし、あるいは単に $hoge++ でやってもいい。
because after all, assignments are expressions in C, therefore you can do ``$foo+=5'' to increment the value of ``$foo'' by five, or just ``$foo++'' you can do.

これを条件付きブレークでもできるから、このブレークポイントに 10 回目にきたらブレークとかするのにはお手軽でしょ、 $hoge--==0 をするんだよね。
You can even do this in a conditional breakpoint, so that's a cheap way of having it break the tenth time the breakpoint is hit, you can do ``$foo--==0''.

みんな、ついてきてる？
Does everyone follow that?

hoge を減らしてって、それがゼロになってたらブレークしろってこと。
Decrement foo and if it's zero now, break.

そしてそれから $hoge を、スキップしたい回数にセットして、それで行ける。
And then you set $foo to the number of times you want it to skip, and you let it go.

これを配列の中の要素を見るのにも使える。
You can also use that to examine elements of an array.

たとえばポインタの配列があって、そしたらこんなことする：
Suppose you have an array of pointers, you can then do:

PRINT X[$hoge++]
PRINT X[$foo++]

でもその前にまずこれ：
But first you do

SET $hoge=0
SET $foo=0

オッケー、で、こうしたら（と「Print」式をさす）、X のゼロ番目の要素が出てくる。
Okay, when you do that [points at the ``Print'' expression], you get the zeroth element of X,

で、もう一回やったらそれは一番目の要素で、それでこれがもし構造体へのポインタなら、たぶんここ（PRINT 式の X の前）にアステリスク（*）を入れて、そしたら毎回これはこの配列の要素がさしてる次の構造体をだしてくる。
and then you do it again and it gets the first element, and suppose these are pointers to structures, then you probably put an asterisk there [before the X in the PRINT expression] and each time it prints the next structure pointed to by the element of the array.

そしてもちろん、改行をおすだけでこれを繰り返せる。
And of course you can repeat this command by typing carriage-return.

これ一つだけ繰り返すんじゃ不十分なら、ユーザ定義コマンドをつくればいい。
If a single thing to repeat is not enough, you can create a user-defined-command.

「Define むにゃむにゃ」とやって、それからコマンドを何行か入れて、「end」とやる。
You can say ``Define Mumble'', and then you give some lines of commands and then you say ``end''.

これでもう「むにゃむにゃ」コマンドが定義されて、それが入れた行を実行する。
And now there is defined a ``Mumble'' command which will execute those lines.

で、こういう定義をコマンドファイルに入れておくとすごく便利なの。
And it's very useful to put these definitions in a command file.

ディレクトリごとにコマンドファイルを持って、そこを作業ディレクトリにしてデバッガを起動すると、それが勝手にロードされるようにしておける。
You can have a command file in each directory, that will be loaded automatically when you start the debugger with that as your working directory.

だから各プログラムごとに、ユーザ定義コマンドをいろいろ定義しておいて、便利な形でそのプログラムのデータ構造にアクセスできるようにしとける。
So for each program you can define a set of user defined commands to access the data structures of that program in a useful way.

そういうユーザ定義コマンド用にドキュメンテーションだってつくれるんだよ。
You can even provide documentation for your user-defined commands,

そうするともとからのコマンドとまったく同じように、「help」機能で処理されるんだ。
so that they get handled by the ``help'' features just like the built-in commands.

このデバッガでもう一つ珍しいのが、スタックからフレームを捨てられるってこと。
One other unusual thing in this debugger, is the ability to discard frames from the stack.

デバッグしてるプログラムで何が起きてるか見られるだけじゃなくて、それを好き放題変えられるってのが大事だと思うんだ。
Because I believe it's important not just to be able to examine what's happening in the program you're debugging, but also to change it in any way conceivable.

だから問題を一つ見つけて何がダメかわかったら、そのコードが正しかったかのようにあちこちなおしてから、コンパイルしなおさなくても次のバグを見つけにいけるわけだよ。
So that after you've found one problem and you know what's wrong, you can fix things up as if that code were correct and find the next bug without having to recompile your program first.

ということは、プログラムのデータ領域を思い通りに直せるだけじゃなくて、コントロールのフローを好きに変えられなきゃならない。
This means not only being able to change the data areas in you program flexibly, but also being able to change the flow of control.

このデバッガでは、こんなふうにしてコントロールのフローをすごく直接的に変えられる：
In this debugger you can change the flow of control very directly by saying:

SET $PC=<なんか数字>
SET $PC=<some number>

こうやってプログラムカウンタを変えるの。
So you can set the program counter.

それとスタックポインタもセットできるし、あるいはこういうふうにでも：
You can also set the stack pointer, or you can say

SET $SP+=<なんとか>
SET $SP+=<something>

スタックポインタをちょっと増やしたいなと思うでしょ。
If you want to increment the stack pointer a certain amount.

でもついでに、プログラムのどこか途中からはじめたいとして、だからプログラムカウンタをそのソース行にあわせるよね。
But in addition you can also tell it to start at a particular line in the program, you can set the program counter to a particular source line.

でもそれで、その関数を呼んだのがまちがいで、その関数呼びたくなかった！としたら？
But what if you find that you called a function by mistake and you didn't really want to call that function at all?

たとえばその関数がどうしようもなくいかれてて、実はそこから戻ってきて、その関数のやるべきだったことを手でやりたいとしたら？
Say, that function is so screwed up that what you really want to do is get back out of it and do by hand what that function should have done.

それには 「RETURN」 命令を使う。
For that you can use the ``RETURN'' command.

スタックフレームを選んで 「RETURN」とやると、そのスタックフレームや、その中にあるやつ全部が捨てられて、その関数からすぐに戻ってきたような感じになって、しかもそこから返ってくるはずの値も指定できる。
You select a stack frame and you say ``RETURN'', and it causes that stack-frame, and all the ones within it, to be discarded as if that function were returning right now, and you can also specify the value it should return.

実行は続かないよ。
This does not continue execution;

返ってきたようなふりをして、そこでまたプログラムを止めるから、ほかのものもどんどん変えられる。
it pretends that return happened and then stops the program again, so you can continue changing other things.

このくらいいろいろまとまってると、プログラムの中で何が起きてるか、かなり細かくコントロールがきくわけよ。
And with all these things put together you thus have pretty good control over what's going on in a program.

これに加えて、もう一つちょっとおもしろいこと。
In addition one slightly amusing thing:

C にはストリング定数があって、デバッガ内で計算してる数式にストリング定数を使ったらどうなるか？
C has string constants, what happens if you use a string constant in an expression that you're computing in the debugger?

デバッグしてるプログラム内にストリングをつくらなきゃなんない。
It has to create a string in the program you were debugging.

だからつくってくれる。
Well it does.

デバッグ中のプログラム内で MALLOC へのコールをやってくれて、MALLOC を走らせて、それからコントロールを取り戻す。
It sets up a call to MALLOC in that debugged program, lets MALLOC run, and then gets control back.

こうやって、知らないうちにストリング定数を置く場所を見つけてくれるの。
Thus it invisibly finds a place to put the string constant.

いずれこのデバッガが本物の GNU システム上で動くようになるときには、その下で動いてる全プロセスの内部状態を調べられるような機能をつけるつもり。
Eventually when this debugger is running on the real GNU system, I intend to put in facilities in the debugger to examine all of the internal status of the process that is running underneath it.

たとえばメモリマップの状態を見ようとかね、どのページが存在して、どれが読めて、どれが書き込めるか見て、あと下部プログラムの終了状態（terminal status）を見るとか。
For example to examine the status of the memory map, which pages exist, which are readable, which are writable, and to examine the inferior program's terminal status.

もうかなりコマンドはあるんだ。
There already is a bit of a command;

このデバッガは、UNIX のデバッガとはちがって、終了状態をデバッガやデバッグ中のプログラムと完全に切り離してる。
this debugger, unlike the debuggers on UNIX, keeps the terminal status completely separate for the debugger and the program you're debugging,

だからそのままのモード（raw mode）で動くプログラムも見られるし、割り込み駆動入力をするプログラムでも動くし、それにデバッグ中のプログラムが実際に使ってるものの終了状態についても調べてくれるコマンドがある。
so that it works with programs that run in raw mode, it works with programs that do interrupt driven input, and there's also a command that enables you to find out something about the terminal settings at the program you're debugging is actually using.

一般にデバッガというのは、下部プロセスで起こってることはすべてわかるようにすべきだと思うな。
I believe that in general a debugger should allow you to find out everything that's going on in the inferior process.


3.4 gcc コンパイラ

GNU システムのうちすでに存在する主要部分は二つある。
There are two other main parts of the GNU system that already exist.

一つは新しい C コンパイラ（訳注：もちろんこの時点ではまだ gcc という名前はなかった。）で、もう一つは TRIX カーネルだ。
One is the new C compiler, and one is the TRIX kernel.

新しい C コンパイラは、この春から今年いっぱい書いてたもの。
The new C compiler is something that I've written this year since last spring.

ついに PASTELは捨てようと決めたんだ。
I finally decided that I'd have to throw out PASTEL.

この C コンパイラは PASTEL からのアイデアをもらってて、アリゾナ大学ポータブル・オプチマイザからのアイデアももらってる。
This C compiler uses some ideas taken from PASTEL, and some ideas taken from the University of Arizona Portable Optimizer.

連中のおもしろいアイデアは、いろんな種類のマシンを単純な命令の生成で扱うことで、ターゲットのマシンが許せばそれをいくつか組み合わせて複雑な命令にするんだ。
Their interesting idea was to handle many different kinds of machines by generating simple instructions, and then combining several simple instructions into a complicated instruction when the target machine permits it.

これを総合的にやるために、命令が数学式の記法で書かれてる。
In order to do this uniformly, they represent they represent the instructions in algebraic notation.

たとえば ADD 命令はこんな感じで書かれる：
For example, an ADD instruction might be represented like this:

r[3]=r[2]+4
r[3]=r[2]+4

これはコンパイラ内部での命令の表現形。
This would be a representation inside their compiler

2 番レジスタの中身をとって、それに 4を足して 3 番レジスタに入れろという命令。
for instruction to take the contents of register two, add four and store it in register three.

こういうふうにすれば、あらゆるマシン用にあらゆる命令を表現できる。
In this fashion you can represent any possible instruction for any machine.

それでかれらは実際に、すべての命令をこの形式で表現して、それを組み合わせる段階になったら、ある表現式をべつので置き換えて、もっと複雑な式をつくって組み合わせて命令にするわけ。
So they actually did represent all the instructions this way and then when it came time to try to combine them, they would do this by substituting one expression into another, making a more complicated algebraic expression for the combined instruction.

ときどき、最初の命令の結果がそれ以上使われるかどうかに応じて、割りつけ演算子を 2 つ持つような組み合わせ命令をつくんなきゃならない。
Sometimes depending on whether the result of the first instruction had any further use, it might be necessary to make a combined instruction with two assignment operators.

この値（と何かを指さす）用に 1 つと、こっちの値（と何かを指さす）用に 1 つ、こっちは 2 番目の命令からきた値と差し替えるのね。
One for this value [pointing at ???]and another one with this value [pointing at ???] substituted in it with what came from the second instruction.

でもこの値を 1 回しか使わないなら、差し替えたあとは捨てちゃえる。
But if this value was only used that once, you could eliminate it after substituting for it;

もうそれで計算する必要はないんだから。
there'd be no need to compute it any more.

だから。途中で入ってくる命令とかがこういう値を変えたりしないかとか、そういうのをちゃんとチェックして、差し替えをきちんとやるのはなかなかややこしい。
So it's actually somewhat complicated doing the substitution correctly checking that the intervening instructions don't change any of these values and other such things.

自動インクリメントや自動デクリメント・アドレッシングみたいなものをサポートするなら（ぼくはしてるけど）、値を保存するんじゃないような状況についてチェックするのに、いろいろチェックもしなきゃならない。
When you support such things as auto-increment and auto-decrement addressing, which I do now, you also have to do various checks for those to check for situations where what you're doing is not value preserving.

でもこういうの全部チェックしたら、差し替えた組み合わせ式をパターン・マッチャーに通して、それが選んだターゲットマシンで有効な命令を全部認識してくれる。
But after checking all those things, then you take the substituted combined expression and put it through a pattern matcher, which recognizes all the valid instructions of your chosen target machine.

それで認識されたら、その 2 つの命令を組み合わせ命令と置き換えて、そうでなきゃそのままにする。
And if it's recognized, then you replace those two instructions with the combined one, otherwise you leave them alone.

そして連中の技法ってのは、データフローで関連づけた命令 2 つ 3 つをこうやって組み合わせることなんだ。
And their technique is to combine two or three instructions related by data flow in this way.

アリゾナコンパイラでは、いろんなものをこういう文字列で表現してて、だから連中のコンパイラはとてつもなく遅い。
In the Arizona compiler, they actually represent things as text strings like this, and their compiler is horribly slow.

最初はこのコンパイラをそのまま使ってちょっと変えるだけにしようかと思ったけれど、でもぼくの求めるスピードを出すには完全に書き換えるしかないのは明らかだったので、こういう式すべてにリスト構造の記法を使うように書き直した。
First I had some idea of just using their compiler and making changes in it, but it was clear to me I had to rewrite it entirely to get the speed I wanted, so I have rewritten it to use list structure representations for all these expressions.

たとえばこういうの：
Things like this:

(set (reg 2)      (+ (reg 2)    (int 4)))
(set (reg 2)      (+ (reg 2)    (int 4)))

なんか LISP っぽいけど、でもこいつの意味はそんなに LISP してない。
This looks like Lisp, but the semantics of these are not quite LISP,

ここの各シンボルは特別に認識されるものだから。
because each symbol here is one recognized specially.

こういうシンボルの集合が特別に定義されていて、必要なのは全部そこにある。
There's a particular fixed set of these symbols that is defined, all the ones you need.

そしてそれぞれが特定の引数のパターンを持ってる。
And each one has a particular pattern of types of arguments,

たとえば：「reg」は必ず integer で、それはレジスタに番号がついてるからだけど、「+」は必ずサブの式を二つ持ってて、とかね。
for example: ``reg'' always has an integer, because registers are numbered, but ``+'' takes two subexpressions, and so on.

そしてそれぞれの式にはデータ型があって、それが基本的に、それが固定か浮動か、バイト長はどんだけか、なんてことを指示する。
And with each of these expressions is also a data type which says essentially whether it's fixed or floating and how many bytes long it is.

必要なら、ほかの物を扱えるように拡張することもできる。
It could be extended to handle other things too if you needed to.

それでぼくが自動レジスタ割り当てをやる方法ってのは、ぼくが最初にコードを生成するとき、組み合わせとかいろいろやるときだけど、レジスタに入りそうな変数にはすべて、自称疑似レジスタ番号ってのを割り振って、これは 16 とかなんとか、そのターゲットのマシンで実際のレジスタになるには大きすぎる番号からはじまる数字だ。
And the way I do automatic register allocation is that when I initially generate this code, and when I do the combination and all those things, for every variable that conceivably go into a register, I allocate what I call a pseudo register number, which is a number starting at sixteen or whatever is to high to be a real register for your target machine.

だから本物のレジスタは 0 から 15 までとかなんとかに割り当てられてて、そのあとに疑似レジスタがくる。
So the real registers are numbered zero to fifteen or whatever and above that comes pseudo registers.

それで、コンパイラの最後のところで何をやるかというと、ずっと見てって、疑似レジスタを本物のレジスタに変えてくんだ。
And then one of the last parts of the compiler consists of going through and changing all the pseudo registers to real registers.

またもやここでコンフリクトグラフをつくって、どの疑似レジスタ同士が同じ時点で生きてるかを見て、もちろんそれを本物のレジスタの同じところに入れるわけにはいかないので、だからなるべく疑似レジスタを固めてなるべく本物のレジスタに入れるようにして、しかもその重要度に応じて並べるわけ。
Again it makes a conflict graph, it sees which pseudo registers are alive at the same point and they of course can't go in the same real register, and then it tries packing pseudo registers into real registers as much as it can, ordering them by priority of how important they are.

そして最後に、いろんな問題に対応してコードを訂正しなきゃならない。
And finally it then has to correct the code for various problems,

たとえば本物のレジスタにおさまりきらない疑似レジスタがあって、それをかわりにスタックのスロットに入れなきゃならないとする。
such as happen when there were pseudo registers that don't fit in the real registers, that had to be put into stack slots instead.

一部のマシンだと、これが起きると命令の一部は無効になっちゃうかもしれない。
When that happens on certain machines, some of the instructions may become invalid.

たとえば 68000 だと、レジスタの内容をメモりに加算したり、メモリの内容をレジスタに加算したりはできるけれど、メモリの内容同士の加算はできない。
For example on the 68000 you can add a register into memory and you can add memory into register, but you can't add one memory location into another.

だから ADD 命令があって、68000 を相手にしてて両方の値がメモリにおさまっちゃったら、この命令は無効になる。
So if you have an ADD instruction, and you're headed for a 68000 and both of the things end up in memory, it's not valid.

だから最後のパスでは、ずっと見てって、必要に応じていろんなものをレジスタにコピーしたり、戻したりして、こういう問題を片づける。
So this final pass goes through and copies things into registers and out of registers as needed to correct those problems.

インデックスレジスタも問題になる。
Problems can also arise with index registers.

何かをインデックスにしてアドレスを決めるとき、そのインデックス値がメモリに入ってたら、そのコードはほとんどの場合役にたたなくなる。
If you're trying to index by something, then most of the time that code will become invalid if the index quantity is in memory, 

ただし、間接アドレッシングでそれができるマシンは別だけど。
except in a few cases on some machines where you can it with indirect addressing.

インデックスレジスタに自動インクリメントとかかけてるときには、その値をレジスタに入れて、命令をやって、インクリメントした値をほんとにあるべきメモリのスロットに戻してやらなきゃならないかもしれない。
In the cases when you're doing auto-increment on an index register you may have to copy the value into a register, do the instruction, and then copy the incremented value back to the memory slot where it really lives.

まだまだいろいろ小細工の余地はあって、ぼくもまだ十分に効率よくなるほどの細工は実装しきってない。
There's got room for a lot of hair, and I've not finished implementing all the hair needed to make really fully efficient.

このコンパイラは、C のコードをとって、それを実質的にはCデータ型の注釈がついた構文ツリーに変えるパーサーを持つことでいまは動いてる。
This compiler currently works by having a parser which turns C code into effectively a syntax tree annotated with C datatype information. 

それから次のパスではそのツリーをながめて、こんな（ LISP 状の）コードを生成する。
Then another pass which looks at that tree and generates code like this [LISP like code].

それから最適化パスがいくつかある。
Then several optimization passes.

一つには、ジャンプからジャンプ、ジャンプへのジャンプ、.+1 へのジャンプなんかを扱うもので、こんなのはみんなすぐに簡素化できる。
One to handle things like jumps across jumps, jumps to jumps, jumps to .+1, all of which can be immediately simplified.

それからよくある副次式の認識、さらに基本ブロック探し、それからデータフロー分析をして、どの命令にどの値が使われて、その後まったく使われないのはどれかがわかる。
Then a common subexpression recognizer, then finding basic blocks, and performing dataflow-analysis, so that it can tell for each instruction which values are used in that instruction and never used afterward.

そしてそれぞれの命令を、それが使う値の生成場所とリンクさせて、だから疑似レジスタ R[28] を生成するある命令があって、別の命令があとでR[28] を使って、それが R[28] を使う最初の場所だったら、二番目のやつが最初のやつを戻って指すようにして、このポインタが、命令を組み合わせようとするときの制御に使われる。
And also linking each instruction to the places where the values it uses were generated, so if I have one instruction which generates pseudo register R[28], and then another instruction later which uses R[28] and it's the first place to use R[28], I make the second one point back to the first one, and this pointer is used to control the attempts to combine the instructions.

隣り合った命令を組み合わせるんじゃなくて、ある値を使う命令と、それを生成する命令とを組み合わせるの。
You don't combine adjacent instructions, you combine an instruction that uses a value with the instruction that produced that value.

間にほかの命令がはさまっていても、ここでは関係なくて、単に介入してきたりしないかどうかチェックしなきゃならないだけ。
Even if there are other instructions in between, they don't matter for this, you just have to check them to make sure they don't do anything to interfere.

それで組み合わせ機能が動的レジスタ割り当てをやって、そして最後に、アセンブリコードにする部分がくる。
Then after the combiner comes the dynamic register allocator, and finally something to convert it into assembly code.

アリゾナコンパイラでは、命令認識部分は LEX で生成されてた。
In the Arizona compiler the instruction recognizer was generated with LEX.

マシン記述はただの LEX プログラムで、LEX はそれを C 関数にして、有効な命令を文字列として認識する。
Your machine description was simply a LEX program that LEX would turn into a C function to recognize valid instructions as strings.

ぼくがかわりにつけたのは、特別な専用デシジョン・ツリーで、まるでLISP みたいなこの構文で書かれたマシン記述から生成される。
What I have is instead a special purpose decision tree that's generated from a machine description written in this syntax as if it were LISP.

そしてこの認識部分は、コンパイラ内のいろんな部分のためのサブルーチンとして使われてる。
And this recognizer is used as a subroutine for many different parts of the compiler.

いまんとこ、このコンパイラは PCC くらいの速度で走る。
Currently this compiler runs about as fast as PCC.

レジスタ割り当ての小細工をするなといえば、目に見えて速くはなって、それだと PCC とレジスタの割り当ては同じ。
It runs noticeably faster if you tell it not to do the hairy register allocation, in which case it allocates registers the same way as PCC does.

超小細工モードだと、PCC よりずっと上手にレジスタ割り当てをやって、ぼくの見立てでは VAX だと VAX 用のどの C コンパイラよりもいいコードを生成してくれるね。
In its super hairy mode it does a much better job of allocating registers than PCC, and I observe that for the VAX it generates the best code I've seen from any C compiler on the VAX.

68000 だとコードはまだ理想的とはいえない。
For the 68000 the code is still not ideal.

前段で、十分に先を見通してないから、最高とはいえないようなことをしてる部分が見える。
I can see places where early stages do things that are not the best, because it can't fully look ahead.

前段では選択の余地があって、だからそいつが一番いいと思うことをやるんだけれど、でも別のやりかたをしてくれたら後段のほうが頭がいいから、もっといい処理をしてくれたはず。
It has a choice in an early stage, and it does the thing that it thinks is going to be best, but really if it did the other one, a later stage is actually smart enough to do something even better.

だけど前段は、後段がそんなことしてくれるとは知らないので、だからそういうのでもっと手を入れないと。
But the early stage doesn't know what the later stage is going to do, so I have more work to do on some of these things.

ときどきこのせいで、レジスタが無用に解放されちゃう。
Sometimes this causes it to free up registers unnecessarily.

だって、何かがメモリのほうにおさまって、それをレジスタにコピーしなきゃならなかったら、まずはそれをコピーするためのレジスタが必要になる。
Because when things wind up in memory and it needs to copy them into registers, it needs to get registers to copy them into.

これはつまり、すでに割り当てたレジスタを持ってきて、一時的な値をスタックのスロットに蹴り出すってことだ。
This means taking registers that it has already allocated to, and kicking those temporary quantities out to stack slots.

もちろんそういうのがレジスタからメモリにいっちゃうと、さらにほかの命令が無効になるかもしれなくて、だから何度も何度もチェックが必要になる。
Of course this may invalidate more instructions now that those things are in memory, not registers, so it has to check again and again.

ときどきこいつは、何かをレジスタにコピーしなきゃと思うんだけど、でもそんな必要がなかったりして、すると必要以上のレジスタを解放しちゃって、使えるレジスタを使い切らなかったりするんだ。
Sometimes it thinks it has to copy things to registers and really it isn't going to have to, so it may free up too many things and thus not use all the registers that it could.

（質問: 32000 用のコードジェネレータはありますか？）
(Question: Do you have a code generator for 32000?)

まだだけど、でも言っとくと、要るのはコードジェネレータじゃなくて、ただのマシンの記述だけね。
Not yet, but again, it's not a code generator it's just a machine description that you need.

そのマシンの命令が全部こんなふうに（LISP っぽい形式で）リストしてあればいい。
A list of all the machine instructions described in this [LISP like] form.

だから実際問題として、どの引数がレジスタに入れてとかどのレジスタにとかいう制約条件の考え方を実装するところは別にして、これは 68000 には必要だけど VAXでは不要だった話なんだけど、でもそれを別にすれば、このコンパイラを VAX から68000 に移植するのはほんの数日しかかからなかった。
So in fact aside from the work of implementing the idea of constraints on which arguments can be in registers and which kind of registers, which is something which was needed for the 68000 and was not needed for the VAX, the work of porting this compiler from the VAX to the 68000 just took a few days.

だから、すごく簡単に移植できるんだ。
So it's very easy to port.

コンパイラはいまはアセンブラ・コードを生成して、デバッグ情報を DBX の求める形式でも出せるし、GDB の特別な内部形式でも出せる。
The compiler currently generates assembler code and it can generate debugging information either in the format that DBX wants, or in the special internal format of GDB.

ぼくに言わせれば、このコンパイラで手をいれなきゃいけないのは、あとたった 3 分野だけ。
I'd say the only work needed on this compiler is in three areas.

 * 「プロファイリング」機能をつけなきゃならない。
One: I have to add a ``profiling'' feature,

UNIX のコンパイラにあるやつ。
like the one that the UNIX compilers have.

 * レジスタ割り当てをもう少し賢くしないとダメ。
Two: I have to make these register allocation things smarter,

出力にバカな代物が出てこないようにする。
so that I can stop seeing stupid things appearing in the output.

 * 最後に、いろんなバグがあるし、ちゃんと扱えてないものがある。
And three: There are various bugs, things that doesn't handle correctly yet,

自分自身はコンパイルはできてるんだけどね。
although it has compiled itself correctly.

これだけやるのに、まあ数ヶ月もあればってとこで、そしたらコンパイラをリリースする。
I expect this will just take a few months, and then I will release the compiler.



3.5 TRIX カーネル

システムの中ですでに存在する大きな部分がカーネル。
The other sizable part of the system that exist, is the kernel. 

(質問：休みは？) 
(Question: A pause?)

ああ、うん、そういや休憩を忘れてたね。
Ah, yeah I guess we've forgotten about breaks.

とりあえずカーネルの話だけ終わらせてよ。
Why don't I finish talking about the kernel,

5分ほどですむから。
which should only take about five minutes,

そしたら休憩にしよう。
and then we can take a break.

で、カーネルには TRIX （ぼくの知る限りでは、何の略でもないみたい）っていうシステムを使う予定（訳注：不詳。きいたことない。でも、すでにマルチサーバ式の OS らしきものは構想されているのがわかる。なおここでは、この 1986 年の時点でカーネルがまもなくできそうな雰囲気だが、実際に GNU のカーネルであるHURD がまがりなりにもリリースされたのは、1997 年になってからのことだった。）。
Now, for the kernel I am planning to use a system called TRIX (it doesn't stand for anything that I know of)

これは MIT の研究プロジェクトで開発されたもので、
which was developed as a research project at MIT.

リモート・プロシージャ・コールに基づいてる。
This system is based on Remote Procedure Call.

だからプログラムはドメインと呼ばれてる。
Thus programs are called domains.

各ドメインはアドレス空間といろんな機能（capability）で、機能（capability）ってのはまさに、ドメインを呼び出す能力なんだ。
Each domain is a address space and various capabilities, and a capability is none other than the ability to call a domain.

どのドメインもそれを呼び出す「capability ports」（機能ポート）がつくれて、そしてシステムコールとほかのユーザドメインをコールするのとがまったく同じ。
Any domain can create ``capability ports'' to call it, and then it can pass these ports to other domains, and there is no difference between calling the system and calling another user domain.

どっちをしてるのかすら区別できない。
In fact you can't tell which you have.

だからほかのユーザプログラムでデバイスを簡単に実装できる。
Thus it is very easy to have devices implemented by other user programs.

ファイルシステムも、透過的にユーザプログラムで実装できる。
A file system could be implemented by a user program, transparently.

さらにネットワークごしに通信するのも透過的。
It's also transparent to communicate across networks.

ほかのドメインを直接呼んでるつもりでも、実はネットワークサーバのドメインを呼んでるかもしれない。
You think that you're directly calling another domain, but really you're calling the network server domain.

コールで与えた情報をとって、それをネットワーク越しに別のサーバプログラムに渡して、それがこんどはあなたの話そうとしてるドメインを呼び出す。
It takes the information that you gave in the call, and passes this over the network to another server program which then calls the domain that you're trying to talk to.

でも、あなたとその相手のドメインには、そういう動きはまったく見えずに起こる。
But you and that other domain see this as happening invisibly.

TRIX カーネルは動くし、ごく限られたかたちで UNIX と互換性もあるんだけれど、でもまだまだだね。
The TRIX kernel runs, and it has a certain limited amount of UNIX compatibility, but it needs a lot more.

いまのところ、ディスク上では古くさい UNIX ファイルシステムが使ってるのと同じ構造を使ったファイルシステムを持ってる。
Currently it has a file system that uses the same structure on disk as the ancient UNIX file system does.

おかげでデバッグはやさしいよ。
This made it easier to debug the thing,

ファイルを UNIX でセットして、それを TRIX で走らせたりできるから。
because they could set up the files with UNIX, and then they could run TRIX,

でもこのファイルシステムは、ぼくが必要だと思う機能をぜんぜん持ってない。
but that file system doesn't have any of the features that I believe are necessary.

どうしても追加するべきだと思う機能としては、バージョン番号、削除ファイルの復活、ファイルがいつどこでテープにバックアップされたかの情報、ファイルの詳細更新（atomic superseding of files）。
Features that I believe must be added include: Version numbers, undeletion, information on when and how and where the file was backed up on tape, atomic superseding of files.

UNIX でいいと思うのは、ファイルが書き込まれているときには、いつでもどうなってるか見られるってことね。
I believe that it is good that in Unix when a file is being written, you can already look at what's going there,

たとえば「tail」を使ってどこまで進んだか見るとか、あれっていいよね。
so for example, you can use ``tail'' to see how far the thing got, that's very nice.

それでプログラムが、ファイル書きかけで死んだりしたら、どこまで行ったかも見られる。
And if the program dies, having partly written the file, you can see what it produced.

こういうのっていいんだけど、でもこの書きかけの出力が、いずれ期待してた完全な出力にまちがえられるようなことは、絶対にあってはならない。
These things are all good, but, that partly written output should not ever be taken for the complete output that you expected to have eventually.

その前のバージョンもちゃんと見られて、新しいバージョンが完全に正しくできるまでは、それを使おうとする人みんなに使われるべきでしょ。
The previous version of that should continue to be visible and used by everyone who tries to use it, until the new version is completely and correctly made.

ということはつまり、新しいバージョンはファイルシステムの中で見えなきゃダメだけれど、でも名前は予定されてた名前じゃいけないってことだ。
This means that the new version should be visible in the file system but not under the name it is supposed to have.

作業が完了してはじめてリネームされるようにしないと。
It should get renamed when it's finished.

これはまさに ITS がそうで、だけどここでは、各ユーザプログラムがそれを明示的にやる必要があった。
Which is by the way what happens in ITS, although there each user program has to do this explicitly.

ユーザプログラムに UNIX と互換性を持たせるには、これを目に見えない形でやる必要がある。
For UNIX compatibility with the user programs, it has to happen invisibly.

バージョン番号を、いまの UNIX のユーザプログラムにフィットさせるための、すごい小細工っぽい方式を考えてある。
I have a weird hairy scheme to try to make version numbers fit with the existing UNIX user programs.

それでこれって、ファイル名をそのまま指定してバージョン番号を略すと、ふつうの形で名前を指定するってこと。
And this is the idea that you specify a file name leaving the version number implicit, if you just specify the name in the ordinary way.

でもファイル名をはっきり指定したければ、たとえばはっきりどのバージョンを使いたいか指定するとか、あるいはぜんぜんバージョンを使いたくなければ、ファイル名の最後にピリオドをつける。
But if you wish to specify a name exactly, either because you want to state explicitly what version to use, or because you don't want versions at all, you put a point at the end of it.

だからもし「HOGE」っていうファイル名を与えたら、これはつまり「HOGE のバージョンを全部見て、最新のヤツをもっといで」という意味。
Thus if you give the filename ``FOO'' it means ``Search the versions that exists for FOO and take the latest one''.

でも「HOGE.」といえば、「純粋に HOGE という名前だけのファイルを持っといで、それ以外はいらないよ」ってこと。
But if you say ``FOO.'' it means ``use exactly the name FOO and none other''.

「HOGE.3.」ってのは「ずばり HOGE.3 って名前のファイル」で、これはもちろん HOGE のバージョン3そのもの。
If you say ``FOO.3.'' it says ``use exactly the name FOO.3 '' which of course is version three of FOO and none other.

出力では、単に「HOGE」といったら、これはいずれ「HOGE」の新しいバージョンをつくるけれど、でも「HOGE.」と指定すれば、純粋に「HOGE」という名前のファイルに書き込む。
On output, if you just say ``FOO'', it will eventually create a new version of ``FOO'', but if you say ``FOO.'' it will write a file named exactly ``FOO''.

さて、細かいところを全部つめて、問題が残ってないかとか、UNIX がファイル名にピリオドをつけたらいかれるかかなんとか、同じ行動をさせるようにするには、いろいろまだハードルが残ってはいる。
Now there's some challenges involved in working out all the details in this, and seeing whether there are any lingering problems, whether some UNIX software actually breaks despite feeding them names with points in them and so on, to try to make it get the same behavior.

出力用に、名前がピリオドで終わるファイルを開いたら、その名前をすぐに開いて、だから同じ UNIX の振る舞いが得られるようにしたい。
I would expect that when you open a file for output whose name ends in a point, you should actually open that name right away,

書きかけの出力がそのまま見えるようになって、でもピリオドで終わらない名前に出力したら、閉じたときには新しいバージョンがあらわれて、しかもそれを明示的に閉じないと新しいバージョンにならない。
so you get the so you get the same UNIX behavior, the partially written output is immediately visible, whereas when you output a name that doesn't end in a point, the new version should appear when you close it, and only if you close it explicitly.

システムがクラッシュしたとかなんとかで、ジョブが死んだためにファイルが閉じたら、それは名前が変わる。
If it gets closed because the job dies, or because the system crashes or anything like that, it should be under a different name.

そしてこのアイデアは、「スター・マッチング」に結びつけられる。
And this idea can be connected up to ``star matching'',

つまり、ピリオドで終わらない名前はバージョン番号のついてない名前とマッチするようになるってわけ。
by saying that a name that doesn't end in a point is matched against all the names without their version numbers,

だからあるディレクトリにこんなファイルがあったとしよう：
so if a certain directory has files like this:

ho.1　　ho.2　　ge.8
foo.1 foo.2 bar.8

ここで「*」と言ったら、それは：ho　　ge に相当する。
If I say ``*'', that's equivalent to foo bar

名前をとって、バージョン番号をそこから除いて、それで区別がつくものを選ぶから。
because it takes all the names and gets rid of their versions, and takes all the distinct ones.

でも「*.」といえば、絶対名を全部とってきて、それにピリオドをつけて、それに対してマッチしたのをさがす。
But if I say ``*.'' then it takes all the exact names, puts a point after each one, and matches against them.

だから存在する個別バージョンがすべてあてはまる。
So this gives me all the names for all the individual versions that exist.

同じようにして「*.c」と「*.c.」のちがいもわかるよね。
And similar, you can see the difference between ``*.c'' and ``*.c.''

こいつ（最初の）は基本的にバージョンなしの「.c」ファイルすべてをさすんだけど、こいつ（二番目）は全バージョンをさす……わけじゃないな、それだと「*.c.*.」とやんなきゃいけないのか。
this [the first] would give you essentially versionless references to all the ``.c'' files, whereas this [the second] will give you all the versions ..... well this actually wouldn't, you'd have to say ``*.c.*.''.

まだ細かいところはつめきってないんだ。
I haven't worked out the details here.

もう一つ、ユーザからは見えない機能でしかも確実に互換性があるのが、ファイルシステムのフェイルセーフさってこと。
Another thing, that isn't a user visible feature and is certainly compatible to put in, is failsafeness in the file system.

つまり、全情報をディスクにちゃんとした順序で書けば、うまくそれができれば「停止」ボタンをいつ押しても、それでディスク上のファイルシステムがいかれるようなことは絶対ないふうにできる。
Namely, by writing all the information on disk in the proper order, arranging that you can press ``halt'' at any time without ever corrupting thereby the file system on disk.

これのやりかたはよく知られてる。
It is so well known how to do this,

なんでみんなそれを無視するのか、想像もつかないよ。
I can't imagine why anyone would neglect it.

もう一つのアイデアは、さらに情報の冗長性をもたせる。
Another idea is further redundant information.

これをやるかどうかはよくわからないけど、でも各ファイルに名前を全部入れて、だからディスク上のディレクトリが壊れても、それをディスクのほかの中身から再構築することが可能になるようにする方法について、ちょっと考えがあるんだ。
I'm not sure whether I'll do this or not, but I have ideas for how to store in each file all of its names, and thus make it possible if any directory on disk is lost, to reconstruct it from the rest of the contents of the disk. 

あと、ファイルの任意の一部を細かく（atomically）更新できるようにするにはどうしたらいいか、ぼくはわかってるつもりだ。
Also I think I know how to make it possible to atomically update any portion of a file.

つまりファイルの一部分を新しいデータで更新して置き換えるときに、それだとファイルを読もうとすれば、見えるのは古いデータだけとか新しいデータだけとかね。
Thus if you want to replace a certain subrange of a file with new data in such a fashion that any attempt to read the file will either see only the old data, or only the new data.

できると思う。
I believe I can do that,

しかもファイルをロックしたりとかもしなくてね、ぜんぜん。
without any locking even.

ネットワークのサポートとしては、いずれこのシステム用に TCP/IP を実装するつもり。
For network support, I intend eventually to implement TCP/IP for this system.

それと実質的に UUCP に相当するものとして、KERMIT がつかえると思う。
I also think it's possible to use KERMIT to get something effectively equivalent to UUCP.

シェルは確かもう書き上がってるはず。
A shell I believe has already been written.

二つのモードがあって、一つは BOURNEシェル風で、同じプログラムが別のモードでは C シェル風になる。
It has two modes, one imitating the BOURNE shell, and one imitating the C-shell in the same program.

まだこいつはぼくの手元には届いてないから、どのくらい手をかけなきゃなんないかもわかんないや。
I have not received a copy of it yet, and I don't know how much work I'll have to do on it.

それ以外にもたくさんユーティリティがある。
Also many other utilities exists.

MAKE はあるし、LS も、あとBISON っていう YACC にかわるものもあって、配布されてる。
A MAKE exists, LS, there's a YACC replacement called BISON which is being distributed.

LEX にかなり近いものもできてるんだけど、完全に互換性はないので、ちょっと作業が必要。
Something pretty close to a LEX exits, but it's not totally compatible, it needs some work.

そして全体として、これからやんなきゃならないことは、もう済んだことよりはずっと少ないんだけれど、でもまだまだたくさん手伝いがいるんだ。
And, in general what remains to be done is much less that what's been done, but we still need lots of people to help out.

みんながしょっちゅうきくのが「いつになったら完成するの」ってこと。
People always ask me ``When is it going to be finished?''

もちろんぼくだって、いつできんのかなんてわかりゃしないけど、これはぼくにすべき正しい質問じゃない。
Of course I can't know when it's going to be finished, but that's the wrong question to ask me.

もしその人がそれにお金を払う気なら、そりゃずばりどんなものをいつ手に入れられるか知りたがるのは当然だ。
If you were planning to pay for it, it would make sense for you to want to know exactly what are you going to get and when.

でも、お金を払うことにはならないんだから、きみたちがきくべき正しい質問は「もっとはやく完成させるために、どんな手伝いをしたらいいですか」なんだ。
But since you're not going to pay for it, the right question for you to ask is ``how can you help make it get finished sooner?''

プロジェクトのリストがあって、MIT のファイルにおいてあるんだけど、手伝いたい人はこのインターネットアドレスにメールをくれれば、プロジェクトのリストを送ってあげる。
I have a list of projects, it is on a file at MIT, and people who are interested in helping could send me mail at this Internet address, and I will send back a list of projects.

（こいつ、うまく動くかな（とチョークを見つめて言う）。
(I wonder if this is will work (looking at the chalk)).

これ、読める？
Is this readable?

RMS@GNU.ORG だよ
This is ``RMS@GNU.ORG''

（カラオケ風に色が変わる通り）。
(just follow the bouncing ball.)

で、ここでちょっと休憩といこうか。
And now let's take a break,

そして休憩が終わったら、ぼくはすごい問題発言をいろいろするからね。
and after the break, I will say some really controversial things.

いま帰っちゃだめだよ。
So don't leave now.

いま帰ったら、ホントの山場をみのがすからね。
If you leave now, you're going to miss the real experience.

[ここで15分休憩]
[Here we had a 15 min. break]

  ------------------------------------------------------------------------e

4 情報、ソフトと著作権


GNU ソフトの入手法を言っとくようにと言われた。
I've been asked to announce how you can get copies of GNU software.

で、一つの方法はもちろん、もしそれを持ってる友だちがいたら、それをコピーすればいいけど、でもそういう友だちがいなかったら、そしてインターネットにもつながってなかくて、だからFTP も使えないなら、配布テープを注文してフリーソフトウェア財団（FSF）にお金を送ってくれればいい。
Well, one way of course is if you know a friend who has a copy, you can copy it, but if you don't know a friend who has a copy, and you're not on the Internet, you can't FTP it, then you can always order a distribution tape, and send some money to the Free Software Foundation.

もちろん、フリーソフトは無料配布ってのとは別物なんだよ。
Of course free programs is not the same thing as free distribution.

この話はまたあとで詳しくやる。
I'll explain this in detail later.

ここに取り出しましたるは EMACS のマニュアルだけど、きれいに印刷製本したやつ。
Here I have an EMACS manual, of the nicely printed variety.

写真製版してオフセット印刷してある。
It has been phototypeset and then offset printed.

EMACS の配布パッケージに入ってるソースから自分で印刷してもいいし、こっちのやつを FSF から買ってくれてもいい。
Although you can also print it yourself from the sources that come in the EMACS distribution, you can get these copies from the Free Software Foundation.

あとでここにきて、こいつを見てみて、それとこれには注文書もあってあとでそれを写したりとか、あとこの（表紙の）絵もおもしろがってもらえたりする。
You can come afterwards and look at this and also this contains an order for you might copy some information from, and this [front] picture has also sometimes been enjoyed.

こいつ（と、絵の中でヌーにまたがったRMSに追いかけられてる人物を指さす）は、びびってるソフト隠匿者。
This [pointing at a figure being chased by RMS riding a gnu] is a scared software hoarder,

あとでこいつの話もしよう。
I'll be talking about him in a moment.

ソフトウェアってのは比較的新しい現象だ。
Software is a relatively new phenomenon.

人がソフトを配布し出したのは、せいぜい 30 年前かな。
People started distributing software perhaps thirty years ago.

だれかがそれを商売にしようと思いついたのは、たった 20年ほど昔だ。
It was only about twenty years ago that someone had the idea of making a business about it.

人がどうするかについて、なんの前例もないし、だれが何の権利を持ってるかもわからない世界だった。
It was an area with no tradition about how people did things, or what rights anybody had.

そして、アナロジーでほかの分野の伝統を持ち込めたんだけど、その際のアイデアがいくつかあった。
And there were several ideas for what other areas of life you might bring traditions from by analogy.

ヨーロッパの教授たちがお気に入りのアナロジーは、プログラムと数学とのアナロジー。
One analogy that is liked by a lot of professors in Europe, is that between programs and mathematics.

プログラムってのは一種の大きな数式みたいなもんだ。
A program is sort of a large formula.

さて伝統的には、だれも数式を所有したりはできない。
Now, traditionally nobody can own a mathematical formula.

だれでもそれを写して使える。
Anybody can copy them and use them.

一般の人にいちばん意味があるアナロジーは、料理のレシピだろう。
The analogy that's most meaningful to ordinary people is with recipes.

考えてみれば、日常生活でプログラムにいちばん近いものっていえばレシピなんだよ。
If you think about it, the thing that you have in ordinary life that's most like program is a recipe, it's instructions for doing something.

ちがいといえば、レシピは人が従うもので、機械が自動的にやることじゃないってこと。
The differences come because a recipe is followed by a person, not by a machine automatically.

確かにレシピにはソースコードとオブジェクトコードの差はないけれど、でもいちばん近いのは事実。
It's true there's no difference between source code and object code for a recipe, but it's still the closest thing.

そしてだれもレシピを所有することは認められていない。
And no-one is allowed to own a recipe.

でも選ばれたアナロジーは、本とのアナロジーで、本には著作権がある。
But the analogy that was chosen was the analogy with books, which have copyright.

そして、なぜそれが選ばれたのか？
And why was this choice made?

それは、この選択をすることでいちばん利益を被る人が選択権を与えられたからだ。
Because the people that had the most to gain from making that particular choice were allowed to make the decision.

プログラムを使う人じゃなくて、書く人が決定を認められて、そしてみんなはまったくの利己的な決断をくだして、おかげでプログラミングの世界は醜いところに変わってしまった。
The people who wrote the programs, not the people who used the programs, were allowed to decide, and they decided in a completely selfish fashion, and as a result they've turned the field of programming into an ugly one.

ぼくがこの世界に入ってきたとき、1971 年に MIT で働きだしたとき、ぼくたちの開発したプログラムが共有されないかもなんて考えは、議論すらされなかった。
When I entered the field, when I started working at MIT in 1971, the idea that programs we developed might not be shared was not even discussed.

そしてスタンフォードも CMU もみんな、DIGITAL でさえそうだった。
And the same was Stanford and CMU, and everyone, and even DIGITAL.

当時のDIGITAL からの OS は無料だった。
The operating system from DIGITAL at that time was free.

それにぼくも、PDP-11 クロスアセンブラとかあれこれプログラムをもらうことがよくあって、それをポートして ITS で動くようにして、いろんな機能も加えた。
And every so often I got pieces of program from DIGITAL system such as a PDP-11 cross assembler, and I ported it to run on ITS, and added lots of features.

そのプログラムには版権はなかったんだ。
It was no copyright on that program.

こいつが変わりはじめたのは、やっと 1970 年代後半に入ってからのことなんだよ。
It was only in the late seventies that this began to change.

ぼくはぼくらの共有精神にはすごく感激した。
I was extremely impressed by the sharing spirit that we had.

ぼくたちは、願わくば役に立つことをやっていて、人々がそれを使えれば幸せだった。
We were doing something that we hoped was useful and were happy if people could use it.

だから最初の EMACS を開発したとき、MIT の外の人がそれを使いたいな、と言い出したとき、ぼくはそれがEMACS「コミューン」のものだ、だから EMACS を使うにはそのコミューンの一員じゃなきゃだめで、それはつまり、自分が改良を加えたらそれを貢献する責任があるんだという意味だよ、と言った。
So when I developed the first EMACS, and people wanted to start use it outside of MIT, I said that it belongs to the EMACS ``Commune'', that in order to use EMACS you had to be a member of the commune, and that meant that you had the responsibility to contribute all the improvements that you made.

オリジナルの EMACS への改良はすべてぼくに送らなきゃならなかったんだ。
All the improvements to the original EMACS had to be sent back to me

そうすれば新しいバージョンの EMACS にそれを入れて、コミュニティの全員がメリットを得られる。
so that I could incorporate them into newer versions of EMACS, so that everyone in the community could benefit from them.

でも CMU で SCRIBE が開発されて、それが会社に売られたときに、これが破壊されはじめた。
But this started to be destroyed when SCRIBE was developed at CMU, and then was sold to a company.

これはいろんな大学のぼくたちみんなにとって大問題だった。
This was very disturbing to a lot of us at many universities,

みんなの目の前に大きな誘惑がおかれて、協力をやめるのがすごく儲かるようになって、協力を信じているぼくたちは、協力するように説得する材料がなにもなかった。
because we saw that this was a temptation placed in front of everyone, that it was so profitable to be uncooperative and those of us who still believed in cooperation had no weapon to try to compel people to cooperate with us.

はっきりと、一人また一人と、寝返って社会との協力をやめて、ぼくたちの中ですごく良心の強い人だけが協力を続けるだけになるだろう。
Clearly, one after another, people would defect and stop cooperating with the rest of society, until only those of us with very strong consciences would still cooperate. 

そしてまさにそうなったわけ。
And that's what happened.

プログラミングの世界は醜いところになっちゃったよね。
The field of programming has now become an ugly one,

みんなシニカルで、同じ分野の人たちやユーザに意地悪にしたらいくら儲かるかな、と考えてる。
where everyone cynically thinks about how much money he is going to get by not being nice to the other people in the field, and to the users.

ぼくは、ソフトを所有するという慣行は物質的にも無駄が多く、精神面でも社会的に有害で邪悪なものだと断言したい。
I want to establish that the practice of owning software is both materially wasteful, spiritually harmful to society and evil.

この 3 つはすべて相互に関係しあってる。
All these three things being interrelated.

なぜ精神的に有害かと言えば、それはコンピュータに触れるあらゆる社会人にかかわるからで、その接触を明らかに他人に対して無駄の多い形でやらせる慣行だからだ。
It's spiritually harmful because it involves every member of society who comes in contact with computers in a practice that is obviously materially wasteful to other people.

そして自分だけの利益のために何かをして、しかもそれが自分の助かるよりも他人に害を与えるほうが大きいことを知ってやるたびに、心の中でそんなことを正当化するために、きみはシニカルになるしかない。
And every time you do something for your own good, which you know is hurting other people more that it helps you, you have to become cynical in order to support such a thing in your mind.

そしてそれは、意図的に社会で行われた作業を無駄にするものであり、社会の退廃を招いているがゆえに邪悪なんだ。
And it's evil because it is deliberately wasting the work done in society and causing social decay.

まず、ソフトウェアとか、その他一般的に役に立つ情報を所有しようとすることで、どんな害が生じるかを説明しよう。
First I want to explain the kinds of harm that are done by attempts to own software and other information that's generally useful,

それからその慣行を弁護するような議論に反論して、この現象とどうやって闘えばいいか、そしてぼくがどうやって闘ってるかを話そう。
then I'll go on to rebut the arguments made to support that practice, and then I want to talk about how to fight that phenomenon, and how I'm fighting it.



4.1 ソフトの所有とその害

情報の所有という考え方は、3つの異なるレベルで有害だ。
The idea of owning information is harmful in three different levels.

3 つのレベルで物質的に有害だし、それぞれの物質的な害は、対応する精神的な害を伴う。
Materially harmful on three different levels, and each kind of material harm has a corresponding spiritual harm.

最初のレベルでは、それは単に、利用者がそのソフトを使うのをじゃまするんだけど、実は使う人が少なくてもプログラミングの作業が減るわけじゃない。
The first level is just that it discourages the use of the program, it causes fewer people to use the program, but in fact it takes no less work to make a program for fewer people to use.

プログラムの利用にお値段がついたらこれはみんながプログラムを使わないインセンティブ、というのはこの手のソフト隠匿者どもが大好きなことばなんだけど、使わないインセンティブになって、これは無駄だ。
When you have a price on the use of a program this an incentive, that's the word these software hoarders love to use, the price is an incentive for people not to use the program, and this is a waste.

たとえばあるプログラムにお値段がついて、だから使う人間の数が半減しちゃったら、プログラムの半分は無駄になったことになる。
If for example only half as many people use the program because it has a price on it, the program has been half wasted.

同じだけの作業が、半分の富しかつくりださなかったんだから。
The same amount of work has produced only half as much wealth.

さて実は、プログラムが使いたい人みんなに出回るようにするには、特別なことは何もしなくていい。
Now in fact, you don't have to do anything special to cause a program to get around to all the people who want to use it, 

みんなコピーくらい自分でちゃんとできるし、だからいずれはみんなの手に入る。
because they can copy it themselves perfectly well, and it will get to everyone.

プログラムを書いたら、あとはすわってて、みんなのしたいようにさせればいいの。
All you have to do after you've written the program is to sit back and let people do what they want to do.

でも、そうはならない。
But that's not what happens;

かわりにだれかが意図的にプログラムの共有を妨害しようとする。
instead somebody deliberately tries to obstruct the sharing of the program,

そしてそれどころか、そいつが妨害しようとするだけじゃなくて、ほかの人を手伝わせるよう圧力かける。
and in fact, he doesn't just try to obstruct it, he tries to pressure other people into helping.

ユーザが守秘契約にサインしたら、その人は要するにほかの仲間のユーザたちを売り渡したってことだ。
Whenever a user signs a nondisclosure agreement he has essentially sold out his fellow users.

黄金律にしたがって
Instead of following the golden rule and saying,

「ぼくはこのソフトが好きだ、ぼくの隣人もこのソフトが気に入るだろう、だから二人ともそれが持てるようにしよう」
``I like this program, my neighbor would like the program, I want us both to have it'',

というかわりに、そいつはこう言ってるんだ。
instead he said,

「いいよ、おれにくれよ。
``Yeah, give it to me.

隣人なんか地獄に堕ちろ！　
To hell with my neighbor!

おれもそいつを隣人の手に入らないようにするのに手を貸すからさ、とにかくおれにくれ！」　
I'll help you keep it away from my neighbor, just give it to me!'',

そしてこの精神が、精神的に有害なんだ。
and that spirit is what does the spiritual harm.

この「隣人なんか地獄に堕ちろ、このおれにコピーをよこせ」という態度が。
That attitude of saying, ``To hell with my neighbors, give ME a copy''.

守秘契約とかなんとかにサインしたからってんでぼくに何かのコピーをくれないような人に出くわしてから、ほかのだれかがぼくにその手のものにサインしろって言ったときには、そんなのがまちがってるのはわかった。
After I ran into people saying they wouldn't let me have copies of something, because they had signed some secrecy agreement, then when somebody asked me to sign a thing like that I knew it was wrong.

自分がやられてあんなに腹がたったことを、このぼくが人にやれるわけないでしょ。
I couldn't do to somebody else the thing that had made me so angry when it was done to me.

でもこれは、害の中で最初のレベルにすぎない。
But this is just one of the levels of harm.

第二のレベルは、人がプログラムを変えたいときに生じる。
The second level of harm comes when people want to change the program,

だって、使いたい人みんなに完全にあったプログラムなんてないもの。
because no program is really right for all the people who would like to use it.

人は料理に手を加えるでしょ。
Just as people like to vary recipes,

塩を減らすとか、ちょっとピーマンを入れるとかさ、同じように、プログラムだって自分のほしい効果を得るには手直しがいるんだ。
putting in less salt say, or maybe they like to add some green peppers, so people also need to change programs in order to get the effects that they need.

さて、ソフト所有者たちは、人がプログラムを変えようがどうしようが、実はぜんぜん気にしてないんだけれど、ただ連中の目的のためには、人にそんなことをさせないほうが都合がいい。
Now, the software owners don't really care whether people can change the program or not, but it's useful for their ends to prevent people.

ソフトが独占ソフトだと、ソースは手に入らないし、変えられないし、おかげでプログラマにとってはすごく無駄な作業が増えて、ユーザもいらいらがつのる。
Generally when software is proprietary you can't get the sources, you can't change it, and this causes a lot of wasted work by programmers, as well as a lot of frustration by users.

たとえば、何ヶ月も銀行でプログラマやって、新しいプログラムを書いてた友だちの話なんだけど、
For example: I had a friend who told me how she worked for many months at a bank where she was a programmer, writing a new program.

それにはほとんど大丈夫な市販ソフトがあったんだけれど、でもかれらの求めるものそのものってわけじゃなくて、その差があるおかげで、その市販ソフトは使いものにならなかったんだ。
Now, there was a commercially available program that was almost right, but it was just not quite the thing they needed, and in fact as it was it was useless for them.

そこの部分だけ変える労力はほんのわずかですんだだろうね。
The amount of change it would have taken to make it do what they needed was probably small,

でもそのプログラムのソースがなかったから、それは不可能だった。
but because the sources of that program were not available, that was impossible.

彼女はゼロからはじめるしかなくて、だからたくさん仕事を無駄にした。
She had to start over from scratch and waste a lot of work.

世界でこんな風に時間を無駄にしているプログラマが、どのくらいいるのかは神のみぞ知る、だよね。
And we can only speculate about what fraction of all the programmers in the world are wasting their time in this fashion.

それと、あるソフトがその場しのぎには使えるけれど、でもしっくりこないことがある。
And then there is also the situation where a program is adequate make do, but it's uncomfortable.

たとえば MIT にはじめてグラフィックプリンタがきたとき、ソフトは自分で書いて、いろいろすてきな機能をつけたんだ。
For example: The first time we had a graphics printer at MIT, we wrote the software ourselves, and we put in lots of nice features, 

たとえば自分のジョブが印刷し終わったらメッセージを送ってくれるとか、自分のジョブがキューに入ってる時に紙切れになったら教えてくれるとか、ほかにもいろいろほしいような機能を入れた。
for example it would send you a message when your job had finished printing, and it would send you a message if the printer ran out of paper and you had a job in the queue, and lots of other things that were what we wanted.

その後、もっとずっといいグラフックプリンタが入って、最初のレーザプリンタだったんだけど、でもそのソフトは Xerox のもので、それは変えられなかった。
We then got a much nicer graphic printer, one of the first laser printers, but then the software was supplied by Xerox, and we couldn't change it.

で、そういう機能とかも入れてくれないし、ぼくたちが足すこともできなかったし、だから「その場しのぎ」の代物で我慢しなきゃならなかった。
They wouldn't put in these features, and we couldn't, so we had to make do with things that ``half worked''.

自分たちには、それをなおす意志もやる気も能力も十分にあることがわかってるのに、それが許されてないってのは、すごくいらだたしかったね。
And it was very frustrating to know that we were ready, willing and able to fix it, but weren't permitted.

これって妨害工作だよ。
We were sabotaged.

それと、コンピュータを使ってるのに、コンピュータはわけわからん、仕組みがわからんと言う人がたくさんいる。
And then there are all the people who use computers and say that the computers are a mystery to them, they don't know they work.

うん、そりゃわかりっこないよね。
Well how can they possibly know?

自分の使ってるソフトが読めないんだもん。
They can't read the programs they're using.

プログラムの正しい書き方を学ぶ唯一の方法、そしてプログラムがどう動いてるのかを知る唯一の方法は、ソースコードを読むことなんだもん。
The only way people learn how programs should be written, or how programs do what they do, is by reading the source code.

だから思うんだけど、コンピュータをただの道具としてしか考えない利用者ってのは、実はソースコードを秘密にしとく習慣のせいで生まれた、ニワトリか卵か式の悪循環なのかもしれないよ。
So I could only wonder whether the idea of the user who just thinks of the computer as a tool is not actually a self-fulfilling prophecy, a result of the practice of keeping source code secret.

さてこの種の物質的害に伴う精神的な害は、自分さえよければという精神だ。
Now the spiritual harm that goes with this kind of material harm, is in the spirit of self-sufficiency.

人が長時間コンピュータシステムを使ってると、そのコンピュータシステムの設定はその人が住まう都市になる。
When a person spends a lot of time using a computer system, the configuration of that computer system becomes the city that he lives in.

ちょうど自分の家や家具の配置が、その中ですむぼくたちの生活を規定するように、ぼくたちの使うコンピュータシステムもそうで、自分たちにあうようにコンピュータシステムを変えられなければ、ぼくたちの生活は実は他人に支配されてることになる。
Just as the way our houses and furniture are laid out, determines what it's like for us to live among them, so that the computer system that we use, and if we can't change the computer system that we use to suit us, then our lives are really under the control of others.

そしてこれに気がついた人は、ある意味でモラルが低下するんだ。
And a person who sees this becomes in a certain way demoralized:

「こういうのを変えようとしても無駄だよ、ずっとこうやってひどいままなんだから。
``It's no use trying to change those things, they're always going to be bad.

不満をいうのさえ無駄だ。
No point even hassling it.

とにかく時間をつぎ込んで……これがすんだらぼくがどっかへ行こう、そしてもうこのことは考えないようにしよう」　
I'll just put in my time and ..... when it's over I'LL go away and try not to think about it any more''.

公徳心ってのもがあるのに物事の改善が許されないと、結果としてこの手の精神、この手のやる気のなさが生じるんだ。
That kind of spirit, that unenthusiasm is what results from not being permitted to make things better when you have feelings of public spirit.

第三のレベルの害は、ソフトウェア開発者自身の間のやりとり。
The third level of harm is in the interaction between software developers themselves.

あらゆる知識分野は、人が他人の成果の上に積み上げられるときにいちばんはやく進歩する、でも情報の所有権は、まさに他人がそうしないようにするためにつくられてる。
Because any field of knowledge advance most when people can build on the work of others, but ownership of information is explicitly designed to prevent anyone else to doing that.

もし人が他人の成果に積み上げられたら、その所有権ははっきりしなくなって、だからみんな、その分野への新規参入がゼロからはじめるしかないように手を打って、おかげでその分野の進歩が大幅に後れる。
If people could build on other people's work, then the ownership would become unclear, so they make sure each new entry to the field has to start from the beginning, and thus they greatly slow down the advance of the field.

だからわかるでしょ。
So we can see:

表計算ソフトが別々の会社からたくさん出てるけど、みんなそれがそれまでどうやってきたのか見てみるという恩恵なしにやってる。
How many spreadsheet systems were made all by different companies, all without any benefit of understanding how it was done before?

そりゃ確かに、最初に書かれた表計算ソフトは完璧じゃなかった。
Yes it's true, the first spreadsheet written wasn't perfect.

たぶん、一部のコンピュータでしか動かなくて、なにかをするときにもいちばんいい方法ではやらなかった。
It probably only ran on certain kinds of computers, and it didn't do some things in the best possible way.

だから、それを部分的に書き換えたい人が出てくる理由はいろいろあったろう。
So there were various reasons why certain people would want to rewrite parts of it.

でも、自分の改善したいところだけを書き直せばいいんだったら、作業量はずっと少なくて済んだよね。
But if they had only to rewrite the parts that they really wanted to improve, that would have made for a lot less work.

システムのある部分をよくする方法は見えるかもしれないけれど、同じシステムの別の部分なんかぜんぜんマシにできないかもしれない。
You may see how to make one aspect of a system better, you may not see how to make another aspect of the same system any better,

いや、同じくらいのレベルに達するのだって、えらく苦労するかもしれない。
in fact you might have a great deal of trouble doing it as well.

自分の好きなところをとって、自分がひらめいた部分だけをやりなおせたら、あらゆる面で前より優れたシステムが手に入って、まったく新しいシステムを書くよりもずっと作業は減る。
Now if you could take the part that you like and redo only the part that you have an inspiration for, you could have a system that's better in all ways, with much less work than it now takes to write a completely new system.

そりゃシステムをゼロから書き直すといいこともあるのはみんな知ってる。
And we all know that system can often benefit from being completely rewritten,

でもそれは、古いのをまず読んでからの話だ。
but that's only if you can read the old one first.

だからプログラミング業界の人たちは、時間をたくさん無駄にする方法を編み出したわけで、おかげで表面上は、本当に必要なのよりもずっとたくさんのプログラマが必要になったように見える。
Thus, the people in the programming field have evolved a way of wasting a lot of their time and thus making apparently a need for more programmers than we really need.

なぜプログラマ不足なんてことが言われるのか？
Why is there a programmer shortage?

知的所有権のおかげで、プログラマたちは自分のやる仕事の半分を無駄にするような仕組みにしちゃったからだよ。
Because with intellectual property programmers have arranged to waste half the work they do, so we seem to need twice as many programmers.

だからみんなが知的所有権システムを指さして「ほら、こんなに雇用を生み出してる、産業がこんなにでかくなってるじゃないか」なんて言うけど、
And so, when people point to the system of intellectual property and say ``look at the large employment statistics, look at how big this industry is''

それが証明してるのは、実はみんながお金と時間をたくさん無駄にしてるってことなんだ。
what that really proves is that people are wasting a lot of money and time.

プログラマの生産性を上げる話をするときでも、高度なツールがどうのこうのといえば、連中は喜ぶけど、でもプログラマのやってるよけいなことを削ることで生産性をあげるって話になると、とたんに反対する。
If they talk about looking for ways to improve programmer productivity, they're happy to do this if it involves superior tools, but to improve programmer productivity by getting rid of the explicit things that is done to reduce programmer productivity, that they're against.

そうなったら雇われてるプログラマの数が減るからって。
Because that would reduce the number of programmers employed.

これってちょっと、分裂症じみた議論だと思わない？
There's something a little bit schizophrenic there.

そしてこのレベルの物質的害に対応する精神的な害は、科学的な協力精神に及ぼす害だ。
And the spiritual harm that corresponds to this level of material harm is to the spirit of scientific cooperation,

これは昔はすごく強くて、戦争してる国同士の科学者ですら協力を続けてた、自分たちがやってるのが戦争とは何にも関係なくて、人類の長期的なメリットのためなんだってのがわかってたから。
which used to be so strong that scientists even in countries that were at war would continue cooperating, because they knew that what they were doing had nothing to do with the war, it was just for the long term benefit of humanity.

最近じゃみんな、もう人類の長期的なメリットのことなんか気にもしない。
Nowadays, people don't care about the long term benefit of humanity any more.

プログラムの利用をじゃまするのがどんなことか理解するには、仮にここにサンドイッチがあって、食べられるけれど、食べてもなくならないとしよう。
To get an idea of what it's like to obstruct the use of a program, let's imagine that we had a sandwich, that you could eat, and it wouldn't be consumed.

あなたが食べて、別の人がその同じサンドイッチを食べて、何度でも食べて、それでも毎回もとのと同じだけ栄養がある。
You could eat it, and another person could eat it, the same sandwich, any number of times, and it would always remain just as nourishing as originally.

それでやるべきいちばんいいこと、このサンドイッチを使って何をすべきかといえば、おなかのすいた人たちがいるところにそれを持ってくことだ。
The best thing to do, the thing that we ought to do with this sandwich is carry it around to the places where there are hungry people;

なるべく多くの口にそれを与えて、なるべく多くの人の腹を満たすようにすることだ。
bringing it to as many mouths as possible, so that it feeds as many people as possible.

このサンドイッチを食べることに、値段なんか絶対つけちゃいけない。
By all means, we should not have a price to eat from this sandwich,

値段をつけたら金がなくて食べられない人が出てくるからで、そうしたらそれは無駄になる。
because then people would not afford to eat it, and it would be wasted.

プログラムってのはこのサンドイッチみたいなものなんだけれど、でももっといいもので、なぜかといえば同時にいろんなところにあって同時に食べられて、どんどん別の人に使ってもらえるから。
The program is like this sandwich, but even more so because it can be in many different places at once being eaten, used by different people one after the other.

このサンドイッチがみんなをあらゆる場所で永遠に食べてもらえるのに、だれかがそれを自分の所有物だと決めたせいで、それが実現できないでいるんだ。
It is as if this sandwich was enough to feed everyone, everywhere, forever, and that were not allowed to happen, because someone believed he should own it.



4.2 ソフト所有肯定論への反駁

さて、プログラムを所有できると信じてる人たちは、ふつうはそれを正当化するのに 2 つの議論を持ち出す。
Now, the people who believe that they can own programs, generally put forward two lines of argument for this.

最初の議論は、
The first one is

「おれが書いたんだ、おれの魂の申し子だ、わが心、わが魂がここにはこもってる。
``I wrote it, it is a child of my spirit, my heart, my soul is in this.

それを他人が奪い取るなんて？　
How can anyone take it away from me?

どこまでいってもこいつはおれのもんだ、おれのおれのおれのぉっ！」というやつ。
Wherever it goes it's mine, mine, MINE!!''.

でも不思議なことに、こういうこと言う人のほとんどは、そのソフトは勤め先の会社のものだっていう合意書にサインしてるんだよね。
Well, it's sort of strange that most of them signs agreements saying it belongs to the company they work for.

だからこれって、簡単に自分をごまかして何かが重要だと思いこんでしまえることの一つだと思う。
So I believe this is one of the things you can easily talk yourself into believing is important,

同じくらい簡単に、そんなのぜんぜん大事じゃないと自分を説得することもできるんだ。
but you can just as easily convince yourself it doesn't matter at all.

こういう人はこの論法を使って、人がこのプログラムを変えるやりかたまでコントロールする権利を要求するんだ。
Usually, these people use this argument to demand the right to control even how people can change a program.

「だれにもわたしの芸術作品をめちゃくちゃにさせてなるものか」って。
They say: ``Nobody should be able to mess up my work of art''.

じゃあ、これからつくろうと思ってる料理を発明した人が、それはその人の芸術作品だからってきみの料理の仕方をどうこうする権利があったらどうなると思う？
Well, imagine that the person who invented a dish that you plan to cook had the right to control how you can cook it, because it's his work of art.

塩を使わないようにしようと思っても、そいつは
You want to leave out the salt, but he says

「ダメダメ、
``Oh, no. 

わたしがこの料理を設計したんだから、これはこんだけ塩をいれなきゃダメ！」
I designed this dish, and it has to have this much salt!''

「でも、ぼくは医者に塩をとめられてるんですよ、
``But my doctor says it's not safe for me to eat salt.

どうしましょう？」
What can I do?''.

明らかに、プログラムを使ってる人のほうが、その現場に近いんだ。
Clearly, the person who is using the program is much closer to the event.

プログラムの利用はその人に直接はねかえってくるけど、それを書いた人には、一種のごく抽象的な関係しかない。
The use of the program affects him very directly, whereas it only has a sort of abstract relation to the person who wrote the program.

したがって、人々に自分自身のくらしをできる限り好きなようにさせるという趣旨からして、そういうことを決めるのはそのユーザであるべきなんだ。
And therefore, for the sake of giving people as much control as possible over their own lives, it has to be the user who decides those things.

連中の二番目の議論は、経済的なものだ。
The second line of argument they make is the economic one.

「プログラムを書いても報酬が得られないじゃないか」
``How will people get payed to program?''

と言うわけで、ここには確かにホントの問題がちょっとはある。
they say, and there's a little bit of real issue in this.

でも連中のいうことのかなりの部分は混乱してる。
But a lot of what they say is confusion.

そしてどこが混乱してるかっていうと、
And the confusion is, it's not at all the same to say

「たくさんの人がプログラミングするようにしたいなら、ほかの手段で生計をたてなくてもいいような仕組みをつくらなきゃ」
``if we want to have a lot of people programming we must arrange for them not to need to make a living in any other fashion''

というのと、その一方では
on the one hand, and to say

「いまのシステムじゃなきゃダメだ、プログラミングで金持ちにならなきゃ」
``We need to have the current system, you need to get rich by programming''

というのとでは、話がまるっきしちがうってこと。
on the other hand.

生きてけるだけの賃金を得るのと、少なくとも最近のアメリカのプログラマがもらってるような給料をもらうってのとでは、話がぜんぜんちがう。
There's a big difference between just making a living wage and making the kind of money programmers, at least in the US make nowadays.

みんながいつも言うのは
They always say:

「じゃあおれはどうやって喰ってけばいいんだ？」
``How will I eat?'',

ってことだけれど、実際には
but the problem is not really how

「こいつは食えるか」
``Will he eat?'',

ってことじゃなくて「こいつは寿司（訳注：高くて高級なぜいたくな飯という意味）が食えるか」
but ``How will he eat sushi?''. 

ってことで、「雨つゆがしのげるか」
``How will I have a roof over my head?'',

ってことじゃなくてホントに言いたいのは
but the real problem is

「高級マンションが買えるか」ってことなんだ。
``How can he afford a condo?''.

いまの方式は、最大限の儲けを得るためにソフト開発に投資しようと思った人の選んだシステム。
The current system were chosen by the people who invest in software development, because it gives them the possibility of making the most possible money,

システム開発をサポートするための唯一の方法だからこうなってるわけじゃないんだ。
not because it's the only way anyone can ever come up with money to support a system development effort.

実は、ほんの 10 年とか 15 年とか前のごく最近までは、ソフト開発をほかの方法でサポートするのがあたりまえだったんだ。
In fact, even as recently as ten and fifteen years ago it was common to support software development in other ways.

たとえばDIGITAL の OS は 1970 年代初期までフリーだったけれど、フリーの OS ってのは、70 年代初期ですら、ちゃんと給料もらってる人が開発してたんだよ。
For example, those DIGITAL operating systems that were free, even in the early seventies, were developed by people who were paid for their work.

役に立つプログラムの多くは大学で開発されてる。
Many useful programs has been developed at universities.

最近だとこういうプログラムは売られることが多いけど、15 年前ならふつうはフリーで、それでもみんな給料がもらえてたんだ。
Nowadays those programs are often sold, but fifteen years ago they were usually free, yet the people were paid for their work.

プログラムみたいなものだと、これは無限サンドイッチとか、道とかみたいなもので、一回はつくらなきゃダメだけど、一度つくったらもうそれを何回使おうが関係なくて、使うのにコストもかかんないなら、使うのに値段なんかつけないほうが一般的にいい。
When you have something like a program, like an infinite sandwich, like a road, which has to be built once, but once it is built it pretty much doesn't matter how much you use it, there's no cost in using it, generally it's better if we don't put any price on using it.

そして、いまでもぼくたちがつくって、作った人に金を払うようなそういうものってのはたくさんある。
And there are plenty of those things that we develop now, and pay people to build.

たとえばそこらの道がそうだよね。
For example, all the streets out there.

お金を払わずに道を造ってくれる人を見つけるのは無理だ。
It's very easy to find people who will program without being paid; it really is impossible to find people who will build streets without being paid.

道をつくるのはプログラミングとちがってクリエイティブじゃないし、楽しくもない。
Building streets is not creative and fun like programming.

でも、世の中にはたくさん道があって、それに支払うだけの金も捻出されてる。
But we have plenty of streets out there, we do come up with the money to pay them,

そしてそのほうが、ずっといいよね。
and it's much better the way we do it

でもこういうことだってできる。
than if if we said:

「企業に道をつくらせて勝手に料金所をつけさせて、街角を曲がるたびに通行料を支払うようにしよう。
``Let's have companies go and build streets and put toll booths up, and then every time you turn another street corner, you pay another toll.

そしていい場所に道を敷いた企業は儲かって、そうでないのは倒産するようにしよう」
And then the companies that picked the good places to put their streets, they will be profitable, and the others will go bankrupt.''

だれかが、何かを隠匿することで大金を儲ける方法を編み出すと、変なことが起きる。
There's a funny thing that happens whenever someone comes up with a way of making lots of money by hoarding something.

それまでは、たぶんその分野にすごく情熱をもっていて、熱心に働く人たちがたくさんいたんだ。
Until that time you've probably had lots and lots of people who were really enthusiastic and eager to workin that field,

唯一の問題は、その人たちはそもそも喰っていけるのか、ということだけ。
the only sort of question is how can they get any sort of livelihood at all.

たとえば数学者を考えてみると、純粋数学者に支給されるお金よりも、純粋数学者志望者のほうがずっと多い。
If we think of mathematicians for example, there are a lot more people who want to be pure mathematicians than there is funding for anybody to be pure mathematicians.

そして支払われたとしても、大した額じゃないし、あまりいい暮らしもできない。
And even when you do get funding, you don't get very much, they don't live well.

ミュージシャンとなるともっとひどい。
And for musicians it's even worse.

時間の大半を費やしてミュージシャンになろうとしてる人が、平均的なミュージシャンでどのくらい稼いでるかっていう統計を見たことがある。
I saw a statistics for how much the average musician, the average person devoting most of his time trying to be a musician, in Massachusetts made;

マサチューセッツでは、確か州平均所得の半分以下だったんだよ。
it was something like half the median income or less.

かつかつで暮らしてけるくらいで、つらいよね。
It is barely enough to live on, it's difficult.

でも、そうしたがる人はたくさんいる。
But there are lots of them trying to do that.

そこへ、何かをすることですごくたくさん稼げるようになったとしよう。
And then, somehow when it gets generally possible to get very well paid to do something,

するとそういう人たちは消えて、みんなこう言うんだ。
all those people disappear, and people start saying

「そのくらい儲からなきゃ、だれもやりゃしないよ」
``nobody will do it unless they get paid that well''.

そしてぼくは、これがプログラミングの分野でおこるのを見てきた。
And I saw this happen in the field of programming.

AI 研で働いてて、大した給料もなかったのに仕事が大好きだった人たちが、いまでは年に 5 万ドルはもらわなきゃとても働けないよ、なんて言う。
The very same people who used to work at the AI lab and get payed very little and love it, now wouldn't dream of working for less than fifty thousand dollars a year.

どうしちゃったわけ？
What happened?

人の前に大金を儲ける可能性をぶら下げてやると、似たようなことをしてるほかの人たちが、そんだけの金を稼いでるのを見ると、みんな自分たちも同じくらい稼ぐべきだという気になって、だから昔ながらのやりかたを続けようという人はだれもいない。
When you dangle before people the possibility of making lots of money, when they see that other people doing similar work are getting paid that much money, they feel that they should get the same, and thus no-one is willing to continue the old way.

そしてこれが起きちゃったら、人に大金を払うしか手がないんだと思いこむのは簡単なんだけれど、でもそりゃちがう。
And it's easy after this has happened to think that paying people a lot of money is the only way it could be, but that's not so.

もし大金を儲ける可能性がなかったら、ちょっとのお金でもそれをやろうって人が出てくるだろう。
If the possibility of making a lots of money did not exist, you would have people who would accept doing it for a little money,

特にそれがクリエイティブでおもしろいことなら。
specially when it's something that is creative and fun.



4.3 ソフト隠匿との闘い

AI 研のユニークな世界が破壊されるのを見てきて、ソフトを売るのがその核心なんだってことも見てきたし、さらにはさっき説明したように、ああいう社会を手に入れるにはフリーソフトが必要なんだってことも見てきた。
Now I saw the unique world of the AI lab destroyed, and I saw that selling software was an intrinsic part of what had destroyed it, and I saw also, as I explained before, how you need to have free software in order to have a community like that.

でもそれからいろいろ考えてみて、ソフト隠匿がいろんな形で社会全てを傷つけることに思い当たったんだ。
But then thinking about it more, I realized all these ways in which hoarding software hurts all of society,

特に、人々に隣人を売り渡すよう圧力をかけて、それが社会の退廃を招いてるってことに。
most specially by pressuring people to sell out their neighbors and causing social decay.

道で人が刺されてるのを見ても、黙ってようとするのと同じ精神だよ。
The same spirit that leads people to watch while somebody in the street is getting stabbed and not tell anyone.

そこらじゅうの企業がしょっちゅう示してるのがわかる、あの精神だよね。
The spirit that we can see so many companies all around us displaying all the time.

そして、ぼくは自分が道を選べるのがはっきりしてた。
And it was clear to me I had a choice,

その世界の一部となって、自分の送ってる人生について不幸に感じ続けるか、それともそれと闘うか。
I could become part of that world and feel unhappy about what I was doing with my life, or I could decide to fight it.

だからぼくは闘うことにした。
So I decided to fight it.

ぼくはキャリアを捧げて、ソフト共有コミュニティの再建に努めてきたし、一般にとって有用な情報を員臆するという現象を終わらせようと努力してきた。
I've dedicated my career to try to rebuild the software sharing community, to trying to put an end to the phenomenon of hoarding generally useful information.

そして GNU システムは、この目的達成のための手段なんだ。
And the GNU system is a means to this end.

社会的な目的のための、技術的な手段だ。
It is a technical means to a social end.

GNU システムによって、ぼくはソフト隠匿者どもの脅しに対してユーザたちにワクチンをあげたいんだ。
With the GNU system, I hope to vacinate the users against the threat of the software hoarders.

いま現在、この隠匿者どもは基本的に、人のコンピュータを粗大ゴミにしてしまう力を持ってる。
Right now the hoarders essentially claims the power to render a person's computer useless.

アメリカでは、だいたい 50 年くらい前に、マフィアとかでそういう連中がいた。
There used to be people in the US, most commonly about fifty years ago, they were in the Mafia,

店やバーに行って、特にもちろん違法なバーだよね。
they would go up to stores and bars, especially bars when bars were illegal of course.

それでこう言う。
They would go up and say:

「ここらへんじゃあ、最近火事が多いですなあ。
``A lot of places around here have been burning down lately.

あんたんとこも、火事なんかになったらいやだよねえ。
You wouldn't want your place to burn down, would you?

おれたちなら、あんたを火事から守ってやれるんだよ、月に 1,000 ドル払ってくれるだけで、ここで火事が起きないようにしてやるよ」
Well we can protect you from fires, you just have to pay us a thousand dollars a month, and we'll make sure you don't have a fire here''.

これがいわゆる「保護恐喝」ってやつ。
And this was called ``the protection racket''.

さていまはだれかがこう言う。
Now we have something where a person says

「なかなかいいコンピュータをお持ちですな、それでいろいろソフトも使ってらっしゃる。
``You got a nice computer there, and you've got some programs there that you're using.

さて、そのソフトに消えてほしくなければ、警察に追われる身になりたくなければ、わたしに 1,000 ドル払いなさい。
Well, if you don't want those programs to disappear, if you don't want the police to come after you, you better pay me a thousand dollars, 

そしたらこのプログラムをライセンス付きで売ってあげよう」
and I'll give you a copy of this program with a license'',

これが人呼んで「ソフト保護恐喝」。
and this is called ``the software protection racket''.

ホント、連中がなにやってるかといえば、ほかの人がやるべきことをしようとすんのをじゃましてるだけじゃん。
Really all they're doing is interfering with everybody else doing what needs to be done, 

なのに、連中はわれわれに対しても自分自身に対しても、自分たちがなにか有益な機能を果たしてるようなふりをしてみせてる。
but they're pretending as much to them selves as to the rest of us, that they are providing a useful function.

で、ぼくの願いは、ソフトウェア・マフィアの連中がやってきて
Well, what I hope is that when that software Mafia guy comes up and says,

「そのプログラムがコンピュータから消えてもいいのか？」
``You want those programs to disappear on your computer?'',

と言ったら、利用者たちが
the user can say

「おまえなんかもうこわくないぞ、
``I'm not afraid of you any more.

ぼくにはこのフリーの GNU ソフトがあるんだ。
I have this free GNU software,

もうおまえたちは手も足も出ないんだぞ」と言えることなんだ。
and there's nothing you can do to me now.''

さて、ソフト所有を正当化する議論として出てくるのが、みんなにものをつくるインセンティブを与えるってやつだ。
Now, one of the justifications people sometimes offer for owning software, is the idea of giving people an incentive to produce things.

ぼくは私企業の考え方には一般的に賛成だし、ほかの人が喜んで使ってくれるものをつくってお金を得たいな、と思うのにも賛成だけれど、ソフトの分野ではこれが収拾つかない状態になってきてる。
I support the idea of private enterprise in general, and the idea of hope to make money by producing things that other people like to use, but it's going haywire in the field of software now.

独占ソフトをつくるのは、同じプログラムをつくってそれをフリーにするのとでは、社会への貢献度がぜんぜんちがう。
Producing a proprietary program is not the same contribution to society as producing the same program and letting it be free.
Because writing the program is just a potential contribution to society.

社会の富への貢献が起こるのは、そのプログラムが使われたときだけなんだ。
The real contribution to the wealth of society happens only when the program is used.

プログラムが使われるのを妨害したら、その貢献は起きないんだ。
And if you prevent the program from being used, the contribution doesn't actually happen.

だから社会が必要としている貢献は、みんながえらくインセンティブをもってつくってる独占ソフトではなくて、ぼくたちが本当に求めてる貢献はフリーソフトで、ぼくたちの社会が収拾つかなくなっているのは、それがあまり役にたたないことをするインセンティブを人に与えて、役に立つことをするインセンティブをぜんぜん与えてないからだ。
So, the contribution that society needs is not these proprietary programs that everyone has such an incentive to make, the contribution we really want is free software, so our society is going haywire because it gives people an incentive to do what is not very useful, and no incentive to do what is useful.

だから私企業の基本的な考え方がここではおかしくなっていて、だから社会自体が神経症気味とさえ言えるかもね。
Thus the basic idea of private enterprise is not being followed, and you could even say that the society is neurotic.

だってさ、個人が他人に対して、その個人自身にとってよくない行動を推奨するとき、その人は神経症なんだから。
After all when an individual encourages in others behavior that is not good for that individual we call this a neurosis.

ここでは社会がそういうふうに行動してる。
Here society is behaving in that fashion,

プログラマに、社会にとってよくないことをするように奨励してるんだから。
encouraging programmers to do things that is not good for society.

ぼくは変わり者なんだ。
I'm unusual.

自分が社会のよき一員で、何かを社会に貢献していると感じていたいんだよ、うまいこと社会をカモにしてるなんて感じるよりはね。
I'd rather believe that I'm a good member of society and that I'm contributing something, than feel that I'm ripping society off successfully,

だからぼくは、いまの自分の道を選んだ。
and that's why I've decided to do what I have done

でもだれでも、自分が実は役にたってないことでお金をもらってるという気分は、多少なりともすっきりしないものを感じてるんだ。
But every one is at least a little bit bothered by the feeling that they are getting paid to do what's not really useful.

だから、こんなまちがったことをするためのインセンティブなんて考え方を擁護するのはやめて、みんなに正しいことを奨励するような仕組みを考えつく努力くらいはしようではないの。
So let's stop defending this idea of incentives to do the wrong thing and let's at least try to come up with arrangements to encourage people to do the right thing,

その正しいことってのは、フリーソフトをつくることなんだ。
which is to make free software.

ご静聴どうも。
Thank you.

  ------------------------------------------------------------------------

5 質疑応答

[このあと、RMS は一時間ばかり質問に答えた。
[After this RMS answered questions for about an hour.

ここには質疑応答のほんの一部しか入れていない。
I have only included a very few of the questions and answers in this version.

テープが悪かったし、そのすべてをまともに書き出す暇がなかったので、悪しからず]
The tape was bad, and I didn't have the time to do a proper job on all of it]

Q：だれかあなたを訴えたりとか、面倒を起こそうとしたことはありますか
Q: Has anyone tried to make problems for you?

A：そういうもめごとを唯一起こそうとしたのは、ゴスリング EMACS の持ち主、というか自称持ち主、詐称持ち主どもだけだな。
A: The only time anyone has tried to make a problem for me was those owners, so called, self-styled owners of Gosling Emacs.

それをのぞけば、あやをつける手がかりがないから、大して何もしようがないよね。
Aside from that they have no grounds to do so, so there is not much they can do.

ところで、あることを考えさせて、あることを考えなくさせるためにことばが使われてることに、みんなもっと注意してほしいなと思うんだ。
By the way, I'd like to call everyone's attention to the way in which people use language to try to encourage people to think certain thoughts and not think of others.

いまこの分野での用語は、自称詐称ソフトウェア所有者たちが選んだもので、なるべくソフトウェアを、所有物になる物質的ものと同じ物だと思わせて、そのちがいを見過ごすようにしてあるんだ。
Much of the terminology current in the field was chosen by the self-styled software owners to try to encourage you to try to make you see software as similar to material objects that are property, and overlook the differences.

これのいちばん明白な例が「海賊」ってことば。
The most flagrant example of this is the term ``pirate''.

よき市民として隣人とソフトを共有しようとする人間を表現するのに、「海賊」ということばを使うのは拒否してほしいんだ。
Please refuse to use to use the term ``pirate'' to describe somebody who wishes to share software with his neighbor like a good citizen.


話しそこねてたけど、
I forgot to tell you this:

著作権の考え方は印刷術の後に発明された。
The idea of copyright was invented after the printing press.

古代には、著者はおたがい自由にコピーしあってたし、それがまちがってるとも思われなかったし、すごい役にたったりもした。
In ancient times authors copied from each other freely, and this was not considered wrong, and it was even very useful:

一部の著者が後世に伝えられたのは、断片的ではあっても、その一部がほかの著作の中でまとまって引用されてたおかげなんだ。
The only way certain authors works have survived, even in fragments, is because some of them were quoted at length in other works which have survived.

これは、本というものが一部ずつ筆写するものだったからそうなった。
This was because books were copied one copy at the time.

10 部つくるのは、1 部つくるのの 10 倍手間がかかった。
It was ten times as hard to make ten copies as it was to make one copy.

そこへ印刷術が発明されて、だからといって人は本の筆写ができなくなったわけではないけれど、でも印刷するのに比べたら、筆写はえらく面倒で、実質的に不可能といってよくなったわけね。
Then the printing press was invented, and this didn't prevent people from copying books by hand, but by comparison with printing them, copying by hand was so unpleasant that it might as well have been impossible.

本が大量生産でしかつくれなくなったら、著作権が意味を持つようになってきて、そしてそれは読書大衆の自由を奪ったりもしなかった。
When books could only be made by mass production, copyright then started to make sense and it also did not take away the freedom of the reading public.

印刷術を持っていない一般大衆の一員である人は、どのみち本をコピーできなかったから、
As a member of the public who didn't own a printing press, you couldn't copy a book anyway.

著作権ができたって、別に自由を失うわけじゃなかった。
So you weren't loosing any freedom just because there were copyrights.

だから技術的な変化のために著作権が発明されて、道徳的にも筋が通ってたわけ。
Thus copyright was invented, and made sense morally because of a technological change.

いまはその反対の変化が起きてる。
Now the reverse change is happening.

情報の個別コピーがどんどんよくなってきてて、やがて技術が究極にまで進歩すれば、どんな情報でもコピーできるようになるというのが見えてきた。
Individual copying of information is becoming better and better, and we can see that the ultimate progress of technology is to make it possible to copy any kind of information.

 [テープを裏返すので中断]
[break due to turning of tape]

だからぼくたちは、著作権なんか無意味だった古代世界と同じ状況に戻ってるんだ。
Thus we are back in the same situation as in the ancient world where copyright did not make sense.

ぼくたちの所有物の概念を考えてみると、それは物質的なものからきている。
If we consider our idea of property, they come from material objects.

物質的なものは、ほぼ保存則にしたがう。
Material objects satisfy a conservation law, pretty much.

うん、確かにチョークは半分に折れるから、正確にはちがうし、すりへるし、消費もされる。
Yes it's true I can break a chalk in half, that's not it, and it gets worn down, it gets consumed.

でも基本的にこれは（と椅子を指さす）、椅子一脚だ。
But basically this is one chair [pointing at a chair].

指をパチンとならしてこれを二つにするわけにはいかない。
I can't just sort of snap my finger and have two chairs.

これをもう一つ手に入れるには、最初のやつをつくったのと同じようにつくるしかない
。
The only way to get another one is to build it just the way the first one was build.

原材料がもっといるし、もっと労働もいるし、だからぼくたちの所有物の考え方は、そういう事実にあてはまるよう、道徳的に納得がいくかたちで発展してきたんだ。
It takes more raw materials, it takes more work of production, and our ideas of property were evolved to make moral sense to fit these facts.

だれでもコピーできる情報なら、話はちがってくる。
For a piece of information that anyone can copy, the facts are different.

だからそれにあてはまる道徳的な態度もちがう。
And therefor the moral attitudes that fit are different.

ぼくたちの道徳的な態度というのは、何かをしたら人がどれだけ助かるか、人がどれだけ害を被るか考えることで決まってくる。
Our moral attitudes comes from thinking how much it will help people and how much it will hurt people to do certain things.

ものだと、この椅子をとってくことはできるけど、これをコピーすることはできない。
With a material object, you can come and take away this chair, but you couldn't come and copy it.

そしてきみがこの椅子をもっていったら、それで何かが生まれるわけじゃないから、これはまったく正当化できない。
And if you took away the chair, it wouldn't be producing anything, so there's no excuse.

だれかが「おれはこの椅子一脚をつくる作業をしたんだし、こいつを持てるやつが一人しかいないんなら、それはおれだろう」と言ったとしたら、
I somebody says: ``I did the work to make this one chair, and only one person can have this chair, it might as well me'',

確かにみんな「うん、そりゃ筋が通ってる」と言うだろう。
we might as well say: ``Yeah, that makes sense''.

だれかが「おれはこのディスクにビットを刻んだんだ、だからこいつおれから奪ったら承知しないぞ」と言ったら、
When a person says: ``I carved the bits on this disk, only one person can have this disk, so don't you dare take it away from me'',

うん、これも確かに筋が通ってる。
well that also make sense.

そのディスクを一人しか持てないんなら、じゃあそれはそのディスクの所有者でいいよ。
If only one person is going to have the disk, it might as well be the guy who owns that disk.

でもだれかがやってきてこう言ったとする。
But when somebody else comes up and says:

「あんたのディスクはこわさないよ、ただまったく同じものを魔法で作り出して、それを持ってくから、あんたはいままでどおりディスクを使えばいいんだよ」　
``I'm not going to hurt your disk, I'm just gonna magically make another one just like it and then I'll take it away and then you can go on using this disk just the same as before'',

そしたらこれは「ぼくは魔法の椅子コピー機を持ってて、きみはいままで通り椅子を楽しんですわったりできて、いつでも手元においとけて、でもぼくもその椅子が使えるんだ」というのとおなじで、
well it's the same as if somebody said: ``I've got a magic chair copier. You can keep on enjoying your chair, sitting in it, having it always there when you want it, but I'll have a chair too''.

これはいいことだ。
That's good.

つくんなくていいんなら、指をパチンと鳴らせば複製できるんなら、すばらしいことだ。
If people don't have to build, they can just snap their fingers and duplicate them, that's wonderful.

でもこの技術の変化は、個別コピーを所有して個別コピーで金を儲けようとする人にはお気に召さない。
But this change in technology doesn't suit the people who wants to be able to own individual copies and can get money for individual copies.

連中の考えは、保存する物体にしか通用しない。
That's an idea that only fits conserved objects.

だからなんとかプログラムを実体のある物質みたいにしようとする。
So they do their best to render programs like material objects.

ソフト屋にいってプログラムを買うと、なんか本みたいなものについてくるでしょう。不思議じゃない？
Have you wondered why, when you go to the software store and buy a copy of a program it comes in something that looks like a book?

あれはみんなに、自分が買ってるのが物体なんだと思ってほしくて、本当はデジタルのコピー可能なデータを手に入れたんだと気がつかないでほしいからなの。
They want people to think as if they were getting a material object, not to realize what they have really got in the form of digital copyable data.

コンピュータって結局のところ、万能マシンでしょ。
What is a computer after all but a universal machine?

たぶんみんな、ユニバーサルチューリングマシンについては勉強してるよね。
You've probably studied universal Turing machines, 

ほかのどんなマシンでも模倣できるマシンね。
the machines that can imitate any other machine.

万能マシンがすばらしいのは、ほかのマシンを模倣できるだけじゃなくて、その指示をコピーして変えられるってことだ。
The reason a universal machine is so good is because you can make it imitate any other machine and the directions can be copied and changed,

これってまさに、物質ではできないことだ。
exactly the things you can't do with a material object.

そしてこれがまさに、ソフトウェア隠匿者どもがみんなにやらせるまいとしてることなんだ。
And those are is exactly what the software hoarders want to stop the public from doing.

万能マシンという技術変化のメリットは享受したがってるくせに、一般社会にはそのメリットを手に入れさせたくないんだよ。
They want to have the benefit of the change in technology, to universal machines, but they don't want the public to get that benefit.

基本的に連中は「物の時代」を温存しようとしてるんだけれど、でもそんな時代はもう終わってる。
Essentially they are trying to preserve the ``material object age'', but it's gone,

だからぼくたちも、正しいとか間違ってるとかの考え方を、ぼくたちが住む世界の実状にあわせてシンクロさせるべきなんだ。
and we should get our ideas of right and wrong in sync with the actual facts of the world we live in.

Q：つまり結局のところ、情報の所有権の問題なんですね。
Q: So it boils down to ownership of information.

情報を所有することが正しいような場合というのは、あるんでしょうか。どう思います？
Do you think there are any instances where, you opinion, it's right to own information?

A： 一般的な利用価値のない情報なら、あるいは個人的な情報なら、所有オッケーだと思う。
A: With information that's not generally useful, or is of a personal nature, I would say it's OK.

言い換えると、なにかのやりかたじゃなくて、それでどうするつもりかという情報。
In other words not information about how to do things, but information about what you intend to do.

他人にとっての価値が疑わしいもの、あなたからお金をむしり取るには使えても、それで何かを作り出したりはできないような情報。
Information whose only value to others is speculative, that is they can take some money away from you, but they can't actually create anything with it.

ぼくに言わせれば、そういうものを秘密にして統制するのはまったく問題ない。
It's perfectly reasonable I'd say to keep that sort of thing secret and controlled.

でも創造に係わる情報、人が使って楽しめる情報、そしてそれを持ってる人が多ければ多いほど、もっと利用されて楽しまれるような情報、そういうのは必ずコピーを推奨すべきなんだ。
But in terms of creative information, information that people can use or enjoy, and that will be used and enjoyed more the more people who have it, always we should encourage the copying.





